(['replicate s z', 'replicate s zr', 'replicate s zro', 'replicate (\\lam _ => E) {?}'], 'replicate s (zro )')
(['top-univ <=∘ {?}', 'top-univ {?} {?}', 'top-univ {?}', 'top-univ <=∘ p'], 'top-univ <=∘ {?}')
(['terms-equality {{?}} (x1 :: x3 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* :inverse (var 1)))) (var 1) idp', 'terms-equality {{?}} (x1 :: x3 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* :inverse (var 1))))) (var 1) idp', 'terms-equality\n{{?}} (x1 :: x3 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* :inverse (var 1))))) (var 1) idp', 'terms-equality {{?}} (x1 :: x3 :: nil) (var 0 :* (varverse (var 0) :* (var 1 :* :inverse (var 1))))) (var 1) idp'], 'terms-equality\n  {{?}} (x1 :: x3 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* (var 1 :* :inverse (var 1))))) (var 1) idp')
(['<_*-left {?} {?}', '<_*-left {?} {?} {?}', '<_*-left {?} y<x', '<_*-left x<y y<x'], '<_*-left y<z z>0 x>0')
(['inverse-left {S2}', 'inverse-left {S1}', 'inverse-left S2', 'inverse-left {SS2}'], 'inverse-left {S2}')
(['\\lam {x} => {?}', '\\lam p => {?}', '\\lam {x} {x} => {?}', '\\lam {x} p => {?}'], '\\lam {x} => {?}')
(['~-pequiv {?}', '~-pequiv {?} {?}', '~-pequiv {?} id', '~-pequiv {?} idp'], '~-pequiv {?}')
(['isInNF {?}', 'isInNF (r, false)', 'isInNF (r, false) {?}', 'isInNF (r, isInNF (r, r))'], '\\case res-l.2 \\as b : case_return_arg_1_1 \\return (\\lam (_x : \\Sigma (GroupTerm V) Bool) => isInNF _x.1) case_return_arg_1 \\with {\n  | true => {?}\n  | false => {?}\n}')
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}) => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}'], 'rewrite (cons ) {?}')
(['<_*_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positi', '<_*_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_pos', '<_*_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positivegpositi', '<_*_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_positive_pos'], '<_*_positive_positive {RatField} {?} {?}')
(['<=<_<= {?} idp', '<=<_<= idp {?} idp', '<=<_<= S<=<_<= {?} idp', "<=<_<= V'<=<U"], "<=<_<= x'<=<V' idp")
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | inv p => {?}\n}', '\\case \\elim p \\with {\n  | inv => {?}\n}'], 'l (s1 * s2) {?}')
(['covergent-topAbGroup-char {?} {?}', 'covergent-topAbGroup-char {?} {?} {?}', 'covergent-topAbGroup-char {?}', 'covergent-topAbGroup-char.2 {?}'], 'convergent-topAbGroup-char 2 0 {?}')
(['\\lam x => {?}', '\\lam (x : X) => {?}', '\\lam x x => {?}', 'inverse {f}'], '\\lam _ => {?}')
(['real_<-rat-char.2 {?}', 'real_<-rat-char.1 {?}', 'real_<-rat-char {?} {?}', 'real_<-rat-char {?}'], 'real_<-rat-char.2 {?}')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', 'rewrite p i', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}'], 'Ag a0')
(['func-** {f}', 'func-*** {f}', 'func-** {f} {?}', 'func-*** {f} {?}'], 'func-** {f}')
(['{?} <=∘ {?}', '{?} <=∘  {?}', 'p y', 'p {?}'], 'p Uy')
(['inP (0, idp)', 'inP (n, idp)', 'inP (0, idp), idp)', 'inP (degree<= idp)'], 'inP (1, idp, idp)')
(['*c-assoc {B}', '*c-assoc {B} {?}', '*c-assoc {{?}}', '*c-assoc {A}'], '*c-assoc {B}')
(['\\lam {p0} p1 => {?}', '\\lam p0 => {?}', '\\lam p => {?}', '\\lam {p0} p2 => {?}'], '\\lam {p0} p1 => {?}')
(['add {?} {?}', 'add {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], '\\peval add {V} {B} v b l')
(['ActionBySubgroup {?}', 'ActionBySubgroup H', 'ActionBySubgroup {?} {?}', 'ActionBySubgroup {G} {?}'], 'ActionBySubgroup H')
(['toZero {R} {?} {?}', 'toZero {R} {?} {?} {?}', 'toZero {?} {?}', 'toZero  {?} {?}'], 'toZero {R} {g (l !! j).2} {conj a (f (l !! j).2)} p')
(['tupleBeta {P1} {?} {?}', 'tupleBeta {P1} {?}', 'tupleBeta {P} {?} {?}', 'tupleBeta {P1} {?} {?} {?}'], 'tupleBeta {P1}')
(['\\lam {y} p => {?}', '\\lam p => {?}', '\\lam {y} => {?}', '\\lam {y} {?} => {?}'], '\\lam d => {?}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => {?} {?}', 'prop-dpi (\\lam i => {?}) {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['true-over-obj ∘ proj2', 'rewrite (true-over-obj ∘ proj2) {?}', 'rewrite (true-over-obj ∘ proj2 ∘ proj2) {?}', 'rewrite (true-over-obj ∘ proj2 ∘ proj2) id {?}'], 'rewrite (prod-id-right ) {?}')
(['\\lam p0 => {?}', '\\lam p0 p1 => {?}', '\\lam p0 {p1} {p2} => {?}', '\\lam p0 {p1} p2 => {?}'], '\\lam p0 {p1} {p2} x*y=x*z => {?}')
(['{?} <=∘ {?}', '{?} <=∘  {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | inl p => {?}\n}'], 'x<=a <∘r a<xy')
(['Join-univ {?}', 'later {?}', 'p y', 'Join-univ <=∘ {?}'], 'x<<y {\\Sigma} {\\lam _ => y} {?}')
(['*c_zro-left {X}', '*c_zro-left {?}', '*c_zro-left {{?}}', '*c_zro-left {X} {?}'], '*c_zro-left {X}')
(['char-rel ', 'rewrite (hinv_f ) {?}', 'char-rel  {?} {?}', 'rewrite (hinv_f {a}) {?}'], 'rewrite (hinv_f {associator-iso }) {?}')
(['\\lam p => {?}', '\\lam x<=y => {?}', '\\lam {x} z<=y => {?}', '\\lam {x} {y} => {?}'], '\\lam p0 p1 => {?}')
(['trichotomy  x y y', 'trichotomy x y y', 'later {?}', 'trichotomy  (trichotomy ) {?} {?}'], '\\case trichotomy x y \\as t : case_return_arg_1_1 \\return (\\lam (e : E) => e <= z) case_return_arg_1 \\with {\n  | less _ => {?}\n  | equals p => {?}\n  | greater _x => {?}\n}')
(['rewrite ide {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | inv => {?}\n}', '\\case \\elim p \\with {\n  | inv p => {?}\n}'], 'cancel {?}')
(['limUnique {L} {?}', 'limUnique {L} {?} {?}', "limUnique {L'} {?}", "limUnique {L'}"], 'limUnique {?}')
(['--->_join ', '-->_join ', '--->_join  {?}', '-->_join  {?}'], '-->_join ')
(['{?} <=∘ {?}', '\\peval x * x', '\\peval x * x <=∘ {?}', '\\lam x<=y => {?}'], 'xx<=qx <=∘ {?}')
(['\\peval fromRat {?}', 'fromRat {?}', '\\peval rfunc n', '\\peval rfunc (suc n) - rfunc n'], '*-rat rat_<=-dec {?}')
(['\\lam p => {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}'], 'h x0 {eps * ratio 1 4} linarith')
(['cauchy-subset {?} {?}', 'cauchy-subset {?} {?} {?}', 'cauchy-subset {?} p', 'cauchy-subset {X} {?} {?}'], 'cauchy-subset p {?}')
(['<=-uniform {?} {?}', '<=-uniform {?} {?} {?}', '<=-uniform {?} {?} {?} {?}', '<=-uniform {U} {?} {?}'], '<=-uniform u {?} d')
(['func-cont ', 'func-cont {f} {?}', 'func-cont {f} {?} {?}', 'func-cont {func (zro )} {?}'], 'func-cont  OBall-open')
(['negative-right ', 'rewrite (negative-right ) {?}', 'negative-right  {?}', 'rewrite negative-right {?}'], 'negative-right ')
(['+-comm ', '+-comm {{?}}', '+-comm {X}', '+-comm {_}'], '+-comm ')
(['*-rat-locally-uniform {?} {?}', "*-rat-locally-uniform (d1', d2')) {?}", '*-rat-locally-uniform {?} {?} {?}', "*-rat-locally-uniform (d1', d2') <∘ {?}"], '(h {?} {?}).2')
(['+-assoc ', '+-assoc {X}', '+-assoc  {?}', '+-assoc {E}'], '+-assoc ')
(['<=<-left {?} {?}', '<=<-left {?} {?} {?}', '<=<-left  {?} {?}', '<=<-left p {?}'], '<=<-left {?} p')
(['\\lam p => {?}', '\\lam a => {?}', '\\lam b => {?}', '\\lam b<=s => {?}'], '\\lam c => {?}')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}', '\\case \\elim p0, \\elim p1 \\with {\n  | _, inP (x, idp) => {?}\n}', '\\case \\elim p0, \\elim p1 \\with {\n  | _, inP (x, p)) => {?}\n}'], '\\case \\elim p0 \\with {\n  | 0 => {?}\n  | 1 => {?}\n}')
(['zro-left ', 'zro-left {?}', 'zro-left  {?}', 'zro-left <∘ {?}'], 'zro-left {_} {a + zro}')
(['BigSum {?}', 'BigSum {?} {?}', 'BigSum-unique {?}', 'BigSum {ExUpperRealAbMonoid} {?}'], 'BigSum_zro {?}')
(['<=-antisymmetric  {?} {?}', '<=-antisymmetric {?} {?}', '<=-antisymmetric {?} {?} {?}', '<=-antisymmetric  {?} {?} {?}'], '<=-antisymmetric {ExUpperRealAbMonoid} {?} {?}')
(['terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 1) idp', 'terms-equality\n{{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 1) idp', 'terms-equality\n  {{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 1) idp', 'terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (vanverse (var 0) :* var 1)) (var 1) idp'], 'terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 1) idp')
(['\\lam p0 => {?}', '\\lam p => {?}', '\\lam p0 p1 => {?}', '\\lam p0 E => {?}'], '\\lam p0 => {?}')
(['terms-equality {{?}} (x0 :: x1 :: nil) :ide (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* var 0 :* :inverse (var', 'terms-equality {{?}} (x0 :: x1 :: nil) :ide (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* var 0 :* (var ', 'terms-equality {{?}} (x0 :: x1 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* var 0 :* :inverse (v', 'terms-equality {{?}} (x0 :: x1 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* var 0 :* :inve'], 'terms-equality\n{{?}} (x0 :: x1 :: nil) :ide (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* var 0 :* :inverse (var 0))))\n  idp')
(['FinSum {B} {?}', 'FinSum {B} {?} {?}', 'FinSum-unique {B} {?} {?}', 'FinSum-unique {B} {?}'], 'FinSumEquality {?}')
(['decideEq ratNom y', 'decideEq  y', 'decideEq x y', 'decideEq  y y'], 'decideEq (ratNom x) (ratNom y)')
(["r' i", '++_index-right i', 'rewrite ++_index-right {?}', '++_index-right {?}'], 'rewrite ++_index-right p')
(['inP (0, c)', 'inP (0, z)', 'inP (n, z)', 'inP (0, z, c)'], 'inP (n, z<-C)')
(['{?} <=∘  {?}', '{?} <=∘  p', '{?} <=∘ {?}', '{?} <=∘   {?}'], '{?} <=∘  {?}')
(['meet-monotone  {?} {?}', 'meet-monototone  {?} {?}', 'meet-monotone  {?} {?} {?}', 'meet-monotototone  {?} {?}'], 'meet-monotone  {?} {?}')
(['cover-trans {?} {?}', 'cover-trans {?} {?} {?}', 'cover-trans  {?} {?}', 'cover-trans  {?} {?} {?}'], 'cover-trans z<=y {?}')
(['inP {?}', 'inP (x, L<=y)', 'inP (x, \\case \\elim p \\with {\n  | inP (x, \\case \\elim p \\with {\n  | inP (x, \\case \\elim p \\with {\n  | inP (x, \\case \\elim p \\wi', 'inP (x, \\case \\elim p \\with {\n  | inP (x, \\case \\elim p \\with {\n  | inP (x, \\case \\elim p \\with {\n  | inP (x, \\case \\elim p => '], "inP (x, x.L-closed q<x q'<q, a<=x, x<=b, fx<=y)")
(['\\lam p => {?}', '\\lam c => {?}', '\\lam l => {?}', '\\lam c p => {?}'], '\\lam b => {?}')
(['\\lam {V} Vo => {?}', '\\lam {V} Vo V0 => {?}', '\\lam {V} p => {?}', '\\lam {V} {V} Vo => {?}'], '\\lam p0 => {?}')
(['zro-right {?}', 'zro-right {X}', 'zro-right {_} {Y.zero}', 'zro-right {_} {f (x.1 X.+ h X.*c a X.*c b, u3 {h} u.1)}'], 'zro-right {_} {f (x.1 X.+ h X.*c a X.+ h X.*c b, u3 {h} u.1)}')
(['<=u-trans-left {?} {?}', '<=u-trans-left {?} {?} {?}', '<=u-trans-left {?} p', '<=u-trans-left {?}'], '<=u-trans-left _ {?} meet-left')
(['univ_map {S} {?} {?}', 'univ_map {S} {G} {?} {?}', 'univ_map {S} {G} {?} {?} {?}', 'univ_map {S} i u1 G.* univ_map'], 'rewrite inverse-left {?}')
(['BigJoin-univ {B} {?}', 'BigJoin-univ {B}', 'BigJoin-char {B} {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], 'reduce_BigJoin {V} {B}')
(['prop-isProp {?} {?}', 'prop-isProp ', 'prop-isProp {?}', 'prop-isProp {?} {?} {?}'], 'prop-isProp (Func {op {functor {f {e}}}} h) {?}')
(['h {?}', 'h x', '\\lam p => {?}', 'h {?} {?}'], 'h1 s.1')
(['{?} <=∘  {?}', '{?} <=∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', 'rewrite (ide_*) {?}'], 'f {1 - w} g[1-w]=0')
(['dist-neighborhood.2 y', 'dist-neighborhood.1 y', 'dist-neighborhood.2 {?}', 'dist-neighborhood {X} {?} {?}'], 'dist-neighborhood G {?} {?} Gy {?}')
(['cover-trans {?} {?}', 'cover-trans {?} {?} {?}', 'cover-trans  {?} {?}', 'cover-trans {?} {?} {?} {?}'], 'cover-trans {?} {?}')
(['<=-square  {?} {?}', '<=-square  {?} {?} {?}', '<=-square ', '<=-square  {?} {?} {?} {?}'], '<=-square  q>0 {?}')
(['dist-symm {X}', 'dist-symm <∘r {?}', 'dist-symm <∘ {?}', 'dist-symm <∘l {?}'], 'rewrite dist-symm {?}')
(['byRight {?}', 'byRight p', 'byRight a<b', 'byRight {?} {?}'], 'byRight {?}')
(['\\lam l => {?}', '\\lam l j => {?}', '\\lam l p => {?}', '\\lam l q => {?}'], '\\lam l s => {?}')
(['prop-dpi (\\lam i => eps ) {?} {?}', 'prop-dpi (\\lam i => eps (\\lam i => eps)) {?}', '\\lam i => {?}', 'prop-dpi (\\lam i => eps (h2 i a)) {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['\\lam {D} Dc => {?}', '\\lam Dc => {?}', 'later {?}', 'SetLattice _'], '\\lam Dc => {?}')
(['closure-trans {?} idp', 'closure-trans {?} {?} idp', 'closure-trans {?} {?}', 'closure-trans A {?} idp'], "closure-trans AD' {\\lam V' W' => ∃ (\\Sigma (V : D) (W : E V) (P W') (V' ⊆ V) (W' ⊆ W))} {?} idp")
(['\\lam p0 => {?}', '\\lam p0 p1 => {?}', '\\lam p => {?}', '\\lam p0 => {{?}'], '\\lam p0 => {?}')
(['{?} <=∘ {?}', '\\lam p => {?}', '{?} <=∘  {?}', '{?} <=∘ {?} {?}'], 'rewrite ide-right {?}')
(['byLeft {?}', 'byLeft p', 'byLeft {?} {?}', 'byLeft Uo Uy'], 'byLeft {?}')
(['rewrite idp {?}', 'rewrite (idp) idp', 'rewrite idp idp', 'rewrite (idp) idp) idp'], 'rewrite (limBeta {L {C} {D} {J} {G} Y} (cone {C} {D} {J} {G} f) j) idp')
(['getAbs _', 'getAbs _ _', 'getAbs {?} {?}', '(getAbs _).2 {?}'], '(getAbs _).3')
(['decideEq a y', 'decideEq a x', 'decideEq a y y', 'decideEq a a'], 'decideEq a')
(['terms-equality {{?}} (x10 :: x1 :: x12 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* (:inverse (var 1) :* (var 2 :* var 3)) :* (:inv', 'terms-equality {{?}} (x10 :: x1 :: x12 :: x2 :: nil) :ide (var 0 :* (var 1 :* (:inverse (var 1) :* (var 2 :* var 3)) :* (:inver', 'terms-equality\n{{?}} (x10 :: x1 :: x12 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* (:inverse (var 1) :* (var 2 :* var 3)) :* (:inv', 'terms-equality {{?}} (x10 :: x1 :: x12 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* (:inverse (var 1) :* (var 2 :* var 3)) :* (var '], 'terms-equality {{?}} (x10 :: x1 :: x12 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* (:inverse (var 1) :* (var 2 :* var 3)) :* (:inverse (var 3) :* (:inverse (var 2) :* :inverse (var 0)))))\n  idp')
(['interior {Y} {?}', 'interior {X}', 'interior {X} {?}', 'interior {Y} {?} {?}'], 'interior {Y} {V}')
(['\\lam p => {?}', '\\lam e => {?}', '\\lam p0 => {?}', '\\lam x => {?}'], '\\lam s => {?}')
(['\\new LDiv {\n  | inv-right => \\lam p => {\n  | inv-right => \\lam p => {?}\n}', '\\new LDiv (pos n) {\n  | inv-right => \\lam p => {\n  | inv-right => inv-right \n}', '\\new LDiv (pos n) {\n  | inv-right => inv-right {\n  | inv-right => inv-right {suc n}\n}', '\\new LDiv {\n  | inv-right => \\lam p => {\n  | inv-right => \\lam p => {\n  | inv-right => inv-right \n}'], '\\new LDiv {\n  | inv => x div pos (suc n) - y div pos (suc n)\n  | inv-right => rewrite sum-cancel-right ldistr_-\n}')
(['func-top {{?}}', 'func-top ', 'func-top {ret f}', 'func-top {ret {?}'], 'func-top {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f ∘ reflectorMap X)}')
(['<=_*_positive_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative_negat', '<=_*_positive_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative  {?} ', '<=_*_positive_negative_negative_negative_negative_negative_negative_negative_negative_negative_negative  {?} {?}', '<=_*_positive_negative_negative_negative_negative_negative_negative  {?} {?}'], '<=_*_positive_negative {?} c<=0')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], '\\lam q => {?}')
(['later {?}', 'rewrite p2 idp', 'rewrite n=a2 {?}', 'rewrite (decideEq/=_reduce p) {?}'], 'rewrite p1 {?}')
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', 'dist-trial {X} {?} {?}', 'dist-trial {?} {?}'], '<=-less {?}')
(['{?} <=∘ {?}', '{?} <=∘ p', '\\lam p => {?}', '{?} <=∘ a'], '{?} <=∘ {?}')
(['<-rat.1 {?}', '<-rat.2 {?}', '<-rat.1 {?} {?}', '<-rat.2 <-rat'], '<-rat.1 {?}')
(['linearMap {?} {?}', '\\case \\elim p \\with {\n  | byLeft => {?}\n}', '\\new LinearMap {\n  | R => R\n  | Dom => U\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => \\lam j => basis-split ', '\\new LinearMap {\n  | R => R\n  | Dom => U\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => '], 'extend bu lv')
(['meet_*-right {?} {?}', 'meet_*-right {?} {?} {?}', 'meet_*-right {R} {?} {?}', 'meet_*-right {s} {?} {?}'], 'meet_*-right {?}')
(['negative=id  y', 'negative=id ', 'negative=id  y y', 'negative=id  y x'], 'negative=id ')
(['<=-refl ', '<=-refl {?}', '<=_refl {?}', '<=-refl <=-refl'], 'c <=-refl')
(['\\lam {x} => {?}', '\\lam {x} {y} => {?}', '\\lam {x} p => {?}', '\\lam {x} {y} {?}'], '\\lam {x} => {?}')
(['{?} <=∘ {?}', 'abs {?} {?}', 'abs {?}', 'abs {?} {?} {?}'], '<=_* {?} {?}')
(['<_*_positive-right {?} {?}', '<_*_positive-right {?} {?} {?}', '<_*_positive-right  {?} {?}', '<_*_positive-right {?}'], '<_*_positive-right {?} {?}')
(['\\lam p => {?}', '\\new LinearMap A B', '\\new LinearMap {\n  | R => R\n  | Dom => R\n  | Cod => R\n  | Cod => R\n  | Cod => R\n  | Cod => R\n  | Cod => R\n  | Cod => R\n  | Cod ', '\\new LinearMap {\n  | R => R\n  | Dom => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => '], '\\new LinearMap {\n  | R => _\n  | Dom => ProductLModule R A B\n  | Cod => A\n  | func => \\lam p0 => (\n    \\let (a, b) => p0\n    \\in a)\n  | func-+ => idp\n  | func-*c => idp\n}')
(['diagonal_func {?} {?}', 'diagonal_func {?}', 'diagonal_func L', 'diagonal_func {?} {?} {?}'], 'diagonal_func _')
(['absurd {?}', 'absurd {?} {?}', '\\lam p => {?}', "rec' {?} {?}"], "rec' absurd {?}")
(['natCoef_*c {M}', 'natCoef_*c {M} {?}', 'rewrite natCoef_*c {?}', 'natCoef_*c {M} {?} {?}'], 'natCoef_*c {M}')
(['join-left ', 'join-left <=∘  {?}', 'join-left <=∘ {?}', 'join-left <=∘ join-left'], 'join-left ')
(['inP (U, UBall-open {X})', 'inP (U, UBall-open {X}) {?}', 'inP (U, UBall-open Sopen {X})', 'inP (U, UBall-open Sopen So) {?}'], 'inP (_, UBall-open {X} Uo {x.1}, UBall-point {X} {U} Ux, \\lam u => p $ simplify in u)')
(['Sh {?}', '\\new MonoidData {\n  | y :: y :: nil\n}', 'Sh {?} {?}', '\\new MonoidData {S} (x :: inverse (S) x :: y :: nil)'], '\\new MonoidData {S} (x :: inverse {S} x :: y :: nil)')
(['levelProp (LDiv g g|x g|y)', 'levelProp (LDiv g g|x g|y) {?}', 'levelProp (LDiv g g|x) (rewrite (res-univ g g|x g|y)) {?}', 'levelProp (LDiv g g|x) (rewrite (res-univ g g|x) (res-univ g g|x g|y)) {?}'], 'levelProp g g2 {?} (res-univ {g2} g g|x g|y)')
(['\\case \\elim p0, \\elim p1 \\with {\n  | inP (U, DU, inP (V, DV, \\lam p => {?}) => {?}\n}', '\\case \\elim p0, \\elim p1 \\with {\n  | inP (U, DU, inP (V, DV, \\lam p => {?}\n}))) => {?}\n}', '\\case \\elim p0, \\elim p1 \\with {\n  | inP (U, DU, inP (V, DV, \\lam p => {?}) => {?}\n}))', '\\case \\elim p0, \\elim p1 \\with {\n  | inP (U, DU, inP (V, DV, \\lam p => {?}) => {?}\n})'], 'inP (isCont {R} {X} {Y} {U} {Uo} {f} {g} {d1} {d2}, deriv-quot_+ {R} {X} {Y} {U} {Uo} {f} {g} {d1} {d2})')
(['terms-equality {{?}} (x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* (var 0 :', 'terms-equality\n{{?}} (x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* (var 0 :', 'terms-equality {{?}} (x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* (var 0 :* v', 'terms-equality {{?}} (x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* (var 0 :* (var '], 'terms-equality {{?}} (x3 :: x0 :: nil)\n  (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* (var 0 :* :inverse (var 0)))) (var 0) idp')
(['real_<_U.2 y<b', 'real_<_U.2 {?}', 'real_<_U.2 y<y', 'real_<_U.2 y<e'], 'real_<_U.2 {?}')
(['zro-right ', 'zro-right {l}', 'zro-right {?}', 'zro-right {_} {0}'], 'zro-right ')
(['terms-equality {{?}} (x8 :: x2 :: x7 :: x5 :: nil) (var 0) (var 1 :* var 0 :* :inverse (var 0) :* (:inverse (var 1) :* (var 2 :', 'terms-equality {{?}} (x8 :: x2 :: x7 :: x5 :: nil) (var 0) (var 1 :* var 0 :* :inverse (var 0) :* (:inverse (var 1) :* (:invers', 'terms-equality {{?}} (x8 :: x2 :: x7 :: x5 :: nil) (var 0) (var 1 :* var 0 :* :inverse (var 0) :* (var 1 :* var 0 :* :inverse (', 'terms-equality\n{{?}} (x8 :: x2 :: x7 :: x5 :: nil) (var 0) (var 1 :* var 0 :* :inverse (var 0) :* (:inverse (var 1) :* (var 2 :'], 'terms-equality {{?}} (x8 :: x2 :: x7 :: x5 :: nil) (var 0)\n  (var 1 :* var 0 :* :inverse (var 0) :* (:inverse (var 1) :* (var 2 :* (var 3 :* :inverse (var 3)) :* (:inverse (var 2) :* var 0))))\n  idp')
(['terms-equality {{?}} (x5 :: x1 :: x2 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* var 2))) (var 1 :* var 2) idp', 'terms-equality {{?}} (x5 :: x1 :: x2 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* var 2))) (var 1 :* var 2) id', 'terms-equality {{?}} (x5 :: x1 :: x2 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* var 2)))\n  (var 1 :* var 2) idp', 'terms-equality {{?}} (x5 :: x1 :: x2 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* var 2)))\n  (var 1 :* var 2) idp\n}'], 'terms-equality {{?}} (x5 :: x1 :: x2 :: nil) (var 0 :* (:inverse (var 0) :* (var 1 :* var 2))) (var 1 :* var 2) idp')
(['\\lam {p0} p1 => {?}', '\\lam p0 => {?}', '\\lam p => {?}', '\\lam {p0} p1 p2 => {?}'], '\\lam {p0} p1 p2 {z} d => {?}')
(['terms-equality {{?}} (x1 :: x0 :: nil) :ide\n  (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var ', 'terms-equality {{?}} (x1 :: x0 :: nil) :ide (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var 1 ', 'terms-equality {{?}} (x1 :: x0 :: nil) :ide (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 ', 'terms-equality {{?}} (x1 :: x0 :: nil) :ide (var 0 :* var 1 :* (var 0 :* var 1 :* (var 0 :* var 1 :* (var 1 :* (var 1 :* (var 1'], 'terms-equality\n{{?}} (x1 :: x0 :: nil) :ide (var 0 :* var 1 :* (var 0 :* :inverse (var 0) :* (:inverse (var 1) :* :inverse (var 0))))\n  idp')
(['terms-equality {{?}} (x1 :: x0 :: x2 :: nil) (var 0 :* (var 0 :* (var 0 :* (var 0 :* var 1)) (var 2 :* var 2 :* var 2 :* :inver', 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) (var 0 :* (var 0 :* (var 0 :* (var 0 :* var 1))\n  (var 2 :* var 2 :* var 2 :* var ', 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) (var 0 :* (var 0 :* (var 0 :* (var 0 :* var 1)) (var 2 :* var 2 :* var 2 :* var 2 ', 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) (var 0 :* (var 0 :* (var 0 :* (var 0 :* var 1))\n  (var 2 :* var 2 :* var 2 :* var'], 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) (var 0 :* (var 0 :* var 1))\n  (var 2 :* var 2 :* :inverse (var 2) :* (:inverse (var 2) :* (var 1 :* :inverse (var 1)) :* var 0 :* var 0 :* var 1)) idp')
(['meet_L.2 {?}', 'meet_L.1 q', 'meet_L.2 q', 'meet_L q'], '(meet_L.1 s).1')
(['inP (top, <=<_top)', 'inP (top, filter-top)', 'inP (V, V<=<_top)', 'inP (top, filter-top))'], 'inP (top, top, <=<_top, <=<_top, filter-top)')
(['LDiv a k', 'LDiv a b', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | b => {?}\n}'], 'c a')
(['ide_*q {X}', 'ide_*q {X} {?}', 'rewrite ide_*q {?}', 'ide_*q <∘ {?}'], 'ide_*q {X}')
(['\\lam p => {?}', '\\case a<=y \\with {}', '\\case a<=y \\with {\n  | 0 => {?}\n}', '\\case dec<_<= {?} {?}'], "{?} <∘r a2c<c'")
(['\\lam _ => {?}', '\\lam o => {?}', '\\lam _ _ => {?}', '\\lam _ p => {?}'], '\\lam _ => {?}')
(['later {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '(\\lam p => {?}, \\lam p => {?})', '(\\lam j => {?}, \\lam j => {?})'], 'hasNegative-correct  p _ q')
(['inP (N, \\lam p => {?})', 'inP {?}', 'inP (N, \\lam N<=n => {?})', 'inP (N, \\lam p => {?}, \\lam p => {?})'], 'inP (N, \\lam q => p $ f q)')
(['induction {?}', 'induction {?} {?}', 'induction {?} {?} {?}', 'transport ((<=) _) {?} {?}'], 'transport (\\lam p0 => _ <= {X} f p0) {?} induction')
(['\\lam {x} => {?}', '(@) {?} i {J}', '(@) {?} i {x}', '(@) {?} i {X}'], '\\lam {x} => {?}')
(['\\lam j => {?}', '\\lam j p => {?}', '\\lam p => {?}', '\\lam j => {?} => {?}'], '\\lam f => {?}')
(['cfactor-right {?} {?}', 'cfactor-right x', 'cfactor-right {?} {?} {?}', 'cfactor-right {?}'], 'cfactor-right {?}')
(['zro-right ', 'zro-right {?}', 'zro-right {_} {negative z}', 'zro-right <∘r {?}'], 'zro-right {_} {negative z}')
(['{?} <=∘ {?}', '*q-assoc ', '*q-assoc {{?}}', '*q-assoc {?}'], '<=_* {?} p')
(['cStruct {?}', 'contains_zro {?}', 'contains_zro {?} {?}', 'cStruct {?} {?}'], 'later (rewrite natCoefSuc (simplify contains_zro))')
(['later {?}', 'f j', 'c j b', 'c j j'], 'f j')
(['rewrite p in {?}', 'BigProd-univ {?} {?}', 'BigProd-unique  {?} {?}', 'BigProd-unique  {?}'], 'BigProd-fixed {?}')
(['toZero {R} {?} {?}', 'toZero {R} {?} {?} {?}', 'toZero {R} {?} {?} {?} {?}', 'toZero {?} {?} {?} {?}'], 'toZero {R} {d R.* pow {R} b n R.* pow {R} g.1 l R.* pow {R} g.1 m} {y R.* pow {R} g.1 (k * n) R.* pow {R} g.1 m} dyp')
(['compl-meet ', 'compl-meet  {?}', 'compl-meet  {?} {?}', 'compl-meet <=∘  {?}'], 'compl-meet ')
(['\\lam p0 => {?}', '\\lam p => {?}', '\\lam p0 p1 => {?}', '\\lam p0 => {?} {?}'], '\\lam p0 => {?}')
(['\\lam p => {?}', '\\lam e => {?}', '\\lam p0 => {?}', '\\case k \\with {}'], 'fsuc/= sface-skip')
(['ide_*q ', 'ide_*q {X}', 'ide_*q  {?}', 'ide_*q {X} {?}'], 'ide_*q {A}')
(['*i-ldistr ', '*i-ldistr {{?}}', '*i-ldistr  {?}', '*i-ldistr {{?}} {?}'], '*i-ldistr ')
(['\\lam p => {?}', '\\lam {U} V<=<U => {?}', '\\lam {U} p => {?}', '\\lam U<=<U => {?}'], '\\lam s => {?}')
(['=_<= {?}', '=_<= {?} {?}', '=_<= p', '=_<= {?} {?} {?}'], '=_<= {?}')
(['absurd {?}', 'absurd {?} {?}', 'absurd p', 'absurd {?} {?} {?}'], 'absurd {?}')
(['<_<= {?} {?}', '<_<= {?} {?} {?}', '<_<= {?}', '<_<=.2 {?}'], '<_<= |a|<B')
(['+-cont {?}', '+-cont {?} {?}', 'tuple {?} {?}', '+-cont ∘ {?}'], 'inv-dense {R} {?} {?}')
(['terms-equality {{?}} (x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* (var 0 :* :inverse (var 0))) idp', 'terms-equality {{?}} (x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* :inverse (var 0))) idp', 'terms-equality {{?}} (x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* (var 0 :* (var 0 :* :inverse (var 0))) idp', 'terms-equality {{?}} (x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* (var 0 :* vvar 0 :* :inverse (var 0))) idp'], 'terms-equality {{?}} (x0 :: nil) (var 0) (var 0 :* (var 0 :* :inverse (var 0))) idp')
(['fromZero {R} {?} {?}', 'fromZero {?} {?}', 'fromZero {R} {?}', 'fromZero  {?} {?}'], 'fromZero {R} {pow {R} x (m !! 0) R.* pow {R} (a !! 0) (m !! 0) R.* pow {R} x (m !! 0)} {pow {R} x (m !! 0)} {?}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => ex) {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['<-rat.1 {?}', '<-rat.2 {?}', '<-rat {?} {?}', '<-rat.1 {?} {?}'], '<-rat.1 {?}')
(['<=-less {?} {?}', '<=-less {?} {?} {?}', '<=-less {?}', '<=-less S<=S {?}'], '<=-less {?}')
(['\\lam p => {?}', '\\lam e => {?}', '\\lam x => {?}', '\\lam p0 => {?}'], '\\lam p => {?}')
(['\\lam p => {?}', '{?} <=∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | a => {?}\n}'], 'reg a')
(['\\lam lm p => {?}', '\\lam lm => {?}', '\\lam lm lm p => {?}', '\\lam lm lm lk => {?}'], '\\lam lm => {?}')
(['*q-square {X} {?}', '*q-square {X} {?} {?}', '*q-square {?} {?}', '*q-square {X}'], "*q-square {X} ab'-square px")
(['*_positive {?}', '*_positive {?} {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '*_positive-right {?}'], '*-rat {?} {?}')
(['inv-right {e|x}', 'inv-right ', 'inv-right {i|x}', 'inv-right {a|x}'], 'inv-right {e|x}')
(['{?} <=∘ {?}', '{?} <=∘  {?}', '{?} <=∘ a', '{?} <=∘ b<=a'], 'bu {?} {?}')
(['<_*_positive-left  {?} {?}', '<_*_positive-left  {?} x<y', '<_*_positive-left  x<y x<y', '<_*_positive-left  x<y'], '<_*_positive-left  x<y {?}')
(['\\lam p0 => {?}', '\\lam p => {?}', '\\lam p0 p1 => {?}', '\\lam p0 Cs => {?}'], '\\lam p0 => {?}')
(['inP (j, C)', 'inP (j, c)', 'inP {?}', 'inP (j, Cc)'], 'inP (j, Cc)')
(['negative_+ ', 'negative_+  {?} {?}', 'negative_+  {?}', 'negative_+ {?} {?}'], 'negative_+ {IntRing} {d} {n div d * d}')
(['<=_* {?} {?}', '<=_* j {?} {?}', '<=_* {?} {?} {?}', '<=_* j {?} {?} {?}'], '<=_* j<=k j<=k')
(['\\lam j => {?}', '\\new DArray {\n  | at => \\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array', '\\new DArray {\n  | at => \\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Arg  ', '\\new DArray {\n  | at => \\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Array (\\Sigma (Arg )'], '\\new DArray {\n  | at => \\lam j => arg j @ i\n}')
(['terms-equality {{?}} (x2 :: x1 :: x0 :: nil) (var 0 :* (:inverse (var 0) :* (var 0 :* (:inverse (var 0) :* (var 0 :* :inverse (', 'terms-equality {{?}} (x2 :: x1 :: x0 :: nil) (var 0 :* (:inverse (var 0) :* (var 0 :* (:inverse (var 0) :* (var 0 :* (:inverse ', 'terms-equality\n{{?}} (x2 :: x1 :: x0 :: nil) (var 0 :* (:inverse (var 0) :* (var 0 :* (:inverse (var 0) :* (var 0 :* :inverse (', 'terms-equality {{?}} (x2 :: x1 :: x0 :: nil) (var 0 :* (:inverse (var 0) :* (var 0 :* (:inverse (var 0) :* (var 0 :* ververse ('], 'terms-equality {{?}} (x2 :: x1 :: x0 :: nil) (var 0 :* (:inverse (var 0) :* (var 0 :* :inverse (var 0))))\n  (var 1 :* :inverse (var 1) :* (var 2 :* :inverse (var 2))) idp')
(['\\lam j => {?}', '\\lam j => {{?}', '\\lam j p => {?}', '\\lam j Dc => {?}'], '\\lam j => {?}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?} {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?}\n}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['later {?}', 'h {?}', 'h {?} {?}', 'later {?} {?}'], 'V<=U Vz')
(['zro-right ', 'zro-right {_} {ide}', 'zro-right {?}', 'zro-right <∘r {?}'], 'zro-right ')
(['\\lam y => {?}', '\\lam p => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case f \\with {\n  | 0 => {?}\n}'], 'p f inj')
(['\\lam {x} {y} p => {?}', '\\lam {x} p => {?}', '\\lam {x} => {?}', '\\lam {x} {y} {?}'], 'func-* {trans {f.f#} (func {g.f} y) ∘ trans {g.f#} y ∘ Func {F {N.R}} {x} {y} p}')
(['Join-cond {?}', 'Join-cond f', 'Join-cond {L} {?}', 'Join-cond {?} {?}'], 'Join-cond q')
(['coef_/=0 {?} {?}', 'coef_/=0 {?}', 'coef_/=0 p', 'coef_/=0 {?} {?} {?}'], 'coef_/=0 {?}')
(['later {?}', 'rewrite p i', '\\case \\elim p \\with {\n  | 0 => {?}\n}', 'rewrite (BigSum {M}) {?}'], '(f i).2')
(['closureN-lem {?}', 'closureN-lem {?} {?}', 'closureN-lem.2 {?}', 'closureN-lem.1 {?}'], 'closureN-lem.1 q')
(['ldiv/=0  a b', 'ldiv/=0 ', 'ldiv/=0  a/=0', 'ldiv/=0  a/=0 {?}'], 'ldiv/=0 b/=0 (res|val2 {gcd-isGCD a b})')
(['rewrite a=0 {?}', 'rewrite p {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}) => {?}\n}'], 'f j')
(['\\lam p => {?}', '\\lam f => {?}', '\\lam p0 => {?}', '\\lam e => {?}'], '\\lam p => {?}')
(['\\lam a => {?}', '\\lam p => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | inZeroDimensional => {?}\n}'], '\\lam a => {?}')
(['cover {?} {?}', 'cover-cover {?} {?}', 'cover-cover {?} {?} {?}', 'cover-proj1 {?} {?}'], 'cover-trans {?} {?}')
(['\\lam p => {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\peval p {?}'], 'pointSCF_^-1_<=< {X} p')
(['later {?}', 'rewrite p {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], 'rewrite (cons ) {?}')
(['ratherBelow {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\new RatherBelow P P', 'ratherBelow {PresentedFresentedFreme P} {?}'], 'LocaleRatherBelow {_}')
(['\\lam p => {?}', '\\lam V<=<U => {?}', '\\lam {U} V<=<U => {?}', '\\lam {U} V<=<V => {?}'], 'f t')
(['rewrite (o-assoc ) {?}', 'rewrite (beta2  _) {?}', 'rewrite (beta2  _ _) {?}', 'rewrite (beta2  _) {?} {?}'], 'beta2  _ _')
(['suc<suc {?} {?}', 'suc<suc {?}', 'suc<suc <∘ {?}', 'suc<suc p'], 'suc<suc k>0')
(['byLeft {?}', 'byLeft {?} {?}', 'byLeft p', 'byLeft r'], 'byLeft h')
(['\\lam {x} => {?}', '\\lam p => {?}', '\\lam a<=0 => {?}', '\\lam {x} a<=x => {?}'], '\\lam {x} => {?}')
(['*c-comm-left {{?}}', '*c-comm-left ', '*c-comm-left {b}', '*c-comm-left {{?}} {?}'], '*c-comm-left {{?}} {b.1} {s.1} {b.1 *r {A} s.1}')
(['ide-left ', 'rewrite ide-left ide-left', 'ide-left {?}', 'rewrite ide-left {?}'], 'ide-left ')
(['filter-mono FU {?}', 'filter-mono {?} {?}', 'filter-mono {?} {?} {?}', 'filter-mono FU {?} {?}'], 'filter-mono {?} {?}')
(['\\lam p => {?}', 'Join-univ {?}', 'Join-univ  {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], "step d {?} {v} {c'} {?} d~>*c'")
(['h j', 'later {?}', 'rewrite p j', 'rewrite p {?}'], 'rewriteI e bh')
(['{?} <=∘ {?}', 'later {?}', '\\lam p => {?}', '<=_+ <=-refl {?}'], 'bp n')
(['\\new CRingData {\n  | R => R\n  | vars => pow {R} x (m !! 0) :: x :: a :: nil\n}', 'later {?}', 'interpretNF_negate  {?}', '\\new CRingData {\n  | R => R\n  | vars => pow {R} x (m !! 0) :: x :: a :: a :: nil\n}'], '\\new CRingData {\n  | R => R\n  | vars => pow {R} x (m !! 0) :: pow {R} (a !! 0) (m !! 0) :: x :: a !! 0 :: nil\n}')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\lam V<=<U => {?}', 'g F'], 'h CV')
(['transport2 ((<)) ) {?} {?}', 'transport2 ((<) ) {?} {?}', 'transport2 ((<)) ) {?} {?} {?}', 'transport2 ((<) ) {?} {?} {?}'], 'transport2 (\\lam x y => U {meas  x} y) {?} linarith {?}')
(['later {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}) => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n} {?}\n}'], 'wayBelowPredicate R {?} c basic leq dense comm')
(['g {?} {?}', "W'<=<W' {?}", "rewrite W=W' {?}", "rewrite W'=W' {?}"], 'h {?} {?}')
(['\\lam a => {?}', '\\lam a i => {?}', '\\lam a p => {?}', '\\lam _ => {?}'], '\\lam a ac => {?}')
(['closure-filter {?} {?}', 'closure-filter {?} {?} {?}', 'closure-filter FU {?}', 'closure-filter {?} {?} {?} {?}'], 'closure-filter {X} F CA CD')
(['uniformStrongCompletion X', 'transport (id ) id {?}', 'transport (id) id) id', 'transport (id) id) id {?}'], 'tuple id id')
(['{?} <=∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '{?} <=∘ p'], '{?} <=∘ {?}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => ex (h4 i x) {?} {?}', 'prop-dpi (\\lam i => ex (h4 i x y) {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['toZero {?} {?}', 'toZero {?} {?} {?}', 'toZero  {?} {?}', 'toZero {R} {?} {?}'], 'toZero {R} {(s.1 *c (s.1, s.2)).1} {s.1} p')
(['\\lam p => {?}', '{?} <=∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case p \\with {\n  | 0 => {?}\n}'], '\\case \\elim n, \\elim q \\with {\n  | 0, _ => {?}\n  | suc n, q => {?}\n}')
(['inP {?}', 'inP (x, eps, eps>0)', 'inP (x, eps, eps>0, h)', 'inP (x, eps, eps>0, FB)'], 'inP (x, eps, eps>0, FB, mid<right a<x-eps)')
(['max {?} {?}', 'max {A} {?} {?}', 'max {?} {?} {?}', 'max (contains_+ ) {?}'], '\\new SubSemiring {\n  | SubAddMonoid => max {A}\n  | SubMonoid => max\n}')
(['cauchy-open {?} {?}', 'cauchy-open ', 'cauchy-open  {?} {?}', 'cauchy-open {?}'], '(cauchy-open ).2 {?}')
(['(\\lam p => {?}, \\lam p => {?})', 'f {?}', '\\lam p => {?}', '(\\lam p => {?}, \\lam q => {?})'], '(GU, FU)')
(['transport ((<) _) {?} {?}', 'transport (\\lam _x => _x <= _) {?} {?}', 'transport ((<) _) {?} {?} {?}', 'transport (\\lam p0 => {?}) {?} {?}'], 'transport ((\\lam x0 x1 => substitution_meta) (R.ide R.* s.1 R.* s.2)) {?} {?}')
(['(@) {?} i {J}', '\\lam {f} => {?}', '(@) {?} i {X}', '(@) {?} i {e}'], '(@) h4 i {J}')
(['terms-equality {{?}} (x5 :: x11 :: x2 :: x7 :: nil) (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0) :* (var 2 :* :inver', 'terms-equality\n{{?}} (x5 :: x11 :: x2 :: x7 :: nil) (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0) :* (var 2 :* :inver', 'terms-equality {{?}} (x5 :: x11 :: x2 :: x7 :: nil)\n  (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0) :* (var 2 :', 'terms-equality {{?}} (x5 :: x11 :: x2 :: x7 :: nil) (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0) :* (var 1 :* :inver'], 'terms-equality {{?}} (x5 :: x11 :: x2 :: x7 :: nil)\n  (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0) :* (var 2 :* :inverse (var 2) :* var 3)) (var 3) idp')
(['\\lam {x} Vy => {?}', '\\lam {x} p => {?}', '\\lam p => {?}', '\\lam {x} {y} => {?}'], '\\lam _ Vy => {?}')
(['{?} @ i', '(@) {?} i {X}', 'arg i {?}', '(@) {?} i {?}'], '{?} @ i')
(['\\lam F => {?}', '\\lam f => {?}', 'Precat {J} {?}', 'Precat {?} {?}'], 'FamPrecat D')
(['<=-refl ', '<=_*n ', '<=-refl {?}', '<=-refl  {?}'], '<=-refl ')
(['L-closed q<q', 'L-closed a<q', 'L-closed q<a', 'L-closed {a2}'], 'L-closed r<a2 {?}')
(['inP (b, idp)', 'inP (W, WW, idp)', 'inP (V, byLeft idp)', 'inP (V, V<=<U, idp)'], 'inP (_, byLeft idp, \\lam {x} Wx Vx => e (x, (Vx, Wx)))')
(['later {?}', 'makeMatrix {?} {?}', 'makeMatrix {?} {?} {?}', 'cLimit {?}'], 'f 1 1')
(['<=-rat.1 {?}', '<=-rat.2 {?}', '<=-rat {?} {?}', '<=-rat.1 {?} {?}'], '<=-rat.1 {?}')
(['terms-equality {{?}} (x0 :: x5 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 1 :* :inverse (var 1) idp', 'terms-equality {{?}} (x0 :: x5 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 1 :* :inverse (var 1) :* var 0) idp', 'terms-equality {{?}} (x0 :: x5 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 1 :* :inverse (var 1) :* var 0) id', 'terms-equality {{?}} (x0 :: x5 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 1 :* var 0) idp'], 'terms-equality {{?}} (x0 :: x5 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 1 :* :inverse (var 1) :* var 0) idp')
(['<=-antisymmetric {?} {?}', '<=-antisymmetric {?} ide-left_<=', '<=-antisymmetric {?} ide-left_<= {?}', 'ide-left_<= {?}'], '<=-antisymmetric {?} ide-left_<=')
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}) => {?}\n}', '\\case \\elim p \\with {\n  | interpretLatticeNF _ => {?}\n}'], 'rewrite (cons ) {?}')
(['\\lam {q} => {?}', '\\lam {Q} => {?}', '(@) {?} i {Q}', '(@) {?} i {q}'], '\\lam {q} => {?}')
(['map {?} {?}', 'map {?} {?} {?}', 'map {?} {?} {?} {?}', 'map {?} {?} {?} {?} {?}'], '~-trans {?} {?}')
(['func-*c {i}', 'func-*c {{?}}', 'func-*c {a}', 'func-*c {i} {?}'], 'func-*c {i}')
(['h {?}', 'g Vy', 'rewrite p {?}', 'h {?} {?}'], 'rewrite p in Uy')
(['\\lam {y} => {?}', '(@) {?} i {x}', '{?} @ i', '(@) {?} i {X}'], '(@) {?} i {x}')
(['\\lam {p} p => {?}', '\\lam {p} {q} => {?}', '\\lam {p} {q} qe => {?}', 'degree<= {?}'], '\\lam {p} {q} => {?}')
(['later {?}', '\\new CRingData {\n ', '\\new CRingData {\n  | R => R\n  | vars => t :: A }\n  | vars => t :: A }\n  | vars => t :: A }\n  | vars => t :: A }\n  | vars => t :', '\\new CRingData {\n  | R => R\n  | vars => t :: A !! 0 :: x1 :: A !! 0 :: x1 :: A !! 0 :: x1 :: A !! 0 :: x1 :: A !! 0 :: x1 :: A '], '\\new CRingData {\n  | R => R\n  | vars => t :: A !! 0 !! 0 :: x1 :: A !! 0 !! 1 :: y1 :: A !! 1 !! 1 :: s :: A !! 1 !! 0 :: nil\n}')
(['\\lam {r} {x} => {?}', '\\lam {r} => {?}', '\\lam {r} {x} {x} => {?}', 'func {e}'], 'func-*c {transport {LinRepres R G} (\\lam (Cod : LinRepres R G) => InterwiningMap {G} {R} e.dom Cod) {e.dom} {e.cod} q\n  (id-interwining {R} {G} e.dom)}')
(['\\lam C => {?}', '\\lam C p => {?}', '\\lam C c => {?}', '\\lam C => {?} {?}'], 'modelExtHom ')
(['all2-cons {?} {?}', 'all2-cons {?} {?} {?}', 'all2-cons {?}', 'all2-cons (\\lam p0 => p0.1 \\with {\n  | 0 => {?}\n}'], "all2-cons t t'")
(['\\lam p => {?}', 'later {?}', '(\\lam p => {?}, \\lam p => {?})', '(\\lam _ => {?}, \\lam p => {?})'], '<->trans {?} join_U')
(['diff_<= {B} {?}', 'diff_<= {B}', 'diff_<= {?}', 'diff_<= {B} {?} {?}'], 'diff_<= {B}')
(['map_sort-consistent  l', 'map_sort-consistent ', 'map_sort-consistent  _ _', 'map_sort-consistent  (sort-consistent ) {?}'], 'map_sort-consistent l')
(['\\lam _ => {?}', 'count l j', 'count {?} {?}', 'count l j j'], 'replicate (count l j) j')
(['<=_+  {?} {?}', '<=_+  {?} {?} {?}', '<=_+  {?} {?} {?} {?}', '<=_+  {?} p'], '<=_+  a>=0 b>=0')
(['*c-rdistr ', '*c-rdistr {{?}}', '*c-rdistr {x}', '*c-rdistr  {x}'], '*c-rdistr ')
(['cover-inj {?} idp', 'cover-inj  {?} idp', 'cover-inj () idp', 'cover-inj {?} {?}'], 'cover-inj 0 idp')
(['BigSum-ext {?} {?}', 'BigSum-ext {?}', 'BigSum-ext {?} {?} {?}', 'BigSum-ext {R} {?} {?}'], 'BigSum-ext {R} {?}')
(['pow-cover {?} {?}', 'pow-cover (cs j) z', 'pow-cover {X} {?} {?}', 'pow-cover {?} {?} {?}'], 'tuple {?} {?}')
(['{?} <∘ {?}', '{?} <∘  {?}', '{?} <=∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], 'simplify q')
(['\\lam Ux => {?}', '\\lam {x} Ux => {?}', '\\lam p => {?}', '\\lam {x} Uo => {?}'], '\\lam {x} Ufx => {?}')
(['func-negative {f}', 'func-negative {f} {?}', 'func-negative {f} {?} {?}', 'func-negative {{?}}'], 'func-negative {f}')
(['\\lam p => {?}', '\\lam _ => {?}', '\\lam n<=0 => {?}', '\\lam n=0 => {?}'], '\\lam n1=0 => {?}')
(['\\lam p => {?}', '\\lam p0 => {?}', 'later {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], '\\lam q => {?}')
(['fin_< t', 'fin_< {?} {?}', 'fin_< {?}', 'fin_< t.1 {?}'], 'fin_< t.1')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => ex) {?}', 'prop-dpi (\\lam i => ex {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['norm_*q-ofPos {A} {?}', 'norm_*q-ofPos {A}', 'norm_*q-ofPos {A} {?} {?}', 'norm_*q-ofPos {?}'], 'norm_*q-ofPos {A} ide-delta>=0')
(['\\scase \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\lam p => {?}', '\\scase \\elim p0 \\with {\n  | ints => {?}\n}'], '{?} <=∘ {?}')
(['contraction {c}', 'contraction {?}', 'contraction {c} {?}', 'contraction {?} {?}'], '\\new RingHom {\n  | func => \\lam _ => center {c}\n  | func-+ => contraction {c} _\n  | func-ide => contraction {c} _\n  | func-* => contraction {c} _\n}')
(['transportInv (iabs ) {?} {?}', 'transportInv (iabs ) iabs y', 'transportInv (iabs ) {?} iabs y', 'transportInv (iabs ) {?} iabs'], 'transportInv (\\lam _x => _x <= iabs y) t {?}')
(['inMap {?}', 'inMap {?} {?}', 'inMap {g} {?}', '\\case \\elim p \\with {\n  | in~ q => {?}\n}'], "\\case \\elim v, \\elim v' \\with {\n  | in~ a, in~ a1 => {?}\n}")
(['later {?}', '\\case j \\with {\n  | 0 => {?}\n}', '\\case \\elim j \\with {\n  | 0 => {?}\n}', '\\case j \\with {\n  | interpretNF => {?}\n}'], 'apply-axioms {{?}} env l right')
(['\\lam p => {?}', '\\lam f => {?}', '\\lam _ => {?}', '\\lam {a} {b} => {?}'], '\\lam _ => {?}')
(['finCard {?}', '\\new QEquiv {\n  | ret => \\lam p0 => (\\case \\elim p0 \\with {\n  | ret_f => \\lam p0 => (\\case \\elim p0 \\with {\n  | ret_f => \\lam p', '\\new QEquiv {\n  | f => \\lam p0 => (\\case \\elim p0 \\with {\n  | ret_f => \\lam p0 => (\\case \\elim p0 \\with {\n  | ret_f => \\lam p0 ', '\\new QEquiv {\n  | ret_f => \\lam p0 => (\\case \\elim p0 \\with {\n  | ret_f => \\lam p0 => (\\case \\elim p0 \\with {\n  | ret_f => \\lam'], '\\new QEquiv {\n  | f => \\lam p0 => (\\case p0 \\with {})\n  | ret => \\lam p0 => (\\case p0.2 \\with {})\n  | ret_f => \\lam p0 => (\\case p0 \\with {})\n  | f_sec => \\lam p0 => (\\case p0.2 \\with {})\n}')
(['\\lam {f} => {?}', '(@) {?} i {J}', '\\lam {F} => {?}', '(@) h1 i {J}'], '(@) {?} i {J}')
(['choice {?}', 'choice {?} {?}', 'choice {d} {?}', 'choice f'], 'choice {?}')
(['norm_*_<= ', 'norm_*_<= {?}', 'norm_*_<= <=∘ {?}', 'rewrite norm_*_<= {?}'], 'norm_*_<= ')
(['mid<right {?} {?}', 'mid<right  {?} {?}', 'mid<right {?} {?} {?}', 'mid<right {?}'], 'mid<right bp')
(['\\lam p => {?}', '\\lam q => {?}', '\\lam k => {?}', '\\lam p0 => {?}'], '\\lam p => {?}')
(['cauchy-subset {?} {?}', 'cauchy-subset {?} {?} {?}', 'cauchy-subset {X} {?} {?}', 'cauchy-subset {?} {?} {?} {?}'], 'cauchy-subset {?} {?}')
(['\\lam p => {?}', '\\lam x0 => {?}', '\\lam {x0} => {?}', '\\lam x<=y => {?}'], '\\lam x0=x => {?}')
(['<=<_top {?} {?}', '<=<_top {?}', '<=<_top {?} {?} {?}', '<=<_top {X} {?}'], 'cover-char {?} <=<_top')
(['functor {e}', 'functor {e} {?}', 'f {e}', 'functor {{?}}'], 'functor {f {e}}')
(['<=<-right {?} {?}', '<=<-right {?} {?} {?}', '<=<-right {?} {?} {?} {?}', '<=<-right {?} p'], '<=<-right {?} U<=<V')
(['later {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | a => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}'], 'f a/=0 u')
(['join_*-right {?} {?}', 'join_*-right {?}', 'join_*-right {R} {?} {?}', 'join_*-right {?} {?} {?}'], 'join_*-right {?}')
(['transport ((<) ) {?} {?}', 'transport ((<=) ) {?} {?}', 'transport (\\lam _x => _x <= _) {?} {?}', 'transport ((<) ) {?} {?} {?}'], 'transport ((<=) _) {?} {?}')
(['zro-left ', 'zro-left  {?}', 'zro-left {_} {x}', 'zro-left {?}'], 'zro-left ')
(['later {?}', 'isFormulaTrue  {?} {?}', 'isFormulaTrue  {?}', 'isFormulaTrue {?} {?}'], 'c j')
(['LU-focus-bound {y} {?} {?}', 'LU-focus-bound {y} {?}', 'LU-focus-bound {y}', 'LU-focus-bound {y} {?} {?} {?}'], "LU-focus-bound {y} (B - x' + 1) eps/4>0")
(['lift-prop {l1} {?} {?}', 'lift-prop {l1} {?} l2', 'lift-prop {l1} {?}', 'lift-prop {l1}'], 'lift-prop {l1} (inL {l2}) {?}')
(['{?} <=∘  {?}', '{?} <=∘  p', '{?} <=∘   {?}', '{?} <=∘   p'], '{?} <=∘  {?}')
(['*c-assoc ', '*c-assoc {{?}}', '*c-assoc {{?}} {?}', '*c-assoc {{?}} {?} {?}'], '*c-assoc {S {S }}')
(['\\lam {a} {b} p => {?}', '\\lam {a} {b} => {?}', '\\lam {a} p => {?}', '\\lam {a} {b} {b} => {?}'], '\\lam {a} {b} a<~>*b bnf => {?}')
(['\\lam j => {?}', '\\lam j p => {?}', '\\lam j => {?} {?}', '\\lam j => {?} => {?}'], '\\lam j => {?}')
(['\\lam {x} {y} => {?}', '\\lam {x} => {?}', '\\lam {x} {y} {z} => {?}', '\\lam {x} {y} {?}'], '\\lam {x} {y} {z} => {?}')
(['terms-equality {{?}} (x0 :: x1 :: nil) (var 0 :* (var 1 :* (var 0 :* :inverse (var 0)) :* var 0 :* var 1) idp', 'terms-equality {{?}} (x0 :: x1 :: nil) (var 0 :* (var 1 :* (var 0 :* :inverse (var 0)) :* var 0) :* var 0) :* var 0 :', 'terms-equality {{?}} (x0 :: x1 :: nil) (var 0 :* (var 1 :* (var 0 :* :inverse (var 0)) :* var 0) :* var 0) :* var 0) :', 'terms-equality {{?}} (x0 :: x1 :: nil) (var 0 :* (var 1 :* (var 0 :* :inverse (var 0)) :* var 0) :* var 0) :* var 0) :* var'], 'terms-equality\n{{?}} (x0 :: x1 :: nil) (var 0 :* (var 1 :* (var 0 :* :inverse (var 0)) :* var 0) :* :inverse (var 0)) (var 0 :* var 1)\n  idp')
(['<=<-left {?} {?}', '<=<-left {?} {?} {?}', '<=<-left  {?} {?}', '<=<-left p {?}'], '<=<-left {?} {?}')
(['isGCDDomain  x y', 'isGCDDomain  y y', 'isGCDDomain  x y y', 'isGCDDomain x y'], 'isGCDDomain  x.1 y.1 {?} {?}')
(['{?} <∘ {?}', '{?} <∘  {?}', '{?} <=∘  {?}', '{?} <=∘ {?}'], '{?} <∘r {?}')
(['\\lam j => {?}', 'later {?}', '(\\lam j => {?}, \\lam j => {?})', '\\lam p => {?}'], 'rewrite CoverInterBig-char c')
(['pmap {?} {?}', 'pmap {?} {?} {?}', 'pmap {?} {?} {?} {?}', 'pmap (iabs m) m'], 'rewrite (pmap iabs n=m) p')
(['terms-equality {{?}} (x0 :: x3 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0) idp', 'terms-equality\n  {{?}} (x0 :: x3 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0) idp', 'terms-equality\n{{?}} (x0 :: x3 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0) idp', 'terms-equality {{?}} (x0 :: x3 :: nil) (var 0) (var 1 :: x3 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0) idp'], 'terms-equality {{?}} (x0 :: x3 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0) idp')
(['terms-equality {{?}} (x6 :: x3 :: nil) :ide (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0)) idp', 'terms-equality\n  {{?}} (x6 :: x3 :: nil) :ide (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0)) idp', 'terms-equality\n{{?}} (x6 :: x3 :: nil) :ide (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0)) idp', 'terms-equality {{?}} (x6 :: x3 :: nil) :ide\n  (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0)) idp'], 'terms-equality {{?}} (x6 :: x3 :: nil) :ide (var 0 :* var 1 :* :inverse (var 1) :* :inverse (var 0)) idp')
(['\\lam p => {?}', '\\lam _ => {?}', '\\lam Uo Ux => {?}', '\\lam {x} Uo Ux => {?}'], '\\lam f => {?}')
(['\\lam p => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}'], 'transport (\\lam x0 => substitution_meta) {?} {?}')
(['\\lam f => {?}', '\\lam {X} f => {?}', 'natural {h ∘ (g ∘ f)}', 'natural {h ∘ (g ∘  f)}'], 'natural {\\new NatTrans {C} {D1} X W {\n  | trans => \\lam (X1 : C.Ob) => h.trans X1 D.∘ (g.trans X1 D.∘ f.trans X1)\n  | natural => {?hidden}\n}}')
(['\\lam {x} Uo => {?}', '\\lam {x} p => {?}', '\\lam {x} Uo Up => {?}', '\\lam {x} Uo Ux => {?}'], '\\lam Uo Ux => {?}')
(['*n-cont ', '*n-cont {X}', '*n-cont {X} {?}', '*n-cont {X} {?} {?}'], '*n-cont {X}')
(['terms-equality {{?}} (x3 :: nil) (var 0 :* :inverse (var 0) :* var 0) :* var 0) (var 0) idp', 'terms-equality {{?}} (x3 :: nil) (var 0 :* :inverse (var 0) :* var 0) (var 0) idp', 'terms-equality {{?}} (x3 :: nil) (var 0 :* :inverse (var 0) :* var 0) :* var 0) idp', 'terms-equality\n  {{?}} (x3 :: nil) (var 0 :* :inverse (var 0) :* var 0) :* var 0) (var 0) idp'], 'terms-equality {{?}} (x3 :: nil) (var 0 :* :inverse (var 0) :* var 0) (var 0) idp')
(['terms-equality {{?}} (x1 :: x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0))) id', 'terms-equality {{?}} (x1 :: x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0))) ', 'terms-equality {{?}} (x1 :: x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse ', 'terms-equality {{?}} (x1 :: x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 0 :* (var 0 :* (var 0 :* (var 1 :* :inverse (var 1)) :*'], 'terms-equality {{?}} (x1 :: x0 :: nil) (var 0) (var 0 :* (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0))) idp')
(['inP (top, filter-top)', 'inP (top)', 'inP (top, filter-top))', 'inP (U, CU, inP (top, filter-top))'], 'inP (U, CU, inP (V, FV, top, filter-top, \\lam Vx _ => q Vx))')
(["normalize-consistent'  {?} {?}", "normalize-consistent'  s", "normalize-consistent'  {?}", "normalize-consistent'  s {?}"], "normalize-consistent' _")
(['isCauchyFilter {F} {?}', 'isCauchyfilter {F} {?}', 'isCauchyFilter {F}', 'isCauchyFilter {F} Cc'], 'isCauchyFilter {?}')
(['cauchy-regular-cover  {?} {?}', 'cauchy-regular-cover  y<=<U', 'cauchy-regular-cover {?} {?}', 'cauchy-regular-cover  {?} {?} {?}'], 'cauchy-regular-cover  V<=<U y')
(['terms-equality {{?}} (x4 :: nil) :ide (var 0 :* :inverse (var 0)) idp', 'terms-equality\n{{?}} (x4 :: nil) :ide (var 0 :* :inverse (var 0)) idp', 'terms-equality\n  {{?}} (x4 :: nil) :ide (var 0 :* :inverse (var 0)) idp', 'terms-equality {{?}} (x4 :: nil) :ide (var 0 :* :inverse (var 0))) idp'], 'terms-equality {{?}} (x4 :: nil) :ide (var 0 :* :inverse (var 0)) idp')
(['ringHom a|b', 'auxHom a|b', '\\new RingHom a|b', 'ringHom {?}'], 'div-map {R} a|b')
(['homogen-pow {?} {?}', 'homogen-pow {?} {?} {?}', 'homogen-pow {?}', 'homogen-pow {?} {?} {?} {?}'], 'homogen-pow {R} ch')
(['#0-*-right {gcd}', '#0-*-right {gcd} {?}', '#0-*-right {gcd} {?} {?}', '#0-*-right {?}'], '#0-*-right {D} {?}')
(['=_<= {?}', '=_<= {?} {?}', '=_<= *-comm', '=_<= <=∘ {?}'], '=_<= *-comm')
(['count-leaves  l', 'rewrite id<suc id<suc', 'rewrite id<suc {?}', 'rewrite id<suc id<suc {?}'], 'q <∘ id<suc')
(['h {?}', 'rewrite p {?}', 'rewrite p in Vx', 'g Ux Vx'], 'rewrite p in Ux')
(['\\lam p => {?}', '\\lam e => {?}', '\\lam {F} p => {?}', '\\lam {F} {?} => {?}'], '\\lam p0 => {?}')
(['nucleus-<=  {?}', 'nucleus-<=  x<=y', 'nucleus-<=  {?} {?}', 'nucleus-<= {?} {?}'], 'nucleus-<=  p')
(['contains_ide {S}', 'contains_ide {?}', 'cStruct {?}', 'cStruct {S}'], 'contains_ide {S}')
(['terms-equality {{?}} (x14 :: nil) :ide (var 0 :* :inverse (var 0)) idp', 'terms-equality\n{{?}} (x14 :: nil) :ide (var 0 :* :inverse (var 0)) idp', 'terms-equality\n  {{?}} (x14 :: nil) :ide (var 0 :* :inverse (var 0)) idp', 'terms-equality {{?}} (x14 :: nil) :ide (var 0 :* :inverse (var 0))) idp'], 'terms-equality {{?}} (x14 :: nil) :ide (var 0 :* :inverse (var 0)) idp')
(['\\lam x<y => {?}', '\\lam p => {?}', '\\lam x y => {?}', '\\lam {x} x<y => {?}'], '\\lam x/#y => {?}')
(['decideEq i j {?}', '\\case decideEq i j \\with {\n  | 0 => {?}\n}', '\\case decideEq i j \\with {}', 'decideEq i j {?} {?}'], 'rewrite (decideEq/=_reduce i/=j) {?}')
(['meet_<= {?} {?}', 'meet_<= {?}', 'meet_<= {?} {?} {?}', 'meet_<= {?} p'], 'meet_<= a<=b')
(['\\lam {x} p => {?}', '\\lam {x} {y} => {?}', '\\lam {x} => {?}', '\\lam {x} {y} {\\lam p => {?}'], '\\lam {x} {y} x//=y => {?}')
(['*-comm ', '*-comm {{?}}', '*-comm {X}', '*-comm {_} {x}'], '*-comm ')
(['\\case \\elim p0, \\elim p1 \\with {\n  | inP (V, DV, inP (x, \\case \\elim p2)) => {?}\n}', "\\case \\elim p0, \\elim p1 \\with {\n  | inP (V, DV, inP (x, \\case \\elim p2 \\with {\n  | inP (V, DV, inP (V, DV, inP (V, DV, inP (V'", '\\case \\elim p0, \\elim p1 \\with {\n  | inP (V, DV, inP (x, \\case \\elim p2 \\with {\n  | inP (V, DV, inP (V, DV, inP (V, DV, inP (V,', "\\case \\elim p0, \\elim p1 \\with {\n  | inP (V, DV, inP (x, \\case \\elim p2 \\with {\n  | inP (V, DV, inP (V', VV, inP (V, DV, inP (V"], '\\case \\elim p0, \\elim p1 \\with {\n  | _, inP (_, _, V, DV, idp) => {?}\n}')
(['minPoly_degree-char {?} {?}', 'minPoly_degree-char {?} {?} {?}', 'minPoly_degree-char.2 {?}', 'minPoly_degree-char {?}'], '(pe, (minPoly_degree-char f a p pe p/=0).1 {?})')
(['fromZero {?} {?}', 'fromZero {R} {?} {?}', 'fromZero {R} {?}', 'fromZero {?} {?} {?}'], 'fromZero {R} {pow {R} a n R.* ((l !! j).1 R.* f (l !! j).2) R.* (a R.* b)} {pow {R} a n R.* b R.* (l !! j).1 R.* g (l !! j).2} {?}')
(['Join-univ {?}', 'Join-univ {?} {?}', 'Join-univ <=∘ {?}', 'Join-univ {?} J'], 'Join-univ {?}')
(['transport (ide) ) idp', 'transport (ide ) idp', 'transport ((<) ) ) idp', 'transport (ide ) ide {?}'], 'transport (\\lam x0 => substitution_meta) {?} idp')
(['toZero {R} {?} {?}', 'toZero {?} {?}', 'toZero {?} {?} {?}', 'toZero {R} {?} {?} {?}'], 'toZero {R} {pow {R} x (m !! 0) R.* (R.ide - x R.* a !! 0)} {R.zro} p')
(['\\lam p => {?}', '\\lam _ => {?}', '\\lam p0 => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], '\\lam _ => {?}')
(['V<=<V {?}', 'rewrite p {?}', 'g V<=<U', 'rewrite p idp'], "p2 y' c2<y' y'<d2")
(['deriv-quot {?} {?}', 'deriv-quot {?} {?} {?}', 'deriv-quot {?}', 'deriv-quot {?} {?} {?} {?}'], 'deriv-quot-cont gx gh ga d {top} {?}')
(['Join-univ {?}', 'Join-univ  {?}', 'Join-univ  {?} {?}', 'Join-univ {?} {?}'], 'Join-univ  {?}')
(['\\lam p => {?}', '\\lam S => {?}', '(\\lam p => {?}, \\lam p => {?})', '(\\lam p => {?})'], '\\lam p0 => {?}')
(['terms-equality {{?}} (x1 :: x0 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x1', 'terms-equality\n{{?}} (x1 :: x0 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x1', 'terms-equality\n  {{?}} (x1 :: x0 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: ', 'terms-equality {{?}} (x1 :: x0 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: x10 :: nil) (var 0 :* (var 1 :* :inve'], 'terms-equality\n  {{?}} (x1 :: x0 :: x10 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 2 :* (:inverse (var 2) :* var 0)) idp')
(['prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => ex {) {?} {?}', 'prop-dpi (\\lam i => ext_coefZero ) {?} {?}', 'prop-dpi {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['isNeg  x', 'isNeg x', '\\case \\elim p \\with {\n  | 0 => {?}\n}', 'rewrite (isNeg ) idp'], 'unfold {?}')
(['meet-monotone  {?} {?}', 'meet-monototone  {?} {?}', 'meet-monotone  {?} {?} {?}', 'meet-monotototone  {?} {?}'], 'meet-monotone  {?} {?}')
(['Kernel {f}', 'Kernel {f} {?}', 'Cernel {f}', 'SubGroup f'], 'Kernel {f}')
(['transport ((<) ) {?} {?}', 'transport ((<)) ) {?} {?}', 'transport (\\lam _x => _x <= _) {?} {?}', 'transport ((<) ) {?} {?} {?}'], 'transport (\\lam X => X) p a')
(['\\case \\elim p \\with {\n  | inP (x, inP (x, \\case \\elim p) => {?}\n}', '\\case \\elim p \\with {\n  | inP (x, inP (x, \\case \\elim p \\with {\n  | inP (x, inP (b, p)), inP (b, inP (b, inP (b, inP (b, inP (b', '\\case \\elim p \\with {\n  | inP (x, inP (x, \\case \\elim p \\with {\n  | inP (x, inP (b, p)), inP (b, inP (b, inP (b, inP (b, p))), ', '\\case \\elim p \\with {\n  | inP (x, inP (x, \\case \\elim p \\with {\n  | inP (x, inP (b, p)), inP (b, inP (b, inP (b, inP (b, inP (B'], 'inP (R, p, q, RVW)')
(['lem {?}', 'lem {A} {?}', 'lem {?} {?}', 'lem {A} {?} {?}'], 'lem {?}')
(['later {?}', 'contains-unit {?} {?}', 'contains-unit  {?} {?}', 'contains-unit {?}'], 'rewriteI {?} {?}')
(['isCauchyFilter {?} {?}', 'isCauchyFilter {?}', 'isCauchyFilter {F} {?}', 'isCauchyFilter Cc {?}'], 'isCauchyFilter {F} {?}')
(['terms-equality {{?}} (x4 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* (var 0)) idp', 'terms-equality {{?}} (x4 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0)) idp', 'terms-equality\n{{?}} (x4 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* (var 0)) idp', 'terms-equality\n  {{?}} (x4 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* (var 0)) idp'], 'terms-equality {{?}} (x4 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* (var 1 :* :inverse (var 1) :* var 0)) idp')
(['Ideal {?}', 'ideal {?}', '\\lam p => {?}', 'ideal {?} {?}'], 'closure1 (padd 1 0)')
(['terms-equality {{?}} (x4 :: x3 :: x2 :: nil) (var 0 :* var 1 :* (var 2 :* var 2) :* :inverse (var 0)) idp', 'terms-equality {{?}} (x4 :: x3 :: x2 :: x2 :: nil) (var 0 :* var 1 :* (var 2 :* var 2) :* :inverse (var 0)) idp', 'terms-equality {{?}} (x4 :: x3 :: x2 :: nil) (var 0 :* var 1 :* (var 2 :* var 2) :* :inverse (var 0 :* var 1) :* :inverse (var ', 'terms-equality {{?}} (x4 :: x3 :: x2 :: x2 :: nil) (var 0 :* var 1 :* (var 2 :* var 2) :* :inverse (var 0 :* var 1) :* :inverse'], 'terms-equality\n  {{?}} (x4 :: x3 :: x2 :: nil) (var 0 :* var 1 :* (var 2 :* var 2) :* :inverse (var 2)) (var 0 :* (var 1 :* var 2)) idp')
(["inP (U', CU')", "inP (U, CU', \\lam p => {?})", "inP (U', CU', \\lam p => {?})", "\\case \\elim p0 \\with {\n  | inP (U, CU', \\lam p => {?}\n}"], "inP (U, CU, V, DV, U'<=U, V'<=V)")
(['\\case \\elim p \\with {\n  | inP (x, inP (b, p), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP', '\\case \\elim p0 \\with {\n  | inP (x, inP (b, p), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), in', '\\case \\elim p0 \\with {\n  | inP (x, inP (b, p)), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), i', '\\case \\elim p0 \\with {\n  | inP (x, inP (b, p), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), inP (b, lb), id'], 'inP (mVar j, unfold $ unfold $ rewrite (func-ide {f}) simplify)')
(['Comp {?} {?}', 'Precategory-of-elements {?} {?}', 'Comp {?} {?} {?}', 'Precategory-of-elements f f'], 'diagram-functor {C} {E} {A} {?}')
(['div-to~ inD y', 'div-to~ {M} {?} {?}', 'div-to~ {M} {inD y}', 'div-to~ (inD y) (inD y)'], 'div-to~ (res|val2 {g})')
(['terms-equality {{?}} (x3 :: x6 :: x14 :: x13 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* var 2 :* :inverse (var 2))) (var 0', 'terms-equality {{?}} (x3 :: x6 :: x14 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* var 2 :* :inverse (var 2))) (var 0 :* (va', 'terms-equality {{?}} (x3 :: x6 :: x14 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* var 2 :* :inverse (var 2))) (var 0 :* v', 'terms-equality\n{{?}} (x3 :: x6 :: x14 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* var 2 :* :inverse (var 2))) (var 0 :* (va'], 'terms-equality {{?}} (x3 :: x6 :: x14 :: x13 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* var 2 :* :inverse (var 2)))\n  (var 0 :* (var 3 :* :inverse (var 3))) idp')
(['(top, x)', '(top x) {?} {?}', '(top  x) {?} {?}', '(top x).2 x'], '((), u)')
(['cauchy-subset {?} {?}', 'cauchy-subset {?} {?} {?}', 'cauchy-subset {X} {?} {?}', 'cauchy-subset {?} {?} {?} {?}'], 'cauchy-subset Cc {?}')
(['norm_dist-left <∘r {?}', 'norm_dist-left <∘ {?}', 'rewrite norm_dist-left {?}', 'norm_dist-left {X} {?} {?}'], 'norm_dist-left <=∘ {?}')
(['g {?} {?}', 'rewrite p {?}', 'g {?} {?} {?}', 'rewrite p intSCF {?}'], 'g V1x V2y')
(['<-rat.1 {?}', '<-rat.2 {?}', '<-rat {?} {?}', '<-rat.2 <-rat'], '<-rat.2 |x|<c')
(['Join f', 'Join-univ {?}', 'Join {?}', '\\new FrameUnit f'], 'F M')
(['=_<= {?}', '=_<= meet-comm', '=_<= <=∘ {?}', '=_<= meet-comm '], '=_<= meet-comm')
(['fromPointwiseCover {?} {?}', 'fromPointwiseCover {?}', 'fromPointwiseCover {?} {?} {?}', 'fromPointwiseCover {Q} {?}'], 'fromPointwiseCover {?}')
(['cover-trans {?} {?}', 'cover-trans {?} {?} {?}', 'cover-trans {?} {?} {?} {?}', 'cover-trans {?} p'], 'cover-trans {?} {?}')
(['\\lam _ => {?}', '\\lam p => {?}', '\\lam c => {?}', '\\lam {_} {_} => {?}'], '\\lam t => {?}')
(['+-assoc ', '+-assoc {X}', '+-assoc  {?}', '+-assoc ) {?}'], '+-assoc ')
(['\\lam p => {?}', 'inP (V, DV, \\lam p => {?})', '\\case \\elim p \\with {\n  | inP (V, DV, \\lam p => {?}) => {?}\n}', '\\case \\elim p \\with {\n  | inP (V, DV, \\lam p => {?}\n}) => {?}\n}'], '\\case \\elim p0 \\with {\n  | inP (N, V, DV, h) => {?}\n}')
(['map func (l at i)', 'map f i', 'map func (l at i))', 'map (\\lam i => func (l at i))'], 'map (func ) l')
(['\\lam p => {?}', '\\lam L<=a => {?}', '(\\lam p => {?}, \\lam p => {?})', '\\lam a<=a => {?}'], '<->trans {?} join_L')
(['inP (U, CU, idp)', 'inP (U, CU, idp), idp)', 'inP (U, CU, idp))', 'inP (U, CU, idp, idp)'], 'inP (U, CU, idp)')
(['absurd {?}', 'absurd {?} {?}', 'absurd p', 'absurd {?} {?} {?}'], 'absurd {?}')
(["\\lam {V'} p => {?}", '\\lam p => {?}', "\\lam {V'} TruncP => {?}", "\\lam {V'} {V'} p => {?}"], "\\lam {V'} p0 => {?}")
(['terms-equality {{?}} (x8 :: x0 :: x5 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 2 :* :inverse (var 2) :* (var 2 :* :', 'terms-equality {{?}} (x8 :: x0 :: x5 :: nil) (var 0 :* :inverse (var 0) :* varverse (var 0) :* var 1) (var 2 :* :inverse (var 2', 'terms-equality {{?}} (x8 :: x0 :: x5 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 2 :* :inverse (var 2) :* (var 2 :* ', 'terms-equality {{?}} (x8 :: x0 :: x5 :: nil) (var 0 :* :inverse (var 0) :* varverse (var 0) :* var 1) (var 2 :* :inverse (var'], 'terms-equality {{?}} (x8 :: x0 :: x5 :: nil) (var 0 :* :inverse (var 0) :* var 1)\n  (var 2 :* (:inverse (var 2) :* (var 2 :* :inverse (var 2))) :* var 1) idp')
(['rewrite (tupleMap ) {?}', 'transport ((<) ) {?} {?}', 'rewrite (tupleMap ) {?} {?}', 'rewrite (tupleMap  (∘) ) {?}'], 'tupleBeta {Bprod  x y}')
(['\\lam p => {?}', '\\lam r => {?}', '\\lam d => {?}', '\\peval rat n3 d3 _'], '\\lam p q => {?}')
(['*-assoc ', '*-assoc  {?}', '*-assoc {X}', '*-assoc  {x}'], '*-assoc ')
(['terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 0) idp', 'terms-equality\n{{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 0) idp', 'terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1)) (var 0) idp', 'terms-equality\n  {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 0) idp'], 'terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1))) (var 0) idp')
(["inP (U', CU')", "inP (U', CU', \\lam p => {?})", "\\case \\elim p \\with {\n  | inP (U', CU'), inP (U', CU', \\lam p => {?}\n}", "\\case \\elim p \\with {\n  | inP (U', CU'), inP (U', CU', \\lam p => {?}\n})) => {?}\n}"], "\\case \\elim p0 \\with {\n  | inP (U', CU', Uh) => {?}\n}")
(['terms-equality {{?}} (x4 :: x6 :: x3 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* (var 2 :* :inverse (var 2))) (var 1) id', 'terms-equality {{?}} (x4 :: x6 :: x3 :: nil) (var 0 :* :inverse (var 0) :* varverse (var 0) :* var 1 :* (var 2 :* :inverse (var', 'terms-equality {{?}} (x4 :: x6 :: x3 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* (var 2 :* :inverse (var 2))) (var 1) idp', 'terms-equality\n{{?}} (x4 :: x6 :: x3 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* (var 2 :* :inverse (var 2))) (var 1) id'], 'terms-equality\n  {{?}} (x4 :: x6 :: x3 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* (var 2 :* :inverse (var 2))) (var 1) idp')
(['\\lam {y} => {?}', '(@) {?} i {x}', '{?} @ i', '(@) {?} i {X}'], '(@) {?} i {x}')
(['\\lam x y => {?}', '\\lam (x : X) => {?}', '\\lam x => {?}', '\\lam x y y => {?}'], '\\lam x y => {?}')
(['\\lam y => {?}', '\\lam y p => {?}', '\\lam y x => {?}', '\\lam y f => {?}'], '\\lam y => {?}')
(['simplify {?}', 'terms-equality {{?}} ((var 0 :* var 1 :: var 2 :* var 3) :* (var 2 :* var 3) :* (var 2 :* var 3) :* (var 2 :* var 4 :', 'terms-equality\n  {{?}} ((var 0 :* var 1 :: var 2 :* var 3) :* (var 2 :* var 3) :* (var 2 :* var 3) :* (var 2 :* var 3) :* (var ', 'terms-equality {{?}} ((var 0 :* var 1 :: var 2 :* var 3) :* (var 2 :* var 3) :* (var 2 :* var 3) :* (var 4 :: Interpret '], 'terms-equality env ((var 0 :* var 1 :+ var 2 :* var 3) :* (var 2 :* var 4 :+ var 0 :* var 5 :+ :negative :ide)) :zro {?}')
(['finv-left ', 'finv-left  {?} {?}', 'finv-left  {?}', 'finv-left  p'], 'finv-left {RatField} {?}')
(['=_<= {?}', '=_<= {?} {?}', '=_<= p', '=_<= {?} {?} {?}'], '=_<= {?}')
(['isRegularFilter {?}', 'isRegrilter {?}', 'isRegularFilter {X}', 'isRegularFilter {pointCF {X}}'], 'isRegularFilter {pointCF {X} x}')
(['fromInt_<= {?} {?}', 'fromInt_<= {?}', 'fromInt_<= p', 'fromInt_<= {?} {?} {?}'], 'fromInt_<= {?}')
(['pow-comm1  {?} {?}', 'pow-comm1  {?}', 'pow-comm1 ', 'pow-comm1  {?} {?} {?}'], 'pow-comm1  {?}')
(['absurd {?}', 'absurd {?} {?}', 'absurd p', 'absurd {?} {?} {?}'], 'absurd {?}')
(['contains_*  {?} {?}', 'contains_*  {?} {?} {?}', 'contains_* {?} {?}', 'contains_*  {?}'], 'contains_*  {?} s')
(["\\new R'", "\\new R' R'", "\\new L' R'", "\\new RingedL' R'"], "\\new RingedLocale L' R'")
(['TopTransfer-map {?} {?}', 'TopTransfer-map {?} {?} {?}', 'TopTransfer-map {?}', 'TopTransfer-map top x'], 'TopTransfer-map (\\lam p0 => p0.1)')
(['+-comm {G}', '+-comm {X}', '+-comm {G} {?}', '+-comm {G} {x}'], '+-comm {G}')
(['\\lam p => {?}', '\\lam f => {?}', '\\lam {a} {b} => {?}', '\\lam {a} {b} p => {?}'], '\\lam p0 p1 => {?}')
(['c*abs-univ-bounded {?} {?}', 'c*abs-univ-bounded {A} {?} {?}', 'c*abs-univ-bounded {A} {?}', 'c*abs-univ-bounded {?}'], 'c*abs-univ-bounded {A} <=-refl {?} x<=1 -x<=1')
(['{?} <=∘ {?}', 'bigJoin-univ {B} {?}', 'bigJoin-univ {B} {?} {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], '=_<= {?}')
(['\\lam p => {?}', '(\\lam p => {?}, \\lam p => {?})', 'rewrite p {?}', 'rewrite p in {?}'], 'p 0')
(['ide-left {M}', 'ide-left {_} {x}', 'ide-left ', 'ide-left <∘ {?}'], 'ide-left {M}')
(['FinSum_char {?} {?}', 'FinSum_char {?}', 'FinSum_char {A} {?}', 'FinSum_char {A} {?} {?}'], 'FinSum_char {Ab {R} {G} {A} {B}} x')
(['commaPrect {?} {?}', 'commaPrect {?} {?} {?}', 'commaPrector {?} {?}', 'commaPrect F {?}'], 'Comp (F ) {?}')
(['abs {?} {?}', 'abs {?}', '{?} <∘ {?}', '{?} <∘r {?}'], 'g p')
(['terms-equality {{?}} (x0 :: x2 :: nil) (var 0) (var 0 :* (var 1 :* :inverse (var 1))) idp', 'terms-equality\n{{?}} (x0 :: x2 :: nil) (var 0) (var 0 :* (var 1 :* :inverse (var 1))) idp', 'terms-equality\n  {{?}} (x0 :: x2 :: nil) (var 0) (var 0 :* (var 1 :* :inverse (var 1))) idp', 'terms-equality {{?}} (x0 :: x2 :: nil) (var 0) (var 0 :* (var 1 :* :inverse (var 1)))) idp'], 'terms-equality {{?}} (x0 :: x2 :: nil) (var 0) (var 0 :* (var 1 :* :inverse (var 1))) idp')
(['byRight {?}', 'byRight {?} {?}', '\\lam _ => {?}', 'byRight V0'], 'byRight {?}')
(['terms-equality {{?}} (x4 :: x9 :: x6 :: x6 :: x6 :: x6 :: x2 :: nil) (var 0) (var 1 :* var 2 :* (:inverse (var 2) :* :inverse (', 'terms-equality {{?}} (x4 :: x9 :: x6 :: x6 :: x6 :: x6 :: x6 :: x2 :: nil) (var 0) (var 1 :* var 2 :* (:inverse (var 2) :* :inv', 'terms-equality {{?}} (x4 :: x9 :: x6 :: x6 :: x6 :: x2 :: nil) (var 0) (var 1 :* var 2 :* (:inverse (var 2) :* :inverse (var 2)', 'terms-equality {{?}} (x4 :: x9 :: x6 :: x6 :: x6 :: x2 :: nil) (var 0) (var 1 :* var 2 :* (:inverse (var 2) :* :inverse (var 1)'], 'terms-equality {{?}} (x4 :: x9 :: x6 :: x2 :: nil) (var 0)\n  (var 1 :* var 2 :* (:inverse (var 2) :* :inverse (var 1) :* (var 3 :* :inverse (var 3) :* var 0))) idp')
(['{?} <=∘ {?}', '\\lam p => {?}', 'wclosed-image j U', 'wclosed-image j Ux'], '{?} <=∘ {?}')
(['coreflection Z', 'coreflection  Z', 'coreflection {coreflection Z}', 'coreflection ∘ {?}'], 'isCoreflection {coreflection  Z}')
(['inP (U, CU, idp)', 'inP (U, CU, meet-monotone )', 'inP (meet-monotone )', 'inP (U, CU, meet-monotone ) idp'], "inP (U ∧ U', inP (U, U', CU, DUU', idp), V ∧ V', open-inter Vo V'o, (Vx, V'x), meet-monotone V<=U V'<=U')")
(['{?} <=∘ {?}', '{?} <∘ {?}', '{?} <=∘  {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], '{?} <∘ {?}')
(['map {?} {?}', 'map {?} {?} {?}', 'map (\\lam as => (as.1))', 'map (\\lam as => (as.1)) {?}'], 'map (\\lam p0 => p0.1)')
(['homogen-ide {?}', 'homogen-ide {?} {?}', 'homogen-ide {R} {?}', 'homogen-ide {R}'], 'homogen-ide {R}')
(['cauchy-subset {?} {?}', 'cauchy-subset {?} {?} {?}', 'cauchy-subset {X} {?} {?}', 'cauchy-subset {?} {?} {?} {?}'], 'cauchy-subset {?} {?}')
(['terms-equality  (var 0 :* var 1 :* var 2 :* var 3) (var 0 :* var 3 :* var 3) idp', 'terms-equality {{?}} (a.1 :: x.2 :: c :: y.2 :: c :: y.2 :: c :: y.2 :: c :: y.2 :: y.2 :: nil) (var 0 :* var 1 :* var 2 :* var', 'terms-equality {{?}} (a.1 :: x.2 :: c :: y.2 :: c :: y.2 :: c :: y.2 :: c :: y.2 :: nil) (var 0 :* var 1 :* var 2 :* var 3) (va', 'terms-equality {{?}} (a.1 :: x.2 :: c :: y.2 :: c :: y.2 :: c :: y.2 :: c :: y.2 :: y.2 :: y.2 :: nil) (var 0 :* var 1 :* var 2'], 'terms-equality\n  {{?}} (a.1 :: x.2 :: c :: y.2 :: nil) (var 0 :* var 1 :* var 2 :* var 3) (var 0 :* var 3 :* (var 1 :* var 2)) idp')
(['inP {?}', '\\scase \\elim p \\with {\n  | inP (x, inP (b, p)), inP (b, inP (b, inP (b, inP (b, inP (b, p), inP (b, inP (b, inP (b, inP (b, inP', '\\scase \\elim p \\with {\n  | inP (x, inP (b, p)), inP (b, inP (b, inP (b, inP (b, inP (b, p), inP (b, inP (b, inP (b, inP (b, p))', '\\scase \\elim p \\with {\n  | inP (x, inP (b, p)), inP (b, inP (b, inP (b, inP (b, inP (b, inP (b, inP (b, inP (b, inP (b, inP (b,'], '\\scase \\elim p0 \\with {\n  | inP (a, a<b, a>0, x<=a, -x<=a) => {?}\n}')
(['o-assoc ', 'o-assoc {M}', 'o-assoc {M} {?}', 'o-assoc {M} {?} {?}'], 'o-assoc {UniformCat} {_} {_} {_} {_} {f} {completion} {hinv {Mc}}')
(['meet-uniform {S1}', 'meet-uniform {S1} {?} {?}', 'meet-uniform {S1} {?}', 'meet-uniform {S1} {?} {?} {?}'], 'meet-uniform {S1}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => ext_cover {S1}) {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['IsZeroSum_count {?} {?}', 'IsZeroSum_count {?}', 'IsZeroSum_count c', 'count {?} {?}'], 'IsZeroSum_count {?} (l j)')
(['byLeft {?}', 'byLeft b<b', 'byLeft {?} {?}', "byLeft b<q'"], 'byLeft {?}')
(['Join-univ {?}', 'Join-univ {?} {?}', 'Join-univ <=∘ {?}', 'Join-univ {?} {?} {?}'], 'Join-univ {?}')
(['\\new AddPointed A B', '\\peval A B', '\\new AddPointed {\n  | A => FinSuppFunc A\n  | A => FinSuppFunc A\n  | A => FinSuppFunc A\n  | A => FinSuppFunc A\n  | fSupp => \\lam', '\\new AddPointed {\n  | A => FinSuppFunc A\n  | A => FinSuppFunc A\n  | A => FinSuppFunc A\n  | A => FinSuppFunc A\n  | A => \\lam _ ='], '\\new AddPointed {\n  | E => FinSuppFunc A B\n  | zro => \\new FinSuppFunc {\n    | func => \\lam _ => 0\n    | fSupp => inP (nil, \\lam _ _ => idp)\n  }\n}')
(['Func-o {L}', 'Func-o {S}', 'meet-left {?} {?}', 'meet-left {?}'], 'Func-o {F {S}}')
(['ide-left {_}', 'ide-left {_} {0}', 'ide-left <∘r {?}', 'ide-left {K}'], 'ide-left {_} {s.1 !! 0}')
(['\\lam {w} p => {?}', '\\lam {w} d => {?}', '\\lam {w} {w} {?}', '\\lam {w} {w} {?} => {?}'], '\\lam {w} d => {?}')
(['permSet-pow {?}', 'permSet-pow {?} {?}', 'perMSet-pow {?}', 'permSet-pow inPS'], 'rewrite permSet-pow {?}')
(['func-*n ', 'func-*n {{?}}', 'runc-*n ', 'func-*n  {?}'], 'func-*n ')
(['byLeft {?}', 'byLeft {?} {?}', 'byLeft p', 'byLeft eps>0'], 'byLeft {?}')
(['getAbs {?} {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', 'getAbs {A} {?} {?}', 'getAbs {?} {?} {?}'], '{?} <=∘ {?}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?} {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?}\n}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['\\lam x => {?}', '\\lam x y => {?}', '\\lam x p => {?}', '\\lam x x => {?}'], '\\lam x => {?}')
(['coneCoh {c} {?}', 'coneCoh {c} {?} {?}', 'coneCoh {c}', 'coh {c} {?} {?}'], 'coneCoh {c} (Hyx, id-left)')
(['\\lam p => {?}', '\\lam i => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], '\\case \\elim i, \\elim j \\with {\n  | 0, 0 => {?}\n  | 0, 1 => {?}\n}')
(['Completion _ _', 'Completion {completionLocale} {?}', 'Completion _ _ _', '\\new UniformEmbedding {\n  | Dom => Completion\n  | Cod => Completion\n}'], 'completion ')
(['natMod=mod x y', 'natMod=mod  x y', 'natMod=mod x y y', 'natMod=mod {x} {?}'], 'rewrite natMod=mod {?}')
(['meet-left ', 'meet-left <=∘  {?}', 'meet-left  {?}', 'meet-left <∘ {?}'], 'meet-left ')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => {?})', 'prop-dpi (\\lam i => {?}) {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['*-comm ', '*-comm {{?}}', '*-comm {A}', 'rewrite (*-comm ) {?}'], '*-comm ')
(['transportInv U {?} {?}', 'transportInv (()) {?} {?}', 'transportInv (\\lam _x => _x <= _) {?} {?}', 'transportInv ((<) ) {?} {?}'], 'transportInv (\\lam p0 => U {p0} eps) {?} d')
(['zeroDimensZeroDimensidimensional {?}', 'zeroDimensZeroDimensZeroDimensidional {?}', 'zeroDimensZeroDimensZeroDimensZeroDimensidional {?}', 'zeroDimensZeroDimensZeroDimensZeroDimensZeroDimensidional {?}'], 'zeroDimensional {K}')
(['\\lam k => {?}', '\\lam k p => {?}', 'map {?} {?} {?}', 'map (\\lam k => {?}, \\lam k => {?})'], '\\lam k => {?}')
(['const {?} {?}', 'Satrrans {?} {?}', 'const {TrivialCat} {?} {?}', 'const {TrivialCat}'], 'natTrans f')
(['terms-equality {{?}} (x14 :: x7 :: x1 :: x9 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 2 :* var 2 :* (:inverse (var 2)', 'terms-equality {{?}} (x14 :: x7 :: x1 :: x9 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 2 :* 2 :* (:inverse (var 2) :* ', 'terms-equality {{?}} (x14 :: x7 :: x1 :: x9 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 2 :* (:inverse (var 2) :* var 3', 'terms-equality {{?}} (x14 :: x7 :: x1 :: x9 :: nil) (var 0 :* (:inverse (var 0) :* var 1)) (var 2 :* (:inverse (var 2) :* var 1'], 'terms-equality {{?}} (x14 :: x7 :: x1 :: x9 :: nil) (var 0 :* (:inverse (var 0) :* var 1))\n  (var 2 :* (:inverse (var 2) :* var 3) :* :inverse (var 3) :* var 1) idp')
(['sqrt {?} {?}', '\\peval sqrt _ _', 'sqrt {?} {?} {?}', 'sqrt {?}'], '\\peval sqrt _ _')
(['terms-equality {{?}} (x7 :: x0 :: nil) (var 0 :* var 1) (var 0 :* var 0 :* var 1) idp', 'terms-equality {{?}} (x7 :: x0 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp', 'terms-equality\n{{?}} (x7 :: x0 :: nil) (var 0 :* var 1) (var 0 :* var 0 :* var 1) idp', 'terms-equality {{?}} (x7 :: x0 :: nil) (var 0 :* var 1) (var 0 :* var 1 idp'], 'terms-equality {{?}} (x7 :: x0 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp')
(['rewrite (normalize-consistent (var 0)) {?}', 'rewrite (normalize-consistent (var 0) (var 0)) {?}', 'rewrite (normalize-consistent {d}} {0} {1} {1} {1} {0} {1} {1} {1} {1} {1} {1} {0} {1} {1} {1} {1} {1} {1} {0} {1} {1} {1} {1} ', 'rewrite (normalize-consistent {d}} {0} {1} {1} {1} {0} {1} {1} {1} {1} {1} {1} {0} {1} {1} {1} {1} {0} {1} {1} {1} {1} {1} {1} '], 'normalize-consistent {d} {0} {0} (:o {V {d}} {0} {0} {H {d}} 1 (:o {V {d}} {1} {0} {H {d}} 2 (var 0) (var 0)) (var 0))')
(['terms-equality {{?}} (x0 :: x3 :: x6 :: nil) (var 0 :* (var 1 :* :inverse (var 1)) :* (:inverse (var 0) :* var 2)) (var 2) i', 'terms-equality {{?}} (x0 :: x3 :: x6 :: nil) (var 0 :* (var 1 :* :inverse (var 1)) :* (:inverse (var 0) :* var 2)) (var 2) id', 'terms-equality {{?}} (x0 :: x3 :: x6 :: nil)\n  (var 0 :* (var 1 :* :inverse (var 1)) :* (:inverse (var 0) :* var 2)) (var', 'terms-equality\n{{?}} (x0 :: x3 :: x6 :: nil) (var 0 :* (var 1 :* :inverse (var 1)) :* (:inverse (var 0) :* var 2)) (var 2) id'], 'terms-equality\n  {{?}} (x0 :: x3 :: x6 :: nil) (var 0 :* (var 1 :* :inverse (var 1)) :* (:inverse (var 0) :* var 2)) (var 2) idp')
(['finSum {?}', 'finSum {?} {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], '(\\lam p0 => {?}, \\lam p0 => {?})')
(['pbEta  {?} {?}', 'pbEta {D} {?} {?}', 'pbEta ', 'pbEta {{?}} {?} {?}'], 'pbEta eq1 eq2')
(['locale_cover {?} {?}', 'locale_cover {?}', 'locale_cover {?} p', 'locale_cover {?} {?} {?}'], 'locale_cover c')
(['determinantN_ide {?}', 'determinantN_ide {?} {?}', 'determinantN_ide k', 'determinantN_ide p'], 'determinantN_ide k')
(['\\lam eps>0 => {?}', '\\lam {eps} eps>0 => {?}', '\\lam p => {?}', '\\lam {e} eps>0 => {?}'], '\\lam {eps} eps>0 => {?}')
(['~_++-right {?} {?}', '~_++-right {?} {?} {?}', '~_++-right {?}', '~_++-right  {?} {?}'], "~_++-right g~g'")
(['terms-equality {{?}} (x10 :: x11 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0 :* (var 0 :* (var 2 :* :inverse (var', 'terms-equality {{?}} (x10 :: x11 :: x5 :: nil) (var 0) (var 1 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0 :* (var', 'terms-equality\n{{?}} (x10 :: x11 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0 :* (var 0 :* (var 2 :* :inverse (var', 'terms-equality {{?}} (x10 :: x11 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :: var 0 :* (var 0 :* (var 2 :* :inverse (var'], 'terms-equality\n  {{?}} (x10 :: x11 :: x5 :: nil) (var 0) (var 1 :* :inverse (var 1) :* var 0 :* (var 2 :* :inverse (var 2))) idp')
(['\\lam p => {?}', '\\lam x<=y => {?}', 'pmap (\\lam p => {?}) {?}', 'pmap (\\lam p => {?}) {?} {?}'], 'rewrite (pmap (\\lam f => f k) fg-comp) in {?}')
(['\\lam x => {?}', '\\lam x p => {?}', '\\lam x x => {?}', '\\lam (x : Cod ) => {?}'], '\\lam x {q} p => {?}')
(['prop-dpi (\\lam i => ex) {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => ex) {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['inP (V, idp)', 'inP (V, DV, idp)', 'inP (V, Vo, idp)', 'inP (V, CU, idp)'], 'inP (f.1, f.2, f.3, <=-refl, <=-refl, \\lam _ => idp)')
(['cover-prod {?} {?}', 'cover-prod {?} {?} {?}', 'cover-prod f j', 'cover-prod {?}'], 'cover-prod {?} {?}')
(['nonEqualApart  x<y', 'nonEqualApart  x y', 'nonEqualApart  y', 'nonEqualApart  {?} {?}'], 'nonEqualApart {t.2 @ i}')
(['contains a', 'contains {?} {?}', 'contains {?} {?} {?}', 'contains-unit {?} {?}'], '\\case \\elim e \\with {\n  | inl c => {?}\n  | inr c => {?}\n}')
(['\\lam p => {?}', 'later {?}', '\\lam N<=n => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], 'convergent-topAbGroup-char 0 1 Sc Uo U0')
(['inP (o-assoc)', 'inP (o-assoc )', '\\case \\elim p0 \\with {\n  | inP (x, inv p)) => {?}\n}', '\\case \\elim p0 \\with {\n  | inP (x, inv (o-assoc )) => {?}\n}'], 'inP (dense-relative-lift g gc.2 gc.1 f r.1 r.2 fd sq,\n  ext (exts (\\lam x => dense-relative-lift-char sq), exts (\\lam y => dense-relative-lift-proj gc.1 sq)))')
(['irr-cmp {?}', 'irr-cmp p', 'irr-cmp x', 'irr-cmp {?} {?}'], 'irr-cmp x')
(['ldiv/=0 {M} {?} {?}', 'ldiv/=0 {M} {?}', 'ldiv/=0 {?} {?}', 'ldiv/=0  {?} {?}'], 'ldiv/=0 {M} b/=0 z|b')
(['~-trans {?} {?}', '~-trans {?} {?} {?}', '~-trans {{?}} {?}', '~-trans {{?}} {?} {?}'], '~-trans {?} {?}')
(['dir {?} {?}', 'dir {?} {?} {?}', 'isTheorem  {?} {?}', 'dir {?} {?} {?} {?}'], 'dir qinj-equality {?}')
(['=_<= {?}', '=_<= {?} {?}', '=_<= V<=', '=_<= V<=<='], '=_<= {?}')
(['terms-equality {{?}} (x1 :: x8 :: nil) (var 0 :* var 1) (var 0 :* var 0 :* var 1) idp', 'terms-equality {{?}} (x1 :: x8 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp', 'terms-equality\n  {{?}} (x1 :: x8 :: nil) (var 0 :* var 1) (var 0 :* var 0 :* var 1) idp', 'terms-equality {{?}} (x1 :: x8 :: nil) (var 0 :* var 1) (var 0 :* var 1 idp'], 'terms-equality {{?}} (x1 :: x8 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp')
(['\\lam {r} => {?}', '\\lam {r} p => {?}', '\\lam {r} {a} => {?}', '\\lam {r} {a} {a} => {?}'], '\\lam A0 => {?}')
(['{?} <=∘ {?}', '{?} <=∘  {?}', 'u.2 <=∘ {?}', '{?} <=∘ {?} {?}'], '\\lam p => {?}')
(['func-* ', 'func-* {a}', 'rewrite (func-*) {?}', 'func-* {a} {?}'], 'func-* ')
(['terms-equality {{?}} (x0 :: x1 :: x2 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* var ', 'terms-equality {{?}} (x0 :: x1 :: x2 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* var 0 :* va', 'terms-equality {{?}} (x0 :: x1 :: x2 :: nil) (var 0 :* :inverse (var 0) :* (var 0 :* varverse (var 0) :* (var 0 :* varverse (va', 'terms-equality {{?}} (x0 :: x1 :: x2 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* var 0 :'], 'terms-equality {{?}} (x0 :: x1 :: x2 :: nil)\n  (var 0 :* :inverse (var 0) :* (var 1 :* :inverse (var 1)) :* (var 0 :* var 0 :* (:inverse (var 0) :* var 2)))\n  (var 0 :* var 2) idp')
(['negative_inv  t', 'negative_inv  {?}', 'negative_inv  {?} {?}', 'negative_inv '], 'negative_inv  t')
(['FinSum {?}', 'FinSum {?} {?}', 'finSum {?} {?}', 'FinSum {SubLRepres} {?}'], 'FinSumEqual-multiply t')
(['boundedPigeonhole f i', 'boundedPigeonhole  i {?}', 'boundedPigeonhole  f i', 'boundedPigeonhole  (i j) {?}'], 'boundedPigeonhole  (\\lam j => f j)')
(['prop-dpi (\\lam i => eps (\\lam i => eps)) {?}', '(@) {?} i {?}', 'prop-dpi (\\lam i => eps (\\lam i => eps)) (\\lam i => eps (h2 i a)) => {?}', 'prop-dpi (\\lam i => eps (\\lam i => eps)) (\\lam i => eps (h2 i a) => {?})'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['\\lam {x} {y} => {?}', '\\lam {x} => {?}', '\\lam {x} {y} {?}', '\\lam {x} p => {?}'], '\\lam {x} {y} => {?}')
(['terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1) :* :inverse (var 0) :* var 0)) (var 0 :* (va', 'terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1) :* :inverse (var 0) :* var 0)) (var 0 :* v', 'terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1) :* :inverse (var 0) :* var 0)) (var 0 :* (var', 'terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1) :* :inverse (var 0) :* var 0)) (var 0 :* (var '], 'terms-equality {{?}} (x2 :: x0 :: nil) (var 0 :* (var 1 :* :inverse (var 1) :* :inverse (var 0) :* var 0))\n  (var 0 :* (var 0 :* :inverse (var 0))) idp')
(['natural {X}', '\\new NatTrans X X', '\\new NatTrans {\n  | trans => \\lam X => \\lam X => X\n  | trans => \\lam X => \\lam X => X\n  | trans => \\lam X => \\lam X => \\lam X =', '\\new NatTrans {\n  | trans => \\lam X => \\lam X => X\n  | trans => \\lam X => \\lam X => \\lam X => X\n  | trans => \\lam X => \\lam X ='], '\\new NatTrans {\n  | trans => \\lam X => b X ∘ a X\n  | natural => \\lam f => rewrite (o-assoc, natural {a} f) (rewriteI o-assoc (rewrite (natural {b} f) o-assoc))\n}')
(['finiteAC p', 'finiteAC {?}', "finiteAC l'", 'finiteAC {?} {?}'], 'finiteAC p')
(['\\lam p => {?}', '\\lam _ => {?}', '\\lam e => {?}', '\\lam p0 => {?}'], '\\lam _0=1 => {?}')
(['terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1) :* (var 1 :* :inverse (var 1))) (var 1) id', 'terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1) :* (var 1 :* :inverse (var 1))) (var 1) idp', 'terms-equality\n{{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1) :* (var 1 :* :inverse (var 1))) (var 1) idp', 'terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (vanverse (var 0) :* var 1) :* (var 1 :* :inverse (var 1))) (var 1) idp'], 'terms-equality {{?}} (x0 :: x4 :: nil) (var 0 :* (:inverse (var 0) :* var 1) :* (var 1 :* :inverse (var 1))) (var 1) idp')
(['closure {?}', 'closure {?} {?}', "closure ls'", "ls' {?}"], '~_Big++ {?}')
(['signum_*_<= {?}', 'signum_*_<= {?} {?}', 'signum_*_<= {?} {?} {?}', 'rewrite (negative n2) {?}'], 'rewrite signum_nom {?}')
(['*-assoc {{?}}', '*-assoc {x}', '*-assoc {R}', '*-assoc {?}'], '*-assoc {R} {x.1} {(l j).1} {(g (l j).2).1}')
(['terms-equality {{?}} (x11 :: x6 :: x1 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 1 :* var 2 :* :inverse (var 2)) idp', 'terms-equality {{?}} (x11 :: x6 :: x1 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 1 :* var 2 :* :inverse (var 2)) id', 'terms-equality {{?}} (x11 :: x6 :: x1 :: nil) (var 0 :* :inverse (var 0) :* varverse (var 0) :* var 1) (var 1 :* var 2 :* :', 'terms-equality {{?}} (x11 :: x6 :: x1 :: nil) (var 0 :* :inverse (var 0) :* varverse (var 0) :* var 1) (var 1 :* var 2 :* :i'], 'terms-equality\n  {{?}} (x11 :: x6 :: x1 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 1 :* var 2 :* :inverse (var 2)) idp')
(['<=-antisymmetric  {?} {?}', '<=-antisymmetric  {?} {?} {?}', '<=-antisymmetric  {?} p', '<=-antisymmetric  {?} {?} {?} {?}'], '<=-antisymmetric  {?} {?}')
(['terms-equality {{?}} (x1 :: x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* var 2)) (var 1 :* var 2) idp', 'terms-equality {{?}} (x1 :: x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* var 2)) (var 1 :: x3 :: x0 :: nil) idp', 'terms-equality {{?}} (x1 :: x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* var 2)) (var 1 :: x3 :: x0 :: nil) id', 'terms-equality {{?}} (x1 :: x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* var 2)) (var 1 :: x3 :: x0 :: nil) (var 1 '], 'terms-equality {{?}} (x1 :: x3 :: x0 :: nil) (var 0 :* :inverse (var 0) :* (var 1 :* var 2)) (var 1 :* var 2) idp')
(['<=_*_positive-right  {?} {?}', '<=_*_positive-right  {?} {?} {?}', '<=_*_positive-right  {?} p', '<=_*_positive-right  a>=0 {?}'], '<=_*_positive-right  a>=0 {?}')
(['rewrite (beta2  _) {?}', 'rewrite (beta2  _ _) {?}', 'rewrite (beta1  _) {?}', 'rewrite (beta2  _) {?} {?}'], 'beta1  _ _')
(['decideEq j i', 'decideEq j (i)', 'decideEq j (i) i', 'decideEq j i i'], 'decideEq j i')
(['inP (meet-univ)', 'inP (meet-univ), meet-univ)', 'inP (meet-univ, meet-univ)', 'inP (r, meet-univ)'], 'inP (U ∧ V, <=<-right (meet-univ <=-refl <=-refl) $ <=<_meet x<=<U x<=<V, meet-monotone p q)')
(['degree_* {?} {?}', 'rewrite (degree_*) {?} {?}', 'rewrite (degree_*) {?}', 'degree_* {?} {?} {?}'], 'rewrite (degree_* p/=0 (\\lam x=0 => q/=0 $ inv s *> pmap ((*) p) x=0 *> zro_*-right)) {?}')
(['<=-uniform {t.2 @ i} {?} {?}', '<=-uniform {t.2 @ i} {?}', '<=-uniform {t.2 @ i}', '<=-uniform {{?}}'], '<=-uniform {t.2 @ i}')
(['\\new Equiv p', '\\new Equiv {\n  | ret_f => ret_f {A}\n  | ret_f => ret_f {A}\n  | ret_f => ret_f {\n  | ret_f => ret_f {\n}', '\\new Equiv {\n  | ret_f => ret_f {A}\n  | ret_f => ret_f {A}\n  | ret_f => ret_f {\n  | ret_f => ret_f {a-to-Equiv {A}\n  | ret_f =>', '\\new Equiv {\n  | ret_f => ret_f {\n  | ret_f => ret_f {\n  | ret_f => ret_f {\n  | ret_f => ret_f {\n  | ret_f => ret_f {'], '=-to-Equiv p')
(['map {?} {?}', 'map {?} {?} {?}', 'map {?} {?} {?} {?}', 'map {?} inMap {?} {?}'], 'map {?} (\\lam r => (r.1, pmap in~ r.2))')
(['join-left <∘ {?}', 'join-left <∘r {?}', 'join-left <∘l {?}', 'join-left {?}'], 'join-left <∘r {?}')
(['func-<= ', 'meet-left ', 'func-<= <=∘ {?}', 'func-<= <=∘ meet-left'], 'func-<=  meet-left')
(['later {?}', '\\lam p => {?}', 'cauchy {?} {?}', 'cauchy {?} {?} {?}'], 'cauchy-subset {?} {?}')
(['exponent ', 'exponent  (exponent ) {?} {?}', 'exponent  {?} {?}', 'exponent  (exponent ) {?}'], '(exponent ).1')
(['decideEq=_reduce idp', 'rewrite (decideEq=_reduce idp) idp', 'rewrite idp idp', 'rewrite (decideEq=_reduce p) idp'], "rewrite (decideEq=_reduce p') idp")
(['later {?}', "g' t.2 i", 'later {?} {?}', 'cover-proj1 {?} {?}'], 'wayBelowPredicate R {?} {?} basic leq dense comm')
(['terms-equality {{?}} (x12 :: x1 :: x3 :: x9 :: nil)\n  (var 0 :* var 1 :* (:inverse (var 1) :* (var 2 :* var 3) :* :inverse (var', 'terms-equality {{?}} (x12 :: x1 :: x3 :: x9 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* (var 2 :* var 3) :* :inverse (var 2', 'terms-equality\n{{?}} (x12 :: x1 :: x3 :: x9 :: nil)\n  (var 0 :* var 1 :* (:inverse (var 1) :* (var 2 :* var 3) :* :inverse (var', 'terms-equality\n{{?}} (x12 :: x1 :: x3 :: x9 :: nil) (var 0 :* var 1 :* (:inverse (var 1) :* (var 2 :* var 3) :* :inverse (var 2'], 'terms-equality {{?}} (x12 :: x1 :: x3 :: x9 :: nil)\n  (var 0 :* var 1 :* (:inverse (var 1) :* (var 2 :* var 3) :* :inverse (var 3)) :* :inverse (var 2)) (var 0) idp')
(['zero<suc {?}', 'zero<suc <∘r {?}', 'zero<suc zero<suc', 'zero<suc {?} {?}'], 'q {0} {suc j} zero<suc')
(['\\lam {x} {y} => {?}', '\\lam {x} {y} {z} => {?}', '\\lam {x} => {?}', '\\lam {x} {y} {z} {z} => {?}'], '\\lam {x} {y} {z} => {?}')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\lam {y} p => {?}', '\\lam {a} p => {?}'], '\\lam Ux => {?}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => ex) {?}', 'prop-dpi (\\lam i => ex i) {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['negative_*-left {?} {?}', 'negative_*-left {?}', 'rewrite negative_*-left {?}', 'negative_*-left <∘ {?}'], 'rewrite (negative_*-left {R}) in q')
(['\\peval coef {?}', 'coef {?} {?}', 'coef_negative {?}', '\\peval coef {?} {?}'], 'solve<Problem {{?}} nil :zro (coef (rat (pos 1) 2 {?hidden} {?hidden})) (2 :: nil, 1, idp, idp {Bool} {true}) nil')
(['simplify {d} (var 0 :* var 1 :* :inv (var 1))', 'simplify (var 0 :* var 1 :* :inv (var 1))', 'simplify {d} (var 0 :* var 1 :* :inv (var 1)) (var 0 :* var 1) idp', 'simplify {d} (var 0 :* var 1 :* :inv (var 1)) (var 0 :* var 0 :* var 1) idp'], 'simplify-correct {d} (var 0 :* var 1 :* :inv (var 1))')
(['terms-equality {{?}} (x3 :: x1 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :', 'terms-equality {{?}} (x3 :: x1 :: x2 :: nil) :ide (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :inver', 'terms-equality {{?}} (x3 :: x1 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :i', 'terms-equality {{?}} (x3 :: x1 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :inv'], 'terms-equality {{?}} (x3 :: x1 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :inverse (var 2))))) idp')
(['rewrite (interpretNF_+ {d} {0} {1} {0} {1} {1} {0} {1} {1} {0} {1} {1} {1} {0} {1} {1} {0} {1} {1} {0} {1} {1} {1} {0} {1} {1} ', 'rewrite (interpretNF_+ {d} {0} {1} {0} {1} {1} {0} {1} {1} {1} {0} {1} {1} {1} {0} {1} {1} {1} {0} {1} {1} {0} {1} {1} {0} {1} ', 'rewrite (interpretNF_+ {d} {0} {1} {0} {1} {1} {0} {1} {1} {1} {0} {1} {1} {1} {0} {1} {1} {1} {0} {1} {1} {0} {1} {1} {1} {1} ', 'rewrite (interpretNF_+ {d} {0} {1} {0} {1} {1} {0} {1} {1} {1} {0} {1} {1} {1} {0} {1} {1} {1} {0} {1} {1} {0} {1} {1} {1} {0} '], 'interpretNF_++ (0 :cons {V {d}} {1} {3} {H {d}} {1} :nil idp)\n  (0 :cons {V {d}} {0} {1} {H {d}} {2} (0 :cons {V {d}} {0} {2} {H {d}} {0} :nil idp))')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], 'later {?}')
(['rewrite (idp) idp', 'rewrite idp idp', 'rewrite (idp) idp) idp', 'terms-equality {{?}} (a.1 :: a.2 :: nil) :zro (Naterpret {2} (a.1 :: a.2 :: nil) :zro (Naterpret {2} (a.1 :: a.2 :: nil) :zro ('], 'terms-equality\n  {{?}} (a.1 :: a.2 :: nil) (:zro :* var 0 :+ :zro :* var 1 :+ :zro) (:zro :+ (:zro :* var 0 :+ :zro :* var 1)) idp')
(['terms-equality {{?}} (x4 :: x0 :: x3 :: nil) :ide\n  (var 0 :* var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :', 'terms-equality {{?}} (x4 :: x0 :: x3 :: nil) :ide (var 0 :* var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :invers', 'terms-equality {{?}} (x4 :: x0 :: x3 :: nil) :ide\n  (var 0 :* var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :i', 'terms-equality {{?}} (x4 :: x0 :: x3 :: nil) :ide\n  (var 0 :* var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :inve'], 'terms-equality {{?}} (x4 :: x0 :: x3 :: nil) :ide\n  (var 0 :* var 1 :* :inverse (var 1) :* (:inverse (var 0) :* (var 2 :* :inverse (var 2)))) idp')
(['ldiv-modEq x y', 'ldiv-modEq p p', 'ldiv-modEq x y y', 'ldiv-modEq {?} {?}'], 'ldiv-modEq (pos x) (pos y) n p')
(['trichotomy {?} {?}', 'trichotomy q s', 'trichotomy {?} {?} {?}', 'trichotomy {RatField} {?} {?}'], 'trichotomy q s')
(['finv_<-rotate-left {?} {?}', 'finv_<-rotate-left {?} {?} {?}', 'finv_<-rotate-left {?}', 'finv_<-rotate-left  {?} {?}'], 'finv_<-rotate-left q>0 {?} {?}')
(['later {?}', '(\\lam j => {?}, \\lam j => {?})', '(\\lam j => {?}, \\lam p => {?})', '\\case \\elim j \\with {\n  | inP (j, inP (j, r<q, => {?}\n})) => {?}\n}'], "lr'.2 j")
(['\\lam p => {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '(\\lam p => {?}, \\lam p => {?})', '\\case \\elim 0 \\with {\n  | 0 => {?}\n}'], "(z1<b', c'<z2)")
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', 'apply-axiom {{?}} {?} {?}', '\\case \\elim p \\with {\n  | interpretNF => {?}\n}'], 'apply-axiom env (var 1 :* var 2) (var 3 :* var 4) r 1 (0 :: 0 :: nil)')
(['\\new LinearRatAlgebraData\n  | R => RealField\n  | vars => zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: ', '\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :', '\\new LinearRatAlgebraData\n  | R => RealField\n  | vars => zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: x :: zr', '\\new LinearRatAlgebraData\n  | R => RealField\n  | vars => zro :: zro :: zro :: zro :: zro :: zro :: zro :: zro :: x :: zro :: zr'], '\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => zro :: zro :: zro :: zro :: x :: zro :: zro :: delta :: zro :: join (x - half delta) S.2 :: nil\n}')
(['<=-antisymmetric {?} {?}', '<=-antisymmetric {?} {?} {?}', '<=-antisymmetric {X} {?} {?}', '<=-antisymmetric {?} {?} {?} {?}'], '<=-antisymmetric {?} {?}')
(['\\lam a => {?}', '\\lam a u => {?}', '\\lam a<-> {?}', '(\\lam a u => {?}, \\lam a => {?})'], 'oneDimensional-char {R}')
(['terms-equality {{?}} (x7 :: x11 :: x10 :: nil) (var 0 :* (vanverse (var 0) :* var 1 :* (var 2 :* var 0 :* (:inverse (var ', 'terms-equality {{?}} (x7 :: x11 :: x10 :: nil) (var 0 :* (:inverse (var 0) :* var 1 :* (var 2 :* var 0 :* (:inverse (var ', 'terms-equality\n{{?}} (x7 :: x11 :: x10 :: nil) (var 0 :* (:inverse (var 0) :* var 1 :* (var 2 :* var 0 :* (:inverse (var 0) :* ', 'terms-equality {{?}} (x7 :: x11 :: x10 :: nil)\n  (var 0 :* (varverse (var 0) :* var 1 :* (var 2 :* var 0 :* (:inverse (var '], 'terms-equality {{?}} (x7 :: x11 :: x1 :: x10 :: nil)\n  (var 0 :* (:inverse (var 0) :* var 1 :* (var 2 :* var 0) :* var 3) :* (:inverse (var 3) :* :inverse (var 0)))\n  (var 1 :* var 2) idp')
(['decideEq=_reduce idp', 'rewrite (decideEq=_reduce idp) idp', 'rewrite idp idp', 'decideEq=_reduce p'], 'rewrite (decideEq=_reduce e) idp')
(['uniform {?} {?}', 'uniform {X} {?} {?}', 'h j', 'uniform {?} {?} {?}'], '(h j).3')
(['\\lam i => {?}', '\\lam p => {?}', '\\lam q => {?}', '\\lam {i} {j} => {?}'], "reduced-tail {V} {B} l'r")
(['negative_* ', 'negative_*  {?}', 'negative_*  {?} {?}', 'negative_*  p'], 'negative_* ')
(['\\lam {x} => {?}', '\\lam {x} p => {?}', '\\lam {x} {x} => {?}', '\\lam {x} x<0 => {?}'], '\\lam {x} x/#0 => {?}')
(['terms-equality (var 0 :* (var 1 :* var 2) :* var 3) idp', 'terms-equality {d} ((var 0 :* (var 1 :* var 2) :* var 3) idp', 'terms-equality {d} (0 :* (var 1 :* var 2) :* var 3) idp', 'terms-equality {d} (0 :* (var 1 :* var 2) :* var 3) (var 0 :* var 1 :* var 3) idp'], 'terms-equality {d} (var 0 :* (var 1 :* var 2) :* var 3) (var 0 :* var 1 :* (var 2 :* var 3)) idp')
(['diff-lem {?} {?}', 'diff-lem {?} {?} {?}', 'diff-lem {?} {?} {?} {?}', 'diff-lem {R} {?} {?}'], 'diff-lem {?} t {?}')
(['\\lam {U} p => {?}', '\\lam p => {?}', '\\lam p0 => {?}', '\\lam {U} TU => {?}'], "Refines-trans r' r")
(['func-* {d}', 'func-* ', 'func-* {d} {a}', 'func-* {x}'], 'func-* ')
(['\\lam {y} p => {?}', '\\lam {y} => {?}', '\\lam S => {?}', '\\lam {y} {S} => {?}'], 'helper {_} {_} {_} {l}')
(['toZero  {?} {?}', 'toZero  {?} {?} {?}', 'toZero  {?} {?} {?} {?}', 'toZero  {?} p'], 'toZero  {finv x * x} {ide} p')
(['interpretNF-consistent {env}', 'interpretNF-consistent ', 'interpretNF-consistent {e}', 'interpretNF-consistent {{?}}'], 'interpretNF-consistent {{?}}')
(['finCard {?}', 'finSet {?}', 'finSet {?} {?}', '\\new FinSet {\n  | Dom => UnitFin \n  | Coef => natCoef \n  | Coef => natCoef \n  | Coef => natCoef \n}'], 'ProdFin _ _')
(['FinSum_char2  {?} {?}', 'FinSum_char2  {?}', 'FinSum_char2 ', 'FinSum_char2 {J} {?}'], 'FinSum_char2  e')
(['decideEq a p', 'decideEq (a *c p) {?}', 'decideEq a (c p) {?}', 'decideEq a (c p) {?} {?}'], 'rewrite a=0 {?}')
(['determinangupperTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangt', 'determinangUpperTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangt', 'determinangUpperTriangupperTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTria', 'determinangupperTriangupperTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTriangtrTria'], 'determinant_IsUpperTriangular {?}')
(['join-left ', 'join-left <=∘ join-left', 'join-left <=∘ {?}', 'join-left <=∘  {?}'], 'join-left ')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\lam p => {?} p'], '\\lam p0 => {?}')
(['filter-mono {?} {?}', 'filter-mono FU {?}', 'filter-mono {?} {?} {?}', 'filter-mono {A} {?} {?}'], 'filter-mono Fr {?}')
(['terms-equality {{?}} (x6 :: x1 :: x11 :: x5 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0) :* (var 2 ', 'terms-equality {{?}} (x6 :: x1 :: x11 :: x5 :: nil) :ide (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0) :* (var 2 :*', 'terms-equality\n{{?}} (x6 :: x1 :: x11 :: x5 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0) :* (var 2 ', 'terms-equality\n  {{?}} (x6 :: x1 :: x11 :: x5 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0) :* (var '], 'terms-equality {{?}} (x6 :: x1 :: x11 :: x5 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* :inverse (var 0) :* (var 2 :* :inverse (var 2) :* var 3) :* :inverse (var 3))\n  idp')
(['BigSum_zro {?}', 'BigSum_zro {?} {?}', 'BigSum_zro {R} {?}', 'BigSum_zro {R} {?} {?}'], 'BigSum_zro {R} {?}')
(['\\lam N<=n => {?}', '\\lam p => {?}', '\\lam {n} p => {?}', '\\lam {n} N<=n => {?}'], '\\lam _ => {?}')
(['terms-equality {{?}} (x3 :: x5 :: x4 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 1 :* var 2 :* (:inverse (var 2) :* :', 'terms-equality {{?}} (x3 :: x5 :: x4 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 1 :* var 2 :* (:inverse (var 2) :* :inve', 'terms-equality {{?}} (x3 :: x5 :: x4 :: nil) (var 0 :* :inverse (var 0) :* var 1) (var 1 :* var 2 :* (:inverse (var 2) :* :i', 'terms-equality {{?}} (x3 :: x5 :: x4 :: nil) (var 0 :* :inverse (var 0) :* var 1)\n  (var 1 :* var 2 :* (:inverse (var 2) :* :'], 'terms-equality {{?}} (x3 :: x5 :: x4 :: nil) (var 0 :* :inverse (var 0) :* var 1)\n  (var 1 :* var 1 :* (var 2 :* (:inverse (var 2) :* :inverse (var 1)))) idp')
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\peval hom-presheaf {?}', '\\peval hom-presheaf Y Y'], '\\case \\elim p0 \\with {\n  | (Z, p) => {?}\n}')
(['terms-equality {{?}} (x12 :: nil) (var 0) (var 0) idp', 'terms-equality  {{?}} (x12 :: nil) (var 0) (var 0) idp', 'terms-equality  {?} idp', 'terms-equality  (var 0) (var 0) idp'], 'terms-equality {{?}} (x12 :: nil) (var 0) (var 0) idp')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => ex) {?} {?}', 'prop-dpi (\\lam i => {?}) {?} {?}'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['negative_<=  {?} {?}', 'negative_<=  {?}', 'negative_<=  p', 'negative_<=  x<=y'], 'negative_<=  {?}')
(['\\lam p => {?}', '\\lam x<a => {?}', '\\lam x<=a => {?}', '\\peval x * x x<a'], '\\lam x<a => {?}')
(['{?} <=∘ {?}', '{?} <∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}'], 'transport2 (<) {?} +-rat {?}')
(['interpretNF_negate  {?} {?}', 'interpretNF_negate  {?}', '\\new CRingData {\n  | R => E\n  | vars => t1 :: s !! 0 :: v1 :: u :: v1 :: u :: Big {?}\n}', '\\new CRingData {\n  | R => E\n  | vars => t1 :: s !! 0 :: v1 :: u :: v1 :: u :: Big {E} (+) (t1 :: s !! 0 :: v1 :: u :: Big {E} ('], '\\new CRingData {\n  | R => this\n  | vars => t1 :: s !! 0 :: v1 :: u !! 0 :: Big {E} {E} (+) zro (\\new Array E n (\\lam (j : Fin n) => s !! suc j * u !! suc j)) :: d :: u1 :: a1 :: s1 :: nil\n}')
(['cMonoid L', '\\new CMonoid L', 'CMonoid L', 'cMonoid {L}'], 'L ')
(['a<=0 <∘ {?}', '{?} <=∘ {?}', '{?} <∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], 'rewrite b=0 {?}')
(['\\lam {X} => {?}', '(@) {?} i {X}', '\\lam {X} {Y} => {?}', 'h1 @ i'], '\\lam {X} => {?}')
(['\\lam {j} => {?}', '(@) {?} i {J}', '\\lam {j} {j} => {?}', '\\lam {j} h => {?}'], '(@) {?} i {j}')
(['\\lam i => {?}', '\\new DArray {\n  | f => \\lam i => f (e.f i)\n}', '\\new DArray {\n  | at => \\lam i => f (e.f i)\n}', '\\new DArray {\n  | f => \\lam i => f\n  | f => \\lam i => f i\n}'], '\\lam i => {?}')
(['map {?} {?}', 'map {?} i', 'map (\\lam a => lift_transposition1 i) {?}', 'map (\\lam a => lift_transposition1 i) {?} i'], 'map (\\lam a => lift_transposition1 {n} {a} i) r.1')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p0, \\elim p1 \\with {\n  | inP (j, p), inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j', '\\case \\elim p0, \\elim p1 \\with {\n  | inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, in', '\\case \\elim p0, \\elim p1 \\with {\n  | inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, inP (j, p)'], 'inP ((pairs-index i j).1, rewrite (pairs-index i j).2 $ +_U_<=.2 $ inP (_, d, _, e, linarith))')
(['meet-uniform {S2}', 'meet-uniform {S2} {?} {?}', 'meet-uniform {S2} {?}', 'meet-uniform {S2} {?} {?} {?}'], 'meet-uniform {S2}')
(['L-inh {x}', 'L-inh {x - ide}', 'L-inh ', 'L-inh {x - 1}'], 'L-inh {x - 1}')
(['diff_* ', 'diff_*  ', 'diff_*  {?}', 'diff_*  {?} {?}'], 'diff_* ')
(['L-rounded {?}', 'L-rounded {a}', 'L-rounded ', 'L-rounded {a + b}'], 'L-rounded {join (a + b) (a + c)}')
(['SFRefines {V} {B} {?} {?}', 'SFRefines {V} {?} {?}', 'SFRefines {V} {B} {?}', '\\peval SFRefines _ _'], 'SFRefines_++-right {V} {B} {?} {?}')
(['inverse-left ', 'inverse-left  {?}', 'inverse-left  {?} {?}', 'inverse-left {?}'], 'inverse-left ')
(['\\lam _ => {?}', '\\lam e => {?}', '\\lam e p => {?}', '\\lam (e : A.E) => {?}'], '\\lam _ => {?}')
(['\\lam p => {?}', '\\lam {x} z<z => {?}', '\\lam {x} x<y => {?}', '\\lam {x} z<y => {?}'], '\\lam x<0 y<z => {?}')
(['limBeta {L} {?} {?}', 'limBeta {L} {?}', 'limBeta {L} {?} {?} {?}', 'limBeta {l} {?} {?}'], 'limBeta {L} {?} 1')
(['\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}) => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n} {?}\n}', '\\peval matchingFamily x (\\lam p => (matchingFamily p p))'], 'p x g c z')
(['Join-univ {?}', 'Join-univ {?} {?}', 'Join-univ <=∘ {?}', 'Join-univ {?} {?} {?}'], 'Join-univ {?}')
(['terms-equality {{?}} (x1 :: x2 :: x4 :: x6 :: nil) (var 0 :* :inverse (var 0) :* varverse (var 0) :* var 1 :* var 2) (var 1 :* ', 'terms-equality {{?}} (x1 :: x2 :: x4 :: x6 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* var 2) (var 1 :* (var 2 :* var 3) idp', 'terms-equality {{?}} (x1 :: x2 :: x4 :: x6 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* var 2) (var 1 :* (var 2 :* var 3)) id', 'terms-equality {{?}} (x1 :: x2 :: x4 :: x6 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* var 2) (var 1 :* (var 2 :* var 3) :* '], 'terms-equality {{?}} (x1 :: x2 :: x4 :: x6 :: nil) (var 0 :* :inverse (var 0) :* var 1 :* var 2)\n  (var 1 :* (var 2 :* var 3) :* :inverse (var 3)) idp')
(['diff {B} {?}', 'diff-univ {B} {?} {?}', 'rewrite (diff {B}) {?}', 'rewrite (diff-univ {B}) {?}'], 'rewrite p {?}')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p2 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}) => {?}\n}'], '\\scase \\elim p0, \\elim p1, \\elim p2 \\with {\n  | in~ a, in~ b, in~ c => {?}\n}')
(['\\lam Uo Ux => {?}', '\\lam p => {?}', '\\lam Uo => {?}', '\\lam _ => {?}'], '\\scase \\elim n \\with {\n  | pos n => {?}\n  | neg n => {?}\n}')
(['StronglyCompleteUniformSpace {?} {?}', 'StronglyCompleteUniformSpace {?}', 'StronglyCompleteUniformSpace _', 'StronglyCompleteUniformSpace _ _'], 'UniformStrongCompletion _')
(['later {?}', 'liftSequent S {?} {?}', 'liftSequent S', 'liftSequent S S'], 'p j')
(['join-univ  {?} {?}', 'join-univ  {?} {?} {?}', 'join-univ  {?} p', 'join-univ '], 'join-univ  {?} {?}')
(['~-psequiv {?}', '~-psequiv {?} {?}', '~-psequiv l', '~-psequiv l1'], '~-psequiv (eperm-++-left r)')
(['zro_*-left {_}', 'zro_*-left {_} {a}', 'zro_*-left <∘r {?}', 'zro_*-left {_} {x}'], 'zro_*-left {_} {a}')
(['+_L.1 r', '+_L.2 r', '+_L.1 r<-r', '+_L.2 r<-r'], '+_L.2 {?}')
(['inP (top, idp)', 'inP (top-univ)', 'inP (top, idp), top-univ)', 'inP (top, idp, top-univ)'], 'inP (top, idp, top-univ)')
(['isProper {?}', 'isProper {?} {?}', 'isProper S', 'isProper S {?}'], 'isProper FU')
(['<_*_U-right {?} {?}', '<_*_U-right {?} {?} {?}', '<_*_U-right {?}', '<_*_U-right {?} {?} {?} {?}'], '<_*_U-right B1>0 {?} {?}')
(['isUniform {?} {?}', '\\peval isUniform {?} {?}', '\\peval isUniform {?} {?} {?}', '\\peval isUniform  Eu x'], 'totallyBounded-cauchy-strong-uniform {{?}} {?} {?} {?}')
(['unique2 {?} {?}', 'unique2 {?} {?} {?}', 'unique2 {?} {?} {?} {?}', 'unique2 {RealNormed} {?} {?}'], 'unique2 *-cover {?} {?}')
(['{?} @ i', '(@) {?} i {u}', '{?} <=∘ {?}', '(@) {?} i {X}'], '{?} @ i')
(['cover_ideal c', 'cover_ideal {?}', 'cover_ideal {?} {?}', 'cover_ideal p'], '\\case cover_ideal c \\with {\n  | inP (n, inP (l : DArray, p)) => {?}\n}')
(['later {?}', '(basisSet-split ub v y).2', 'basisSet-split ub v y', '(basisSet-split ub v y).2 {?}'], '(basisSet-split ub v y).2')
(['rewrite ide-right {?}', 'rewrite ide-left {?}', 'rewrite (dec<_reduce q) {?}', 'rewrite (dec<_reduce r) {?}'], 'rewrite (dec<_reduce id<suc) {?}')
(['*c_IsDiagonal {?}', '*c_IsDiagonal {?} {?}', '*c_IsDiagonal p', '*c_IsDiagonal {d *c B}'], '*c_IsDiagonal Bd')
(['transport I p {?}', 'transport I p {?} {?}', 'transport ((<) _) {?} {?}', 'transport (\\lam _x => _x <= _) {?} {?}'], 'transport I addGroup {?}')
(['transport ((<) ) ) {?} {?}', 'transport (\\lam _x => _x <= _) {?} {?}', 'transport (\\lam _x => _x <= _) p {?}', 'transport (\\lam _x => _x <= _) {?} x'], 'transport ((#)  x) {?} x#y')
(['<_meet-univ  {?} {?}', '<_meet-univ  {?} {?} {?}', '<_meet-univ  {?} {?} {?} {?}', '<_meet-univ  {?} p'], '<_meet-univ linarith linarith')
(['<_+-right  x<y x<y', '<_+-right  x<y y<y', '<_+-right  x<y {?}', '<_+-right  {?} {?}'], '<_+-right  x y>z')
(['absurd {?}', 'absurd {?} idp', '\\lam s => {?}', 'absurd {?} {?}'], 'absurd {?}')
(['transport ((<) ) {?} {?}', 'transport (func-Join ) {?}', 'transport (func-Join ) {?} {?}', 'transport (func-Join) {?} {?}'], 'transport ((<=) _) func-Join {?}')
(['tuple {?} {?}', 'cont {X} {?} {?}', 'cont {X} {?} id', '\\new ContMap {\n  | R => R\n  | Dom => R\n  | Cod => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => R\n  | C => '], '*c-cont ∘ {?}')
(['Func-id {F}', 'Func-id {f}', 'Func-id {X}', 'Func-id A'], 'Func-id {F} {A}')
(['later {?}', 'rewrite p=0 {?}', 'leadCoef {K} {?} {?}', 'leadCoef {K} {?}'], 'finv-left {K} {?}')
(['transport ((<=) ) {?} {?}', 'transport ((<=) _) {?} {?}', 'transport (conj a) {?} {?}', 'transport ((<=) _) conj {?} {?}'], 'transport (\\lam _x => _x <= _) {?} {?}')
(['func-+ {f}', 'func-+ {f} {?}', 'rewrite (func-+ {f}) {?}', 'func-+ {x}'], 'func-+ {f}')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', 'later {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | in~ q => {?}\n}'], '\\case \\elim p0 \\with {\n  | in~ q => {?}\n}')
(['terms-equality {{?}} (x4 :: x1 :: nil) (var 0 :* var 0) (var 1 :* :inverse (var 1) :* (var 0 :* var 0 :* var 0)) idp', 'terms-equality {{?}} (x4 :: x1 :: nil) (var 0 :* var 0) (var 1 :* :inverse (var 1) :* (var 0 :* var 0)) idp', 'terms-equality {{?}} (x4 :: x1 :: nil) (var 0 :* var 0) (var 1 :* :inverse (var 1) :* (var 0 :* var 0 :* var 0)) id', 'terms-equality\n{{?}} (x4 :: x1 :: nil) (var 0 :* var 0) (var 1 :* :inverse (var 1) :* (var 0 :* var 0 :* var 0)) idp'], 'terms-equality {{?}} (x4 :: x1 :: nil) (var 0 :* var 0) (var 1 :* :inverse (var 1) :* (var 0 :* var 0)) idp')
(['terms-equality {{?}} (x7 :: x3 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp', 'terms-equality\n{{?}} (x7 :: x3 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp', 'terms-equality {{?}} (x7 :: x3 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1) idp', 'terms-equality\n  {{?}} (x7 :: x3 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp'], 'terms-equality {{?}} (x7 :: x3 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp')
(['cover-cover {?} {?}', 'tuple {?} {?}', 'cover-cover {?} {?} {?}', 'cover-cover ∘ {?}'], '{?} ∘ {?}')
(['replicate l a', 'replicate (count a) {?}', 'replicate (count l) a', 'replicate (count a) {?} {?}'], 'replicate (count l a) a')
(['terms-equality {{?}} (x11 :: x6 :: x8 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* (var 2 :* (:inverse (var 2) :* :i', 'terms-equality {{?}} (x11 :: x6 :: x8 :: nil) :ide (var 0 :* (var 1 :* :inverse (var 1)) :* (var 2 :* (:inverse (var 2) :* :inv', 'terms-equality {{?}} (x11 :: x6 :: x8 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* (var 2 :* (:inverse (var 2) :* :', 'terms-equality\n{{?}} (x11 :: x6 :: x8 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* (var 2 :* (:inverse (var 2) :* :i'], 'terms-equality {{?}} (x11 :: x6 :: x8 :: nil) :ide\n  (var 0 :* (var 1 :* :inverse (var 1)) :* (var 2 :* (:inverse (var 2) :* :inverse (var 0)))) idp')
(['h {?}', 'later {?}', 'h {?} {?}', 'h x'], 'h p')
(['\\lam {n} {x} => {?}', '\\lam {n} {x} {x} => {?}', '\\lam {n} => {?}', '\\lam {n} p => {?}'], '\\lam {n} {x} => {?}')
(['\\lam c => {?}', 'finSum {?}', 'finSum {?} {?}', 'finSum {?} {?} {?}'], 'later {?}')
(['*c_zro-right {B}', '*c_zro-right {B} {?}', '*c_zro-right {A}', '*c_zro-right {{?}}'], '*c_zro-right {B}')
(['{?} <=∘ {?}', "b'<a <∘r {?}", "b'<a <∘ {?}", "rewrite (b'') {?}"], '{?} <∘l {RatField} b+c<=a')
(['\\lam x<=y => {?}', '\\lam p => {?}', '\\lam {x} => {?}', '\\lam {x} {y} => {?}'], '\\lam p {_} => {?}')
(['\\lam a a => {?}', '\\lam a a p => {?}', '\\lam a a a => {?}', '\\lam a a a a l => {?}'], '\\lam a al => {?}')
(['<=-antisymmetric {?} {?}', '<=-antisymmetric {?} {?} {?}', '<=-antisymmetric {?} p', '<=-antisymmetric p {?}'], '<=-antisymmetric {?} {?}')
(['\\lam p => {?}', 'rewrite p {?}', "\\lam {V} V<=<U' => {?}", '\\lam {V} V<=<U => {?}'], "V<=U <=∘ U<=U'")
(['{?} <=∘ {?}', '\\lam p => {?}', '{?} <=∘  {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}'], '\\lam p => {?}')
(['inv-right {solver}', 'inv-right {?}', 'inv-right {{?}}', 'inv-right {solver} env'], 'apply-axiom {solver} env (var 0 :* var 1) (var 3) d2.inv-right (0 :: 3 :: nil)')
(['terms-equality {{?}} (x2 :: x3 :: nil) (var 0) (var 0 :* var 1 :* :inverse (var 1)) idp', 'terms-equality\n{{?}} (x2 :: x3 :: nil) (var 0) (var 0 :* var 1 :* :inverse (var 1)) idp', 'terms-equality\n  {{?}} (x2 :: x3 :: nil) (var 0) (var 0 :* var 1 :* :inverse (var 1)) idp', 'terms-equality {{?}} (x2 :: x3 :: nil) (var 0) (var 0 :* var 1 :* :inverse (var 1))) idp'], 'terms-equality {{?}} (x2 :: x3 :: nil) (var 0) (var 0 :* var 1 :* :inverse (var 1)) idp')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi {?} {?}', 'prop-dpi (\\lam i => ext_coe) {?} x', 'prop-dpi (\\lam i => ext_coe) {?} p'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '{?} <=∘ {?}', '{?} <∘ {?}'], '{?} <∘r {?}')
(['\\lam {x} {y} => {?}', '\\lam {x} {y} {?}', '\\lam {x} => {?}', '\\lam {x} {y} p => {?}'], '\\lam {x} {y} => {?}')
(['rewrite p idp', 'rewrite (idp) idp', 'rewrite (idp) idp) idp', 'rewrite (idp, idp) idp'], '(idp, Ux)')
(['\\lam Dc => {?}', '\\lam {D} Dc => {?}', '\\lam f => {?}', '\\lam Cc => {?}'], '\\lam {D} p0 F => {?}')
(['<=_+ <=-refl {?}', '<=_+ <=-refl zero<=_', '<=_+ zero<=_ <=-refl', '<=_+ {?} <=-refl'], '<=_+ zero<=_ <=-refl')
(['c {?}', 'c {?} {?}', 'cStruct {?}', 'cStruct {?} {?}'], 'rewrite p Ix')
(['<_/=  {?} {?}', 'meet/=left ', 'meet/=left  {?} {?}', 'meet/=left  x<y'], 'rewrite (meet/=left $ <_/=  q) x<z')
(['ListMonoid {?}', 'ListMonoid Bool', 'ListMonoid S B', 'ListMMonoid {?}'], 'ListMonoid {\\Sigma S Bool}')
(['prop-dpi (\\lam i => ext_coe) {?} {?}', 'prop-dpi (\\lam i => {?}) {?}', 'prop-dpi (\\lam i => ext_coe) {?} {?} {?}', 'prop-dpi (\\lam i => ext_coepletion {L})'], 'prop-dpi (\\lam i => ext_coe) {?} {?}')
(['terms-equality {{?}} (x4 :: x6 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp', 'terms-equality\n{{?}} (x4 :: x6 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp', 'terms-equality\n  {{?}} (x4 :: x6 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp', 'terms-equality {{?}} (x4 :: x6 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1) idp'], 'terms-equality {{?}} (x4 :: x6 :: nil) (var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1)) idp')
(['terms-equality {{?}} (x1 :: x4 :: nil) (var 0 :* var 1 :* :inverse (var 1)) (var 0 :* (var 0 :* var 1)) idp', 'terms-equality {{?}} (x1 :: x4 :: nil) (var 0 :* var 1 :* :inverse (var 1)) (var 0 :* (var 0 :* (var 0 :* (var 1 :* :inverse (v', 'terms-equality {{?}} (x1 :: x4 :: nil) (var 0 :* var 1 :* :inverse (var 1)) (var 0 :* (var 0 :* (var 0 :* var 1)) id', 'terms-equality {{?}} (x1 :: x4 :: nil) (var 0 :* var 1 :* :inverse (var 1)) (var 0 :* (var 0 :* (var 0 :* var 1)) idp'], 'terms-equality {{?}} (x1 :: x4 :: nil) (var 0 :* var 1 :* :inverse (var 1)) (var 0 :* (var 1 :* :inverse (var 1))) idp')
(['filter-top {F}', 'filter-top {f}', 'filter-top {?}', 'filter-top {f} {?}'], 'filter-top {F}')
(['yes {?}', 'yes x', 'yes {?} {?}', 'yes p'], 'yes {?}')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\lam Uo => {?}', '\\lam Uo Up => {?}'], 'fc {?} {?}')
(['L-inh {y}', 'L-inh ', 'L-inh y<y', 'L-inh {y} y<y'], 'L-inh {y}')
(['strExtF S', 'strExtF {?}', 'strExtF {?} {?}', 'rho {?}'], 'strExtF  C S.4')
(['=_<= {?}', '=_<= {?} {?}', '=_<= p', '=_<= direct x'], '=_<= {?}')
(['\\lam x => {?}', '\\lam x y => {?}', '\\lam x p => {?}', '\\lam x x => {?}'], '\\lam x => {?}')
(['terms-equality {{?}} (x2 :: x1 :: nil) (var 0 :* var 0 :* var :inverse (var 0)) (var 1 :* :inverse (var 1) :* var 0) id', 'terms-equality {{?}} (x2 :: x1 :: nil) (var 0 :* var 0 :* var :inverse (var 0)) (var 1 :* :inverse (var 1) :* var 0) idp', 'terms-equality {{?}} (x2 :: x1 :: nil) (var 0 :* var 0 :* var 0 :* var :inverse (var 0)) (var 1 :* :inverse (var 1) :* var', 'terms-equality {{?}} (x2 :: x1 :: nil) (var 0 :* var 0 :* var 0 :* var 0 :* var :inverse (var 0)) (var 1 :* :inverse (var 1) :*'], 'terms-equality {{?}} (x2 :: x1 :: nil) (var 0 :* var 0 :* :inverse (var 0)) (var 1 :* :inverse (var 1) :* var 0) idp')
(['=_<= {?}', '=_<= {?} {?}', '=_<= p', '=_<= fd s'], '=_<= {?}')
(['\\lam j => {?}', '\\lam g => {?}', 'isFinitelyGenerated {?}', 'isFinitelyGenerated  {?}'], '\\lam ie => {?}')
(['\\case \\elim p \\with {\n  | inP (b, p), bb) => {?}\n}', '\\case \\elim p \\with {\n  | inP (b, b<d), {?}\n}', '\\case \\elim p \\with {\n  | inP (b, b<d), inP (b, b<d, b), inP (b, b<d), inP (b, b<d), inP (b, b<d), inP (b, b<d), inP (b, b<d), ', '\\case \\elim p \\with {\n  | inP (b, b<d), inP (b, b<d, b), inP (b, b<d, b), inP (b, b<d), inP (b, b<d), inP (b, b<d), inP (b, b<d'], "\\scase +_U.1 p \\with {\n  | inP (a, inP (q, q<a, U, FU, V, GV, g), b, inP (r, r<b, V', GV', W, HW, h), a+b<d) => {?}\n}")
(['{?} <=∘ {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | inv p => {?}\n}', 'rewrite (inv (*) {?} {?}'], 'transport ((<) _) {?} {?}')
(['+-rat {?}', '+-rat.1 {?}', '+-rat.2 {?}', '+-rat {?} {?}'], 'transport (\\lam _x => _x <= _) +-rat {?}')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', 'coverTransfer-map {?} {?}', 'cauchy {?} {?} {?}', 'coverTransfer-map {?} {?} {?}'], 'func-cover {{?}} Dc')
(['inP (V, CV, idp)', "inP (V, CU', idp)", "inP (V', CV, idp)", "inP (V', CU', idp)"], "inP (U, U', CU, DUU', idp)")
(['\\lam {p0} p1 => {?}', '\\lam p0 => {?}', '\\lam {p0} p2 => {?}', '\\lam p => {?}'], '\\lam {p0} p1 => {?}')
(['\\lam p => {?}', '\\lam p0 => {?}', '\\lam c => {?}', '\\lam e => {?}'], '\\lam e => {?}')
(['perm-consistent  {?} {?}', 'perm-consistent ', 'perm-consistent  {?} {?} {?}', 'perm-consistent  l1 p'], 'perm-consistent p1')
(['\\lam {U} p => {?}', '\\lam p => {?}', '\\lam p0 => {?}', '\\lam {U} TruncP => {?}'], '\\lam p0 => {?}')
(['+_U.1 dp', '+_U.2 {?}', '+_U.2 dp', '+_U.2 d'], '+_U.1 xy+yz<d')
(['inP (h, idp)', 'homogen-zro {?} idp', '\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | inP (y, idp) => {?}\n}'], 'inP ((0, 1, contains_ide {S}), idp, 0, homogen-zro, homogen-ide {R})')
(['determinant {?} {?}', 'determinant B BM', 'determinant B B {?}', 'determinant {?} {?} {?}'], 'rewrite p {?}')
(['later {?}', '\\new TruncP {\n  | R => R\n  | vars => B\n  | vars => toFin j \n  | vars => B\n  | toFin j => B\n  | toFin j => toFin j \n  | toFin j ', '\\new TruncP {\n  | R => R\n  | vars => B\n  | vars => toFin j \n  | vars => B\n  | toFin j => B\n  | toFin j => B\n  | toFin j => toFi', '\\new TruncP {\n  | R => R\n  | vars => B\n  | vars => toFin j \n  | vars => B\n  | toFin j => toFin j \n  | toFin j => B\n  | toFin j '], 'smith-diag Bs {?} {?}')
(['cone f {?}', 'cone {C} {D} {J} {?}', 'cone {C} {D} {?} {?}', 'cone {C} {D} {J} {?} {?}'], 'cone {C} {D} {J} {G} f')
(['somepoint ', '\\new Non-constant-vector somepoint', '\\new Non-constant somepoint', 'constant-vector somepoint '], 'equation-1 ')
(['terms-equality {{?}} (x1 :: x7 :: nil) (var 0) (var 1 :* (:inverse (var 1) :* var 0)) idp', 'terms-equality\n{{?}} (x1 :: x7 :: nil) (var 0) (var 1 :* (:inverse (var 1) :* var 0)) idp', 'terms-equality\n  {{?}} (x1 :: x7 :: nil) (var 0) (var 1 :* (:inverse (var 1) :* var 0)) idp', 'terms-equality {{?}} (x1 :: x7 :: nil) (var 0) (var 1 :: x7 :: nil) (var 0) (var 1 :* (:inverse (var 1) :* var 0)) idp'], 'terms-equality {{?}} (x1 :: x7 :: nil) (var 0) (var 1 :* (:inverse (var 1) :* var 0)) idp')
(['real_<-char.2 {?}', 'real_<-char {?} {?}', 'real_<-char.2 {?} {?}', 'real_<-char.1 x<-1'], '(real_<-char {x - delta} {x}).1 linarith')
(['\\lam X => {?}', '\\lam X p => {?}', '\\lam X f => {?}', '\\lam X {X} {?} => {?}'], '\\lam X => {?}')
(['homogen-negative  {?} {?}', 'homogen-negative  {?}', 'homogen-negative  {?} {?} {?}', 'homogen-negative  {?} p'], 'homogen-negative  {?}')
(['<_+  {?} {?}', '<_+ {?} {?}', '<_+  {?} {?} {?}', '<_+ {?} {?} {?}'], '<_+ {RealAbGroup} s {?}')
(['\\lam eps>0 => {?}', '\\lam {eps} eps>0 => {?}', '\\lam p => {?}', '\\lam {eps} p => {?}'], '\\lam {eps} eps>0 => {?}')
(['\\lam Sc => {?}', 'later {?}', '\\lam {C} Sc => {?}', '\\lam {C} p => {?}'], '\\lam {C} => {?}')
(['degree_degree< {?} {?}', 'degree_degree< {?}', 'degree_degree< {?} {?} {?}', 'degree_degree< q<q'], 'degree_degree< q<n')
(['\\case \\elim p0 \\with {\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', '\\case \\elim p0 \\with {\n  | 0 => {?}\n  | 0 => {?}\n}', '\\case \\elim p \\with {\n  | 0 => {?}\n  | 0 => {?}\n}'], 'OBall_s<=* {?}')
(['{?} <=∘ {?}', 'd2<d2 <∘ {?}', 'd2<d2 <∘r {?}', 'rewrite (d2 * p) {?}'], '<-char-conv-aux r1 p')
(['isProp=>PathContr {?} {?}', "isProp=>PathContr a a'", 'isProp=>PathContr {A} {?}', "isProp=>PathContr (\\lam a a') => {?}"], 'isProp=>PathContr A p')
(['inP (u, helper1 p2)', '(helper1 p2).2', 'inP (u, helper1 p2, inP (a, helper1 p2))', 'inP (u, helper1 p2, inP (a, helper1 p2), helper1 p2)'], 'inP (nil, x2, a.1, a.2, (idp, rewrite {2} e2 (rewrite (helper1 p6) idp)))')
(['{?} <=∘ {?}', '\\peval r * {?}', '\\lam p => {?}', '\\peval r * q'], '{?} <=∘ {?}')
(['\\lam X => {?}', 'func-cover {X}', '\\lam X p => {?}', 'func-cover {X} {?}'], '\\lam X => {?}')
(['\\lam p => {?}', '\\lam x<y => {?}', '\\lam x => {?}', '\\lam f => {?}'], 'dist-uniform.1 Eu')
(['\\lam {y} => {?}', '(@) {?} i {x}', '(@) {?} i {X}', '{?} @ i'], '(@) {?} i {x}')
(['cauchy-open {S}', 'cauchy-open {S} {?}', 'cauchy-open {S} {?} {?}', 'cauchy-open {S} So'], 'cauchy-open {S}')
(['mid>left {?} {?}', 'mid>left {?}', 'mid>left <∘ {?}', 'mid>left {?} {?} {?}'], 'mid>left q<a+b')
(['\\lam p => {?}', '\\lam c => {?}', '\\lam x => {?}', '\\lam p0 => {?}'], '(H.3 _).2')
(['BigSum {?}', 'BigSum {R} {?}', 'BigSum {?} {?}', 'BigSum-unique {?} {?}'], 'monoidSet-coefs-coh {M} {R} {P} {d} e')
(['crefl idp', 'crefl {?}', 'crefl {?} idp', 'crefl (rewrite idp)'], 'crefl idp')
(['absurd {?}', '\\lam j => {?}', '\\case \\elim j \\with {\n  | 0 => {?}\n}', '\\case \\elim j, \\elim p \\with {\n  | 0 => {?}\n}'], 'absurd {?}')
(['norm_+ <=∘ {?}', '<=_+ <=-refl {?}', 'norm_+ <∘r {?}', 'rewrite norm_+ {?}'], 'norm_+ {X}')
(['Join-cond ', 'Join-cond f', 'Join-cond  f', 'Join-cond f f'], 'Join-cond j')
(['aux {?} {?}', 'aux {?} {?} {?}', 'aux {?}', 'aux {?} {?} {?} {?}'], "aux (suc' m)")
(['\\lam y => {?}', '\\lam y p => {?}', '\\lam y x => {?}', '\\lam y f => {?}'], '\\lam y => {?}')
(['mulCoef {?}', 'mulCoef {?} {?}', 'mulCoef {?} {?} {?}', 'mulCoef_mulCoef {?}'], 'mulCoef-consistent {{?}}')
(['nucleus-meet ', 'nucleus-meet {e}', 'nucleus-meet {e} {?}', 'rewrite nucleus-meet {?}'], 'nucleus-meet ')
(['func-minus {f}', 'func-minus {f} {?}', 'func-minus {{?}}', 'func-minus {f} {?} {?}'], 'func-minus {f}')
(['rewrite p {?}', 'rewrite (Func-o {V}) {?}', '\\case \\elim p \\with {\n  | 0 => {?}\n}', 'rewrite (Func-o {G}) {?}'], 'rewriteI o-assoc {?}')
(['>0_Inv  {?} {?}', '>0_Inv  {?}', '>0_Inv ', '>0_Inv {?} {?}'], '>0_Inv  {?} q')
(['pow>=0  {?}', 'pow>=0  {?} {?}', 'pow>=0  a>=0', 'pow>=0 '], 'pow>=0  a>=0')
(['terms-equality {{?}} (x1 :: x0 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* var 2) :* :inverse (var 0))) idp', 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* var 2) :* :inverse (var 1) :* :inverse (var 0))) id', 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) :ide (var 0 :* (var 1 :* var 2) :* :inverse (var 1) :* :inverse (var 0))) id', 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) :ide (var 0 :* (var 1 :* var 2) :* :inverse (var 1) :* :inverse (var 0))) idp'], 'terms-equality {{?}} (x1 :: x0 :: x2 :: nil) :ide\n  (var 0 :* (var 1 :* (var 1 :* var 2) :* :inverse (var 2)) :* :inverse (var 1) :* (:inverse (var 1) :* :inverse (var 0)))\n  idp')
(['transport2 ((<=) ) {?} {?}', 'transport2 ((<=) _) {?} {?}', 'transport2 ((<) ) {?} {?}', 'transport2 ((<=) {M}) {?} {?}'], 'transport2 ((<=) {M}) {?} abMonoid {?}')
(['isSup {?}', 'isSup {?} {?}', 'isSup ', 'isSup {A} {?}'], 'isSup Aa0 Ab As')
(['\\lam So => {?}', '\\lam {S} So => {?}', '\\lam So So => {?}', '(\\lam So => {?}, \\lam So => {?})'], '\\lam {S} => {?}')
(['negative_+  {?} {?}', 'negative_+ ', 'negative_+  {?}', 'negative_+  {?} {?} {?}'], 'negative_+ {_} {zro} {negative z}')
(['substPres {?} {?}', 'substPres {?}', 'substPres {?} {?} {?}', 'substPres P'], "substPres (\\lam s => Given (\\Sigma (s' : predDomain  P) (s = s'))) (predicate P (\\lam j => var (j, idp))) (\\lam q => rewrite q.2 (l q.1)) (\\lam q => rewrite q.2 (l' q.1)) {?} th idp")
(['func-cont {e}', 'f {e}', 'func {e}', 'hinv {e}'], 'hinv {e}')
(['<=<-left {?} {?}', '<=<-left  {?} {?}', '<=<-left {?} {?} {?}', '<=<-left  {?} {?} {?}'], '<=<-left V<=<U p')
(['natCoef>=0 ', 'natCoef>=0  {?}', 'natCoef>=0  {?} {?}', 'rewrite natCoef>=0  {?}'], 'natCoef>=0 ')
(['terms-equality {{?}} (x6 :: x4 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp', 'terms-equality {{?}} (x6 :: x4 :: nil) (var 0 :* var 1) (var 0 :* var 0 :* var 1) idp', 'terms-equality {{?}} (x6 :: x4 :: nil) (var 0 :* var 1) (var 0 :* var 1 idp', 'terms-equality\n  {{?}} (x6 :: x4 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp'], 'terms-equality {{?}} (x6 :: x4 :: nil) (var 0 :* var 1) (var 0 :* var 1) idp')
(['isMono {?} {?}', 'isMono {{?}} {?}', 'isMono {{?}}', 'isMono {C} {?} {?}'], 'isMono {{?}} {?}')
(['=_<= {?}', '=_<= {?} {?}', '=_<= p', '=_<= {?} {?} {?}'], '=_<= {?}')
(['Loop {B} idp', 'Loop {B}', 'Loop {B} {?}', 'Loop {B} {?} idp'], 'Loop B')
(['*r_*q ', '*r_*q  {?}', '*r_*q {{?}}', '*r_*q {?}'], '*r_*q ')
(['diff-mono  {?} {?}', 'diff-mono  {?} {?} {?}', 'diff-mono  {?} p', 'diff-mono  {?} {?} {?} {?}'], 'diff-mono  {?} {?}')
