{"Context": ["U : Set X.E", "x : E {\\this}", "arg : x.1 = y.1", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => U (arg @ i)) x.2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["U : Set X.E", "X : Poset"], "Expected type": "Poset (Elem {X.E} U) {\n  | <= => \\lam (x : E {\\this}) (y : E {\\this}) => x.1 X.<= y.1\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n}", "Expression": "\\new Poset {\n  | E => Elem U\n  | <= => \\lam x y => x.1 <= y.1\n  | <=-refl => <=-refl\n  | <=-transitive => (<=\u2218)\n  | <=-antisymmetric => \\lam p q => ext (<=-antisymmetric p q)\n}", "Premises": ["| <=-refl {x : E} : x <= x", "| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "| \\infix 4 <= E E : \\Prop", "| E : \\Set", "\\type Elem {X : \\Type} (U : Set X) : \\Type => \\Sigma (x : X) (\\property (U x))", "| <=-transitive \\alias \\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z"]}
{"Context": ["X : LinearOrder", "U : Set X.E"], "Expected type": "LinearOrder (Elem {X.E} U) {\n  | < => \\lam (x : E) (y : E) => x.1 X.< y.1\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n  | <-comparison => {?hidden}\n  | <-connectedness => {?hidden}\n}", "Expression": "\\new LinearOrder {\n  | E => Elem U\n  | StrictPoset => ElemStrictPoset U\n  | <-comparison => \\lam y p => <-comparison y.1 p\n  | <-connectedness => \\lam p q => ext (<-connectedness p q)\n}", "Premises": ["| <-comparison (y : E) {x z : E} (x < z) : x < y || y < z", "| \\infix 4 < E E : \\Prop", "| <-transitive \\alias \\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z", "| E : \\Set", "| <-connectedness {x y : E} (Not (x < y)) (Not (y < x)) : x = y", "| <-irreflexive {x : E} : Not (x < x)", "\\type Elem {X : \\Type} (U : Set X) : \\Type => \\Sigma (x : X) (\\property (U x))"]}
{"Context": ["arg : (<=) = (<=)", "null : \\Set", "null : Poset _x", "null : Poset _x"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : _x} -> (@) arg i x x) <=-refl <=-refl", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| <=-refl {x : E} : x <= x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["arg : (<=) = (<=)", "null : \\Set", "null : Poset _x", "null : Poset _x"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : _x} -> (@) arg i x y -> (@) arg i y z -> (@) arg i x z) (<=\u2218) (<=\u2218)", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["arg : (<=) = (<=)", "null : \\Set", "null : Poset _x", "null : Poset _x"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : _x} -> (@) arg i x y -> (@) arg i y x -> x = y) <=-antisymmetric <=-antisymmetric", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["e : Iso", "h1 : func {transport {Poset} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat Poset ", "q : \\new Poset (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n} = \\new Poset (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> x <= y -> (@) h1 i x <= (@) h1 i y)\n  (func-<= {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-<= {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["null : \\Set", "null : StrictPoset _x", "null : StrictPoset _x", "arg : (<) = (<)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : _x} -> Not ((@) arg i x x)) <-irreflexive <-irreflexive", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Not (A : \\Type) : \\Prop => A -> Empty", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| <-irreflexive {x : E} : Not (x < x)"]}
{"Context": ["null : \\Set", "null : StrictPoset _x", "null : StrictPoset _x", "arg : (<) = (<)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : _x} -> (@) arg i x y -> (@) arg i y z -> (@) arg i x z) (<\u2218) (<\u2218)", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["q : \\new StrictPoset (E {e.dom}) {\n  | < => (<) {e.dom}\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n} = \\new StrictPoset (E {e.cod}) {\n  | < => (<) {e.cod}\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n}", "this : Cat StrictPoset ", "e : Iso", "h1 : func {transport {StrictPoset} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> x < y -> (@) h1 i x < (@) h1 i y)\n  (func-< {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-< {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| func-< {x y : E {Dom}} (x < y) : func x < func y", "| id (X : Ob) : Hom X X", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["S1 : Dec A", "S2 : Dec A", "A : \\Set", "h1 : (S1.<) = (S2.<)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Not (A : \\Type) : \\Prop => A -> Empty", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| <-irreflexive {x : E} : Not (x < x)"]}
{"Context": ["S1 : Dec A", "S2 : Dec A", "A : \\Set", "h1 : (S1.<) = (S2.<)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S1 : Dec A", "S2 : Dec A", "A : \\Set", "h1 : (S1.<) = (S2.<)", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "h2 : (S1.\u2227) = (S2.\u2227)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= x) S1.meet-left S2.meet-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| meet-left {x y : E} : x \u2227 y <= x", "\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S1 : Dec A", "S2 : Dec A", "A : \\Set", "h1 : (S1.<) = (S2.<)", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= x) S1.meet-left S2.meet-left", "h2 : (S1.\u2227) = (S2.\u2227)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= y) S1.meet-right S2.meet-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)", "| meet-right {x y : E} : x \u2227 y <= y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S1 : Dec A", "S2 : Dec A", "A : \\Set", "h1 : (S1.<) = (S2.<)", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= x) S1.meet-left S2.meet-left", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= y) S1.meet-right S2.meet-right", "h2 : (S1.\u2227) = (S2.\u2227)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : A} -> z <= x -> z <= y -> z <= (@) h2 i x y) S1.meet-univ S2.meet-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y", "\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S1 : Dec A", "S2 : Dec A", "A : \\Set", "h3 : (S1.\u2228) = (S2.\u2228)", "h1 : (S1.<) = (S2.<)", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= x) S1.meet-left S2.meet-left", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= y) S1.meet-right S2.meet-right", "h2 : (S1.\u2227) = (S2.\u2227)", "h2 : Path (\\lam (i : I) => \\Pi {x y z : A} -> z <= x -> z <= y -> z <= (@) h2 i x y) S1.meet-univ S2.meet-univ"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> x <= (@) h3 i x y) S1.join-left S2.join-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h3 : Path (\\lam (i : I) => \\Pi {x y : A} -> x <= (@) h3 i x y) S1.join-left S2.join-left", "S1 : Dec A", "h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S2 : Dec A", "A : \\Set", "h3 : (S1.\u2228) = (S2.\u2228)", "h1 : (S1.<) = (S2.<)", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= x) S1.meet-left S2.meet-left", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= y) S1.meet-right S2.meet-right", "h2 : (S1.\u2227) = (S2.\u2227)", "h2 : Path (\\lam (i : I) => \\Pi {x y z : A} -> z <= x -> z <= y -> z <= (@) h2 i x y) S1.meet-univ S2.meet-univ"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> y <= (@) h4 i x y) S1.join-right S2.join-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| join-right {x y : E} : y <= x \u2228 y", "\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["S1 : Dec A", "h3 : (S1.\u2228) = (S2.\u2228)", "h1 : (S1.<) = (S2.<)", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= y) S1.meet-right S2.meet-right", "h3 : Path (\\lam (i : I) => \\Pi {x y : A} -> x <= (@) h3 i x y) S1.join-left S2.join-left", "h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S2 : Dec A", "A : \\Set", "h3 : Path (\\lam (i : I) => \\Pi {x y : A} -> y <= (@) h4 i x y) S1.join-right S2.join-right", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)", "h2 : Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h2 i x y <= x) S1.meet-left S2.meet-left", "h2 : (S1.\u2227) = (S2.\u2227)", "h2 : Path (\\lam (i : I) => \\Pi {x y z : A} -> z <= x -> z <= y -> z <= (@) h2 i x y) S1.meet-univ S2.meet-univ"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : A} -> x <= z -> y <= z -> (@) h4 i x y <= z) S1.join-univ S2.join-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z", "\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["S1 : Dec A", "h4 : (S1.#) = (S2.#)", "S2 : Dec A", "A : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h4 i x x)) S1.#-irreflexive S2.#-irreflexive", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Not (A : \\Type) : \\Prop => A -> Empty", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| #-irreflexive {x : E} : Not (x # x)"]}
{"Context": ["S1 : Dec A", "h4 : (S1.#) = (S2.#)", "S2 : Dec A", "A : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> (@) h4 i x y -> (@) h4 i y x) S1.#-symmetric S2.#-symmetric", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| #-symmetric {x y : E} (x # y) : y # x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["S1 : Dec A", "h4 : (S1.#) = (S2.#)", "S2 : Dec A", "A : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi (x y z : A) -> (@) h4 i x z -> (@) h4 i x y || (@) h4 i y z) S1.#-comparison S2.#-comparison", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| #-comparison (x y z : E) (x # z) : x # y || y # z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["S1 : Dec A", "h4 : (S1.#) = (S2.#)", "S2 : Dec A", "A : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> Not ((@) h4 i x y) -> x = y) S1.tightness S2.tightness", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| tightness {x y : E} (Not (x # y)) : x = y", "\\func Not (A : \\Type) : \\Prop => A -> Empty", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : Dec A", "S2 : Dec A", "A : \\Set"], "Expected type": "S1.decideEq = S2.decideEq", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\field decideEq (x y : E) : Dec (x = y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : Dec A", "h4 : (S1.#) = (S2.#)", "S2 : Dec A", "A : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A} -> x /= y -> (@) h4 i x y) S1.nonEqualApart S2.nonEqualApart", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nonEqualApart {x y : E} (x /= y) : x # y", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : Path (\\lam (i : I) => \\Pi {x : A} -> Not ((@) h1 i x x)) S1.<-irreflexive S2.<-irreflexive", "S1 : Dec A", "S2 : Dec A", "A : \\Set", "h1 : (S1.<) = (S2.<)", "h1 : Path (\\lam (i : I) => \\Pi {x y z : A} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<\u2218) (S2.<\u2218)"], "Expected type": "Path (\\lam (i : I) => \\Pi (x y : A) -> Tri {\\new StrictPoset A {\n  | < => h3 @ i\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n}} x y) S1.trichotomy S2.trichotomy", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Tri \\hlevels  {A : StrictPoset} (_ _ : A.E) \n  | less (a A.< a')\n  | equals (a = a')\n  | greater (a A.> a')", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\field trichotomy (x y : E) : Tri x y"]}
{"Context": ["x : Ob {D {\\this}}", "this : Limit ", "c : B {\\this}", "h1 : coneMap = c.coneMap", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob {J {\\this}}} -> \\Pi (h : Hom {J {\\this}} j j') -> Func {G {\\this}} {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {\\this} (sec {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| J : Precat", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| sec B : A"]}
{"Context": ["P : Poset", "S : P.E -> \\Prop"], "Expected type": "Poset (\\Sigma (x : P.E) (S x)) {\n  | <= => \\lam (x : E {\\this}) (y : E {\\this}) => x.1 P.<= y.1\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n}", "Expression": "\\new Poset {\n  | E => \\Sigma (x : P) (S x)\n  | <= => \\lam x y => x.1 <= y.1\n  | <=-refl => <=-refl\n  | <=-transitive => (<=\u2218)\n  | <=-antisymmetric => \\lam p q => ext (<=-antisymmetric p q)\n}", "Premises": ["| <=-refl {x : E} : x <= x", "| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "| \\infix 4 <= E E : \\Prop", "| E : \\Set", "| <=-transitive \\alias \\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z"]}
{"Context": ["arg : x.1 = y.1", "x : E {\\this}", "R : HeytingAlebra", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => neg {R} (neg {R} (arg @ i)) R.<= arg @ i) x.2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func neg \\hlevels  {this : HeytingAlebra} (x : E) : E => x --> bottom", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["n/=0 : n /= 0", "na=0 : n *n a = zro", "n : Nat", "this : SeparatedPreBanachSpace", "a : E"], "Expected type": "a = zro", "Expression": "norm-ext  {?}", "Premises": ["| norm E : ExUpperReal", "| norm-ext {x : E} (norm x = zro) : x = zro", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : TopAbGroup", "X : TopAbGroup", "this : TopAbGroup (\\Sigma X.E Y.E) ", "x : E {\\this}"], "Expected type": "zro {\\this} + x = x", "Expression": "ext (zro-left, zro-left)", "Premises": ["| \\infixl 6 + E E : E", "| zro-left {x : E} : zro + x = x", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : TopAbGroup", "X : TopAbGroup", "this : TopAbGroup (\\Sigma X.E Y.E) ", "y : E {\\this}", "x : E {\\this}", "z : E {\\this}"], "Expected type": "x + y + z = x + (y + z)", "Expression": "ext (+-assoc, +-assoc)", "Premises": ["| \\infixl 6 + E E : E", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : TopAbGroup", "x : E {\\this}", "X : TopAbGroup", "this : TopAbGroup (\\Sigma X.E Y.E) "], "Expected type": "negative {\\this} x + x = zro {\\this}", "Expression": "ext (negative-left, negative-left)", "Premises": ["| negative-left {x : E} : negative x + x = zro", "| \\infixl 6 + E E : E", "| negative E : E", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : TopAbGroup", "y : E {\\this}", "x : E {\\this}", "X : TopAbGroup", "this : TopAbGroup (\\Sigma X.E Y.E) "], "Expected type": "x + y = y + x", "Expression": "ext (+-comm, +-comm)", "Premises": ["| +-comm {x y : E} : x + y = y + x", "| \\infixl 6 + E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "this : StoneC*Algebra (\\Sigma Real A.E) ", "y : E {\\this}", "A : StoneC*PseudoAlgebra"], "Expected type": "x * y = y * x", "Expression": "ext (*-comm, abGroup $ toZero {A} (*-comm {A}))", "Premises": ["| \\infixl 7 * E E : E", "\\lemma toZero \\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ", "\\lemma *-comm {x y : Real} : x * y = y * x ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *-comm {x y : E} : x * y = y * x"]}
{"Context": ["this : StoneC*Algebra (\\Sigma Real A.E) ", "p : norm {\\this} x = zro", "A : StoneC*PseudoAlgebra", "x : E {\\this}"], "Expected type": "x.1 = zro", "Expression": "abs_zro-ext {RealAbGroup} {?}", "Premises": ["\\func abs \\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| zro : E", "\\lemma abs_zro-ext \\hlevels  {this : LatticeAbGroup} {x : E} (_ : abs x = zro) : x = zro "]}
{"Context": ["A : StoneC*PseudoAlgebra", "a : E"], "Expected type": "negative (zro, a) = func {unit-algebra {RealField} {toRealAlgebra {A}}} (negative a)", "Expression": "ext (negative_zro {RealAbGroup}, idp)", "Premises": ["\\lemma negative_zro \\hlevels  {this : AddGroup} : negative zro = zro ", "| negative E : E", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func toRealAlgebra {this1 : RealBanachPseudoAlgebra} : PseudoAlgebra RealField E {\n  | zro => zro\n  | + => (+)\n  | negative => negative\n  | *c => (*r)\n  | * => (*)\n} => \\new PseudoAlgebra {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | *c-comm-left => {?hidden}\n  | *c-comm-right => {?hidden}\n}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| zro : E", "\\func unit-algebra \\hlevels  {R : CRing} {A : PseudoAlgebra R} : AddGroupHom A (UnitAlgebra R A) {\n  | func => \\lam (x : E {Dom {\\this}}) => (R.zro, x)\n} => \\new AddGroupHom {\n  | func-+ => {?hidden}\n}"]}
{"Context": ["x : E {\\this}", "f : X -> Y.E", "y : E {\\this}", "Y : ExMetricSpace", "p : dist {\\this} x y = zro"], "Expected type": "f x = f y", "Expression": "dist-ext p", "Premises": ["| dist-ext {x y : E} (dist x y = zro) : x = y"]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h1 i x x) S1.<=-refl S2.<=-refl", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| <=-refl {x : E} : x <= x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h1 i x y -> (@) h1 i y z -> (@) h1 i x z) (S1.<=\u2218) (S2.<=\u2218)", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X} -> (@) h1 i x y -> (@) h1 i y x -> x = y) S1.<=-antisymmetric S2.<=-antisymmetric", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "h2 : (S1.\u2227) = (S2.\u2227)", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X} -> (@) h1 i ((@) h2 i x y) x) S1.meet-left S2.meet-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| meet-left {x y : E} : x \u2227 y <= x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "h2 : (S1.\u2227) = (S2.\u2227)", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X} -> (@) h1 i ((@) h2 i x y) y) S1.meet-right S2.meet-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| meet-right {x y : E} : x \u2227 y <= y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "h2 : (S1.\u2227) = (S2.\u2227)", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h1 i z x -> (@) h1 i z y -> (@) h1 i z ((@) h2 i x y)) S1.meet-univ S2.meet-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X", "h3 : S1.top = S2.top", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h1 i x (h3 @ i)) S1.top-univ S2.top-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top-univ {x : E} : x <= top", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "h4 : S1.Join = S2.Join", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi (j : J) -> \\Pi {f : J -> X} -> (@) h1 i (f j) ((@) h4 i {J} f)) S1.Join-cond\n  S2.Join-cond", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Join-cond {J : \\Set} (j : J) {f : J -> E} : f j <= Join {J} f", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "h4 : S1.Join = S2.Join", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> X} -> \\Pi {e : X} -> (\\Pi (j : J) -> (@) h1 i (f j) e) -> (@) h1 i ((@) h4 i {J} f) e)\n  S1.Join-univ S2.Join-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Join-univ {J : \\Set} {f : J -> E} {e : E} (\\Pi (j : J) -> f j <= e) : Join {J} f <= e"]}
{"Context": ["X : \\Set", "S2 : PreuniformLocale X", "h2 : (S1.\u2227) = (S2.\u2227)", "h4 : S1.Join = S2.Join", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> X} ->\n  \\Pi {e : X} -> (@) h1 i ((@) h2 i e ((@) h4 i {J} f)) ((@) h4 i {J} (\\lam (j : J) => (@) h2 i e (f j))))\n  S1.Join-ldistr>= S2.Join-ldistr>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Join-ldistr>= {J : \\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\lam (j : J) => e \u2227 f j)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "h5 : S1.isUniform = S2.isUniform", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : X -> \\Prop} -> \\Pi {x y : X} -> (@) h5 i U -> U y -> (@) h1 i x y -> U x) S1.isDownset\n  S2.isDownset", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| isDownset {U : E -> \\Prop} {x y : E} (isUniform U) (U y) (x <= y) : U x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h5 : S1.isUniform = S2.isUniform", "X : \\Set", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X"], "Expected type": "Path (\\lam (i : I) => (@) h5 i (\\lam (_ : X) => \\Sigma)) S1.top-uniform S2.top-uniform", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top-uniform : isUniform (\\lam (_ : E) => \\Sigma)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "h5 : S1.isUniform = S2.isUniform", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X"], "Expected type": "Path (\\lam (i : I) => \\Pi {U V : X -> \\Prop} -> (@) h5 i U -> (@) h5 i V -> (@) h5 i (\\lam (x : X) => \\Sigma (U x) (V x)))\n  S1.meet-uniform S2.meet-uniform", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| meet-uniform {U V : E -> \\Prop} (isUniform U) (isUniform V) : isUniform (\\lam (x : E) => \\Sigma (U x) (V x))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["X : \\Set", "h5 : S1.isUniform = S2.isUniform", "S2 : PreuniformLocale X", "S1 : PreuniformLocale X", "h1 : (S1.<=) = (S2.<=)"], "Expected type": "Path (\\lam (i : I) => \\Pi {U V : X -> \\Prop} ->\n  (@) h5 i U -> (\\Pi {x : X} -> U x -> V x) -> (\\Pi {x y : X} -> V y -> (@) h1 i x y -> V x) -> (@) h5 i V) S1.<=-uniform\n  S2.<=-uniform", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| <=-uniform {U V : E -> \\Prop} (isUniform U) (\\Pi {x : E} -> U x -> V x) (\\Pi {x y : E} -> V y -> x <= y -> V x) : isUniform V", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => (@) h1 i (top {e.dom}) = top {e.cod})\n  (func-top {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-top {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "| func-top : func (top {Dom}) = top {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => top {e.cod} <= (@) h1 i (top {e.dom}))\n  (func-top>= {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-top>= {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| \\infix 4 <= E E : \\Prop", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "| func-top>= : top {Cod} <= func (top {Dom})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> (@) h1 i (x \u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-meet {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x \u2227 y))\n  (func-meet>= {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-meet>= {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> E {e.dom}} -> (@) h1 i (Join {e.dom} {J} f) = Join {e.cod} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-Join {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType"]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> E {e.dom}} -> (@) h1 i (Join {e.dom} {J} f) <= Join {e.cod} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-Join>= {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["h1 : func {transport {PreuniformLocale} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PreuniformLocale (E {e.dom}) {\n  | <= => (<=) {e.dom}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.dom}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.dom}\n  | top-univ => {?hidden}\n  | Join => Join {e.dom}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.dom}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n} = \\new PreuniformLocale (E {e.cod}) {\n  | <= => (<=) {e.cod}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => (\u2227) {e.cod}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top => top {e.cod}\n  | top-univ => {?hidden}\n  | Join => Join {e.cod}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isUniform => isUniform {e.cod}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n}", "e : Iso", "this : Cat PreuniformLocale "], "Expected type": "Path (\\lam (i : I) => \\Pi {U : E {e.dom} -> \\Prop} -> isUniform {e.dom} U ->\n  isUniform {e.cod} (\\lam (y : E {e.cod}) => TruncP (\\Sigma (x : E {e.dom}) (U x) (y <= (@) h1 i x))))\n  (func-uniform {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-uniform {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| \\infix 4 <= E E : \\Prop", "| Ob : \\hType", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| isUniform (E -> \\Prop) : \\Prop", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "| func-uniform {U : E {Dom} -> \\Prop} (isUniform {Dom} U) : isUniform {Cod} (\\lam (y : E {Cod}) => TruncP (\\Sigma (x : E {Dom}) (U x) (y <= func x)))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> x M.<= y -> (@) arg i x <= (@) arg i y) f.func-<= g.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => (@) arg i M.top = top) f.func-top g.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top : func (top {Dom}) = top {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => top <= (@) arg i M.top) f.func-top>= g.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top>= : top {Cod} <= func (top {Dom})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\type \\infix 4 <= \\hlevels  {P : FramePres} (U V : Opens P) : \\Prop => \\Pi {x : P.E} -> U.1 x -> V.1 x"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) arg i (x M.\u2227 y) = (@) arg i x \u2227 (@) arg i y) f.func-meet g.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) arg i x \u2227 (@) arg i y <= (@) arg i (x M.\u2227 y)) f.func-meet>= g.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> M.E} -> (@) arg i (M.Join {J} f) = Join {J} (\\lam (j : J) => (@) arg i (f j)))\n  f.func-Join g.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> M.E} -> (@) arg i (M.Join {J} f) <= Join {J} (\\lam (j : J) => (@) arg i (f j)))\n  f.func-Join>= g.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["M : UniformLocale", "f : UniformHom M (Completion L)", "arg : f.func = g.func", "L : UniformLocale", "g : UniformHom M (Completion L)"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : M.E -> \\Prop} -> M.isUniform U -> isUniform (\\lam (y : E) => TruncP (\\Sigma (x : M.E) (U x) (y <= (@) arg i x))))\n  f.func-uniform g.func-uniform", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| isUniform (E -> \\Prop) : \\Prop", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func-uniform {U : E {Dom} -> \\Prop} (isUniform {Dom} U) : isUniform {Cod} (\\lam (y : E {Cod}) => TruncP (\\Sigma (x : E {Dom}) (U x) (y <= func x)))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> x <= y -> (@) h1 i x L.<= (@) h1 i y) (func-<= {f \u2218 g}) (func-<= {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top = L.top) (func-top {f \u2218 g}) (func-top {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => L.top L.<= (@) h1 i top) (func-top>= {f \u2218 g}) (func-top>= {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x \u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y) (func-meet {f \u2218 g})\n  (func-meet {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i x L.\u2227 (@) h1 i y L.<= (@) h1 i (x \u2227 y)) (func-meet>= {f \u2218 g})\n  (func-meet>= {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E} -> (@) h1 i (Join {J} f) = L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {f \u2218 g}) (func-Join {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E} -> (@) h1 i (Join {J} f) L.<= L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {f \u2218 g}) (func-Join>= {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["g : UniformHom (Completion L) M ", "h1 : func {g \u2218 f} = func {completionLocale {L}}", "M : UniformLocale", "f : UniformEmbedding M L", "L : UniformLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : E -> \\Prop} -> isUniform U -> L.isUniform (\\lam (y : L.E) => TruncP (\\Sigma (x : E) (U x) (y L.<= (@) h1 i x))))\n  (func-uniform {f \u2218 g}) (func-uniform {completion {L}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| isUniform (E -> \\Prop) : \\Prop", "| \\infix 4 <= E E : \\Prop", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func-uniform {U : E {Dom} -> \\Prop} (isUniform {Dom} U) : isUniform {Cod} (\\lam (y : E {Cod}) => TruncP (\\Sigma (x : E {Dom}) (U x) (y <= func x)))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["M : UniformLocale", "L : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> x <= y -> (@) h1 i x L.<= (@) h1 i y)\n  (func-<= {completion {L} \u2218 completion-functor {L} {M} f}) (func-<= {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| \\infix 4 <= E E : \\Prop", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["L : UniformLocale", "M : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top = L.top) (func-top {completion {L} \u2218 completion-functor {L} {M} f})\n  (func-top {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["L : UniformLocale", "M : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => L.top L.<= (@) h1 i top) (func-top>= {completion {L} \u2218 completion-functor {L} {M} f})\n  (func-top>= {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["M : UniformLocale", "L : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x \u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y)\n  (func-meet {completion {L} \u2218 completion-functor {L} {M} f}) (func-meet {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["M : UniformLocale", "L : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i x L.\u2227 (@) h1 i y L.<= (@) h1 i (x \u2227 y))\n  (func-meet>= {completion {L} \u2218 completion-functor {L} {M} f}) (func-meet>= {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["M : UniformLocale", "L : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E} -> (@) h1 i (Join {J} f) = L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {completion {L} \u2218 completion-functor {L} {M} f}) (func-Join {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["M : UniformLocale", "L : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E} -> (@) h1 i (Join {J} f) L.<= L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {completion {L} \u2218 completion-functor {L} {M} f}) (func-Join>= {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["M : UniformLocale", "L : UniformLocale", "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}", "f : UniformHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : E -> \\Prop} -> isUniform U -> L.isUniform (\\lam (y : L.E) => TruncP (\\Sigma (x : E) (U x) (y L.<= (@) h1 i x))))\n  (func-uniform {completion {L} \u2218 completion-functor {L} {M} f}) (func-uniform {f \u2218 completion {M}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}", "| isUniform (E -> \\Prop) : \\Prop", "| \\infix 4 <= E E : \\Prop", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func-uniform {U : E {Dom} -> \\Prop} (isUniform {Dom} U) : isUniform {Cod} (\\lam (y : E {Cod}) => TruncP (\\Sigma (x : E {Dom}) (U x) (y <= func x)))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : Interval Q", "y : Interval Q"], "Expected type": "x = conj {{?error}} x y", "Expression": "ext (inv (join-comm *> join_<= p.1), inv (meet_<= p.2))", "Premises": ["| conj E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : Interval Q", "y : Interval Q", "Q : Dec"], "Expected type": "Cover {{?error}} x {\\Sigma} (\\lam (_ : \\Sigma) => y)", "Expression": "cover-proj2 {_} {_} {_} {_} {x} {y} (ext (inv (join-comm *> join_<= p.1), inv (meet_<= p.2))) {?} idp", "Premises": ["\\lemma cover-proj2 \\hlevels  {P : FramePres} {x : P.E} {J : \\Set} {g : J -> P.E} {a b : P.E} (_ : x = P.conj a b) (j : J) (_ : g j = b) :\n  Cover {P} x {J} g ", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))"]}
{"Context": ["this : RealPreBanachAlgebra E ", "h1 : (\\lam (r : Rat) => TruncP (\\Sigma (r1 : Rat) (r1 StrictPoset.< r) (zro StrictPoset.< r1) (zro {\\this} <= r1 *q ide) (negative (zro {\\this}) <= r1 *q ide))) = (OrderedAddGroup.<) zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {norm {\\this} (zro {\\this})})\n  (U-closed {zro})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "| norm E : ExUpperReal", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["this : RealPreBanachAlgebra E ", "h1 : (\\lam (r : Rat) => TruncP (\\Sigma (r1 : Rat) (r1 StrictPoset.< r) (zro StrictPoset.< r1) (zro {\\this} <= r1 *q ide) (negative (zro {\\this}) <= r1 *q ide))) = (OrderedAddGroup.<) zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q)))\n  (U-rounded {norm {\\this} (zro {\\this})}) (U-rounded {zro})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "| norm E : ExUpperReal", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : (\\lam (r : Rat) => TruncP (\\Sigma (r1 : Rat) (r1 < r) (zro < r1) (negative {\\this} x <= r1 *q ide) (negative (negative {\\this} x) <= r1 *q ide))) = (\\lam (r : Rat) => TruncP (\\Sigma (r1 : Rat) (r1 < r) (zro < r1) (x <= r1 *q ide) (negative x <= r1 *q ide)))", "x : E {\\this}", "this : RealPreBanachAlgebra E "], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {norm {\\this} (negative {\\this} x)})\n  (U-closed {norm {\\this} x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "| norm E : ExUpperReal", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : (\\lam (r : Rat) => TruncP (\\Sigma (r1 : Rat) (r1 < r) (zro < r1) (negative {\\this} x <= r1 *q ide) (negative (negative {\\this} x) <= r1 *q ide))) = (\\lam (r : Rat) => TruncP (\\Sigma (r1 : Rat) (r1 < r) (zro < r1) (x <= r1 *q ide) (negative x <= r1 *q ide)))", "x : E {\\this}", "this : RealPreBanachAlgebra E "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q)))\n  (U-rounded {norm {\\this} (negative {\\this} x)}) (U-rounded {norm {\\this} x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "| norm E : ExUpperReal", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["aa=y-x : a * a = y - x", "b : E", "a : E", "this : StoneC*Algebra", "y : E", "x : E", "bb=x-y : b * b = x - y"], "Expected type": "a * a = zro", "Expression": "norm-ext  {?}", "Premises": ["| norm E : ExUpperReal", "| norm-ext {x : E} (norm x = zro) : x = zro", "| zro : E", "| \\infixl 7 * E E : E", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y"]}
{"Context": ["q : Rat", "this : StoneC*Algebra", "x : E", "q<=0 : q <= zro", "|x|<=q : norm x <= fromRat q"], "Expected type": "x = zro", "Expression": "norm-ext  {?}", "Premises": ["| norm E : ExUpperReal", "| norm-ext {x : E} (norm x = zro) : x = zro", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : FrameHom this (restrict a) ", "this : Locale", "a : E"], "Expected type": "func {\\this} (top {Dom {\\this}}) = top {Cod {\\this}}", "Expression": "ext (top-left )", "Premises": ["| top : E", "| Dom : BaseSet", "\\lemma top-left \\hlevels  {this : TopMeetSemilattice} {x : E} : top \u2227 x = x ", "| Cod : BaseSet", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : FrameHom this (restrict a) ", "this : Locale", "x : E {Dom {\\this}}", "a : E", "y : E {Dom {\\this}}"], "Expected type": "func {\\this} (x \u2227 y) = func {\\this} x \u2227 func {\\this} y", "Expression": "ext equation", "Premises": ["| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : FrameHom this (restrict a) ", "this : Locale", "f : J -> E {Dom {\\this}}", "a : E", "J : \\Set"], "Expected type": "func {\\this} (Join {Dom {\\this}} {J} f) = Join {Cod {\\this}} {J} (\\lam (j : J) => func {\\this} (f j))", "Expression": "ext (Join-rdistr )", "Premises": ["| Dom : BaseSet", "| Join {J : \\Set} (J -> E) : E", "| Cod : BaseSet", "\\lemma Join-rdistr \\hlevels  {this : Locale} {J : \\Set} {f : J -> E} {e : E} : Join {J} f \u2227 e = Join {J} (\\lam (j : J) => f j \u2227 e) ", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : (ret {\\this} (func {factor} x)).1 = x.1", "this : QEquiv ", "this : FrameHom", "x : A {\\this}"], "Expected type": "Path (\\lam (i : I) => nucleus {image} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| ret B : A", "| \\infix 4 <= E E : \\Prop", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : Nucleus", "y : E {\\this}", "arg : x.1 = y.1", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => nucleus (arg @ i) <= arg @ i) x.2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : FrameHom L locale ", "this : Nucleus", "arg : (func {\\this} (top {L})).1 = top.1"], "Expected type": "Path (\\lam (i : I) => nucleus (arg @ i) <= arg @ i) (func {\\this} (top {Dom {\\this}})).2 (top {Cod {\\this}}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| top : E", "| Dom : BaseSet", "| \\infix 4 <= E E : \\Prop", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["this : FrameHom L locale ", "y : E {Dom {\\this}}", "arg : nucleus (x \u2227 y) = nucleus x \u2227 nucleus y", "x : E {Dom {\\this}}", "this : Nucleus"], "Expected type": "Path (\\lam (i : I) => nucleus (arg @ i) <= arg @ i) (func {\\this} (x \u2227 y)).2 (func {\\this} x \u2227 func {\\this} y).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["arg : (func {map} y.1).1 = y.1", "this : Nucleus", "y : Subtype"], "Expected type": "Path (\\lam (i : I) => nucleus (arg @ i) <= arg @ i) (func {map} y.1).2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["this : Nucleus", "y : Subtype"], "Expected type": "TruncP (\\Sigma (x : E {L}) (func {map} x = y))", "Expression": "inP (y.1, ext $ <=-antisymmetric y.2 (nucleus-unit ))", "Premises": ["| nucleus (E {L}) : E {L}", "| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "| \\infix 4 <= E E : \\Prop", "| func (E {Dom}) : E {Cod}", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| nucleus-unit {x : E {L}} : x <= nucleus x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| L : Locale", "inP A", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "L : Locale", "h1 : x.nucleus = y.nucleus"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> (@) h1 i (x L.\u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y) x.nucleus-meet y.nucleus-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| nucleus-meet {x y : E {L}} : nucleus (x \u2227 y) = nucleus x \u2227 nucleus y", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "L : Locale", "h1 : x.nucleus = y.nucleus"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> (@) h1 i x L.\u2227 (@) h1 i y L.<= (@) h1 i (x L.\u2227 y)) x.nucleus-meet>= y.nucleus-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "L : Locale", "h1 : x.nucleus = y.nucleus"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> x L.<= y -> (@) h1 i x L.<= (@) h1 i y) x.nucleus-<= y.nucleus-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "L : Locale", "h1 : x.nucleus = y.nucleus"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : L.E} -> x L.<= (@) h1 i x) x.nucleus-unit y.nucleus-unit", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| nucleus-unit {x : E {L}} : x <= nucleus x"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "L : Locale", "h1 : x.nucleus = y.nucleus"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : L.E} -> (@) h1 i ((@) h1 i x) L.<= (@) h1 i x) x.nucleus-join>= y.nucleus-join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| nucleus-join>= {x : E {L}} : nucleus (nucleus x) <= nucleus x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "L : Locale", "h1 : x.nucleus = y.nucleus"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : L.E} -> (@) h1 i ((@) h1 i x) = (@) h1 i x) x.nucleus-join y.nucleus-join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus-join {x : E {L}} : nucleus (nucleus x) = nucleus x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["j' : Nucleus ", "L : Locale", "y : Subtype {j'}", "j : Nucleus ", "arg : (func {<=-map {L} j j' j<=j'} (y.1, j<=j' {y.1} L.<=\u2218 y.2)).1 = y.1", "j<=j' : j <= j'"], "Expected type": "Path (\\lam (i : I) => j'.nucleus (arg @ i) L.<= arg @ i) (func {<=-map {L1} j j' j<=j'} (y.1, j<=j' {y.1} L.<=\u2218 y.2)).2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| L : Locale", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["j' : Nucleus ", "L : Locale", "y : Subtype {j'}", "j : Nucleus ", "j<=j' : j <= j'"], "Expected type": "TruncP (\\Sigma (x : Subtype {j}) (func {<=-map {L} j j' j<=j'} x = y))", "Expression": "inP ((y.1, j<=j' <=\u2218 y.2), ext $ <=-antisymmetric y.2 nucleus-unit)", "Premises": ["| nucleus (E {L}) : E {L}", "| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infix 4 <= E E : \\Prop", "| func (E {Dom}) : E {Cod}", "| nucleus-unit {x : E {L}} : x <= nucleus x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type Subtype \\hlevels  {this : Nucleus} : \\Set => \\Sigma (x : E {L}) (nucleus x <= x)", "| L : Locale", "inP A", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E {j.L}", "arg : j.nucleus (nucleus {wclosed-image {map {j}}} x) = j.nucleus x", "j : Nucleus"], "Expected type": "Path (\\lam (i : I) => j.nucleus (arg @ i) <= arg @ i)\n  (func {<=-map {j.L} (wclosed-image {map {j}}) (\\new j {}) (wclosure_<= {j})} (func {map {wclosed-image {map {j}}}} x)).2\n  (func {map {j}} x).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| L : Locale", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\lemma wclosure_<= {j : Nucleus} : wclosed-image {map {j}} <= \\new j {} "]}
{"Context": ["j : Nucleus ", "k : Nucleus ", "L : Locale", "arg : (func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})} x).1 = (func {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {j} {k})} x).1", "x : L.E"], "Expected type": "Path (\\lam (i : I) => nucleus {j \u2228 k} (arg @ i) L.<= arg @ i) (func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})} x).2\n  (func {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {j} {k})} x).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "| func (E {Dom}) : E {Cod}", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| join-right {x y : E} : y <= x \u2228 y", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> x L.<= y -> (@) h1 i x <= (@) h1 i y)\n  (func-<= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-<= {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| join-right {x y : E} : y <= x \u2228 y", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => (@) h1 i L.top = top) (func-top {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-top {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| top : E", "| join-right {x y : E} : y <= x \u2228 y", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => top.1 L.<= ((@) h1 i L.top).1) (func-top>= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-top>= {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| top : E", "| join-right {x y : E} : y <= x \u2228 y", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> (@) h1 i (x L.\u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-meet {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| join-right {x y : E} : y <= x \u2228 y", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x L.\u2227 y))\n  (func-meet>= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-meet>= {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| join-right {x y : E} : y <= x \u2228 y", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> L.E} -> (@) h1 i (L.Join {J} f) = Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-Join {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| join-right {x y : E} : y <= x \u2228 y", "| Join {J : \\Set} (J -> E) : E", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["j : Nucleus ", "h1 : (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\lam (e : L.E) => (\n  \\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\n          {L.Meet {\\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\n            (\\lam (p : \\Sigma (n : Nucleus {L1}) (\\Pi (j1 : Bool) -> \\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\n  \\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))", "k : Nucleus ", "L : Locale"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> L.E} -> (@) h1 i (L.Join {J} f) <= Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-Join>= {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| join-right {x y : E} : y <= x \u2228 y", "| Join {J : \\Set} (J -> E) : E", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> x L.<= y -> (@) h1 i x sub.<= (@) h1 i y)\n  (func-<= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => (@) h1 i L.top = sub.top)\n  (func-top {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| top : E", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => sub.top sub.<= (@) h1 i L.top)\n  (func-top>= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| top : E", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> (@) h1 i (x L.\u2227 y) = (@) h1 i x sub.\u2227 (@) h1 i y)\n  (func-meet {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : L.E} -> (@) h1 i x sub.\u2227 (@) h1 i y sub.<= (@) h1 i (x L.\u2227 y))\n  (func-meet>= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> L.E} -> (@) h1 i (L.Join {J} f) = sub.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| Join {J : \\Set} (J -> E) : E", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["j : Nucleus ", "f : Hom sub L", "sub : Ob", "jk<=f : j \u2228 k <= image {f}", "k : Nucleus ", "L : Locale", "h1 : func {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})} = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> L.E} -> (@) h1 i (L.Join {J} f) sub.<= sub.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k}) \u2218 (<=-map {L} (j \u2228 k) (image {f}) jk<=f \u2218 factor {f})})\n  f.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| Join {J : \\Set} (J -> E) : E", "| join-left {x y : E} : x <= x \u2228 y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {dom {\\this}}} -> x <= y -> (@) h1 i x <= (@) h1 i y) (func-<= {hinv {\\this} \u2218 f {\\this}})\n  (func-<= {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (top {dom {\\this}}) = top {dom {\\this}}) (func-top {hinv {\\this} \u2218 f {\\this}})\n  (func-top {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)", "f : FrameHom"], "Expected type": "Path (\\lam (i : I) => top {dom {\\this}} <= (@) h1 i (top {dom {\\this}})) (func-top>= {hinv {\\this} \u2218 f {\\this}})\n  (func-top>= {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {dom {\\this}}} -> (@) h1 i (x \u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {hinv {\\this} \u2218 f {\\this}}) (func-meet {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {dom {\\this}}} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x \u2227 y))\n  (func-meet>= {hinv {\\this} \u2218 f {\\this}}) (func-meet>= {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {dom {\\this}}} ->\n  (@) h1 i (Join {dom {\\this}} {J} f) = Join {dom {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {hinv {\\this} \u2218 f {\\this}}) (func-Join {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Dom}) => e.ret (e.f e1)) = (\\lam (e : E {f.Dom}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {dom {\\this}}} ->\n  (@) h1 i (Join {dom {\\this}} {J} f) <= Join {dom {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {hinv {\\this} \u2218 f {\\this}}) (func-Join>= {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {cod {\\this}}} -> x <= y -> (@) h1 i x <= (@) h1 i y) (func-<= {f {\\this} \u2218 hinv {\\this}})\n  (func-<= {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (top {cod {\\this}}) = top {cod {\\this}}) (func-top {f {\\this} \u2218 hinv {\\this}})\n  (func-top {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "f : FrameHom", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => top {cod {\\this}} <= (@) h1 i (top {cod {\\this}})) (func-top>= {f {\\this} \u2218 hinv {\\this}})\n  (func-top>= {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {cod {\\this}}} -> (@) h1 i (x \u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {f {\\this} \u2218 hinv {\\this}}) (func-meet {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {cod {\\this}}} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x \u2227 y))\n  (func-meet>= {f {\\this} \u2218 hinv {\\this}}) (func-meet>= {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {cod {\\this}}} ->\n  (@) h1 i (Join {cod {\\this}} {J} f) = Join {cod {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {f {\\this} \u2218 hinv {\\this}}) (func-Join {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Iso ", "h1 : (\\lam (e1 : E {f.Cod}) => e.f (e.ret e1)) = (\\lam (e : E {f.Cod}) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {cod {\\this}}} ->\n  (@) h1 i (Join {cod {\\this}} {J} f) <= Join {cod {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {f {\\this} \u2218 hinv {\\this}}) (func-Join>= {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["e : Iso", "h1 : func {transport {FramePres} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat FramePres ", "q : \\new FramePres (E {e.dom}) {\n  | conj => conj {e.dom}\n  | BasicCover => BasicCover {e.dom}\n} = \\new FramePres (E {e.cod}) {\n  | conj => conj {e.cod}\n  | BasicCover => BasicCover {e.cod}\n}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> (@) h1 i (conj {e.dom} x y) = conj {e.cod} ((@) h1 i x) ((@) h1 i y))\n  (func-conj {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-conj {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "| conj E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType"]}
{"Context": ["e : Iso", "h1 : func {transport {FramePres} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat FramePres ", "q : \\new FramePres (E {e.dom}) {\n  | conj => conj {e.dom}\n  | BasicCover => BasicCover {e.dom}\n} = \\new FramePres (E {e.cod}) {\n  | conj => conj {e.cod}\n  | BasicCover => BasicCover {e.cod}\n}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {x : E {e.dom}} -> \\Pi {f : J -> E {e.dom}} ->\n  BasicCover {e.dom} {J} x f -> BasicCover {e.cod} {J} ((@) h1 i x) (\\lam (j : J) => (@) h1 i (f j)))\n  (func-basicCover {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)})\n  (func-basicCover {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "| func-basicCover {J : \\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\lam (j : J) => func (f j))", "| BasicCover {J : \\Set} E (J -> E) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["e : Iso", "h1 : func {transport {FramePres} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat FramePres ", "q : \\new FramePres (E {e.dom}) {\n  | conj => conj {e.dom}\n  | BasicCover => BasicCover {e.dom}\n} = \\new FramePres (E {e.cod}) {\n  | conj => conj {e.cod}\n  | BasicCover => BasicCover {e.cod}\n}"], "Expected type": "Path (\\lam (i : I) => \\Pi {y : E {e.cod}} -> Cover {e.cod} y {E {e.dom}} (h1 @ i))\n  (func-image {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-image {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "| func-image {y : E {Cod}} : Cover {Cod} y {E {Dom}} func", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "h1 : x.1 = y.1", "P : FramePres"], "Expected type": "Path (\\lam (i : I) => \\Pi (x : P.E) -> SCover {P} x (h1 @ i) -> (@) h1 i x) x.2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func SCover \\hlevels  {this : FramePres} (x : E) (U : E -> \\Prop) : \\Prop \n  => Cover x {\\Sigma (x : E) (U x)} (\\lam (t : \\Sigma (x : E) (U x)) => t.1)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["P : FramePres", "L : Locale", "h1 : (\\lam (e : P.E) => Cover {P} e {\\Sigma (j : \\Sigma (b : L.E) (f.func b <= U)) (x : P.E) ((f.func j.1).1 x)}\n  (\\lam (p0 : \\Sigma (j : \\Sigma (b : L.E) (f.func b <= U)) (x : P.E) ((f.func j.1).1 x)) => p0.2)) = U.1", "f : FrameHom L (PresentedFrame P)", "U : E"], "Expected type": "Path (\\lam (i : I) => \\Pi (x : P.E) -> SCover {P} x (h1 @ i) -> (@) h1 i x)\n  (Join {\\Sigma (b : L.E) (f.func b <= U)} (\\lam (j : \\Sigma (b : L.E) (f.func b <= U)) => f.func j.1)).2 U.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func SCover \\hlevels  {this : FramePres} (x : E) (U : E -> \\Prop) : \\Prop \n  => Cover x {\\Sigma (x : E) (U x)} (\\lam (t : \\Sigma (x : E) (U x)) => t.1)", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\type \\infix 4 <= \\hlevels  {P : FramePres} (U V : Opens P) : \\Prop => \\Pi {x : P.E} -> U.1 x -> V.1 x", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["b : P.E", "a : P.E", "P : FramePres", "h1 : (\\lam (e : P.E) => Cover {P} e {\\Sigma (a1 b1 : P.E) ((embed {P} a).1 a1) ((embed {P} b).1 b1)}\n  (\\lam (t : \\Sigma (a1 b1 : P.E) ((embed {P} a).1 a1) ((embed {P} b).1 b1)) => P.conj t.1 t.2)) = (\\lam (e : P.E) => Cover {P} e {\\Sigma} (\\lam (_ : \\Sigma) => P.conj a b))"], "Expected type": "Path (\\lam (i : I) => \\Pi (x : P.E) -> SCover {P} x (h1 @ i) -> (@) h1 i x) (embed {P} a \u2227 embed {P} b).2\n  (embed {P} (conj {P} a b)).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func embed \\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\Sigma} (\\lam (_ : \\Sigma) => x)", "\\func SCover \\hlevels  {this : FramePres} (x : E) (U : E -> \\Prop) : \\Prop \n  => Cover x {\\Sigma (x : E) (U x)} (\\lam (t : \\Sigma (x : E) (U x)) => t.1)", "| conj E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> x <= y -> (@) h1 i x L.<= (@) h1 i y) f.func-<= g.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top = L.top) f.func-top g.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top : func (top {Dom}) = top {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => L.top L.<= (@) h1 i top) f.func-top>= g.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x \u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y) f.func-meet g.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i x L.\u2227 (@) h1 i y L.<= (@) h1 i (x \u2227 y)) f.func-meet>= g.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E} -> (@) h1 i (Join {J} f) = L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  f.func-Join g.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["g : FrameHom (PresentedFrame P) L", "P : FramePres", "L : Locale", "h1 : f.func = g.func", "f : FrameHom (PresentedFrame P) L"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E} -> (@) h1 i (Join {J} f) L.<= L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  f.func-Join>= g.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["h2 : S1.BasicCover = S2.BasicCover", "S1 : FrameUPres X", "X : \\Set", "S2 : FrameUPres X", "h3 : S1.unit = S2.unit"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i {\\Sigma} x (\\lam (_ : \\Sigma) => h3 @ i)) S1.isUnit S2.isUnit", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| isUnit {x : E} : BasicCover {\\Sigma} x (\\lam (_ : \\Sigma) => unit)"]}
{"Context": ["q : \\new FrameUPres (E {e.dom}) {\n  | conj => conj {e.dom}\n  | BasicCover => BasicCover {e.dom}\n  | unit => unit {e.dom}\n  | isUnit => {?hidden}\n} = \\new FrameUPres (E {e.cod}) {\n  | conj => conj {e.cod}\n  | BasicCover => BasicCover {e.cod}\n  | unit => unit {e.cod}\n  | isUnit => {?hidden}\n}", "e : Iso", "this : Cat FrameUPres ", "h1 : func {transport {FrameUPres} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (unit {e.dom}) = unit {e.cod})\n  (func-unit {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-unit {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-unit : func (unit {Dom}) = unit {Cod}", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f : Hom {C} dom cod", "| Ob : \\hType", "| unit : E"]}
{"Context": ["this : Limit ", "f : Hom {D {\\this}} z (apex {\\this})", "g : Hom {D {\\this}} z (apex {\\this})", "h1 : f.func = g.func", "z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h1 i (conj {apex {\\this}} x y) = z.conj ((@) h1 i x) ((@) h1 i y))\n  f.func-conj g.func-conj", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)", "| apex : Ob {D}", "| conj E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Limit ", "f : Hom {D {\\this}} z (apex {\\this})", "g : Hom {D {\\this}} z (apex {\\this})", "h1 : f.func = g.func", "z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {x : E {apex {\\this}}} -> \\Pi {f : J -> E {apex {\\this}}} ->\n  BasicCover {apex {\\this}} {J} x f -> z.BasicCover {J} ((@) h1 i x) (\\lam (j : J) => (@) h1 i (f j))) f.func-basicCover\n  g.func-basicCover", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| func-basicCover {J : \\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\lam (j : J) => func (f j))", "| BasicCover {J : \\Set} E (J -> E) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["this : Limit ", "f : Hom {D {\\this}} z (apex {\\this})", "g : Hom {D {\\this}} z (apex {\\this})", "h1 : f.func = g.func", "z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (unit {apex {\\this}}) = z.unit) f.func-unit g.func-unit", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-unit : func (unit {Dom}) = unit {Cod}", "| apex : Ob {D}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| unit : E"]}
{"Context": ["J : Precat", "this : CocompleteCat FrameUPres ", "G : Functor J this"], "Expected type": "Limit {Precat.op {J1}} {Precat.op} (Functor.op {G1}) (colimit-obj {J1} G1) {\n  | coneMap => colimitMap {J1} G1\n  | coneCoh => {?hidden}\n  | isLimit => {?hidden}\n  | limMap => colimit-univ {J1} G1\n  | limBeta => {?hidden}\n  | limUnique => {?hidden}\n}", "Expression": "\\new Limit {\n  | Cone => colimit-cone G\n  | limMap => colimit-univ G\n  | limBeta => \\lam c j => idp\n  | limUnique => \\lam p => exts (colimit-univ-eq G (\\lam {j} x => path (\\lam i => p j i x)))\n}", "Premises": ["\\func colimitMap {J : Precat} (G : Functor J FrameUPresCat) (j : J.Ob) : FrameUPresHom (G.F j) (colimit-obj {J} G) {\n  | func => finj {J} {G} {j}\n} => \\new FrameUPresHom {\n  | func-conj => {?hidden}\n  | func-basicCover => {?hidden}\n  | func-unit => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "\\lemma colimit-univ-eq {J : Precat} (G : Functor J FrameUPresCat) {Z : FrameUPres} {f g : FrameUPresHom (colimit-obj {J} G) Z}\n  (_ : \\Pi {j : J.Ob} -> \\Pi (x : E {G.F j}) -> f.func (finj {J} {G} {j} x) = g.func (finj {J} {G} {j} x))\n  (t : FTerm {J} G) : f.func t = g.func t ", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| G : Functor J D", "| B : \\Type", "| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex", "| limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| J : Precat", "| F (Ob {C}) : Ob {D}", "\\func colimit-univ {J : Precat} (G : Functor J FrameUPresCat) {Z : FrameUPres}\n  (c : Cone {Precat.op {J}} {Precat.op {FrameUPresCat}} (Functor.op {G}) Z) : FrameUPresHom (colimit-obj {J} G) Z {\n  | func => colimit-func {J} G {Z} c\n} => \\new FrameUPresHom {\n  | func-conj => {?hidden}\n  | func-basicCover => {?hidden}\n  | func-unit => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func colimit-cone {J1 : Precat} (G1 : Functor J1 FrameUPresCat) :\nCone {Precat.op {J1}} {Precat.op {FrameUPresCat}} (Functor.op {G1}) (colimit-obj {J1} G1) {\n  | coneMap => colimitMap {J1} G1\n} => \\new Cone {\n  | coneCoh => {?hidden}\n}", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j"]}
{"Context": ["h1 : (\\lam (e : E {G.F j'}) => finj-eq {J} {G} {j'} {j} h e left) = (\\lam (e : E {G.F j'}) => finj-eq {J} {G} {j'} {j} h e right)", "this : Cone ", "j' : Ob {J {\\this}}", "h : Hom {J {\\this}} j j'", "j : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {F {G {\\this}} j'}} ->\n  (@) h1 i (conj {F {G {\\this}} j'} x y) = conj {apex {\\this}} ((@) h1 i x) ((@) h1 i y))\n  (func-conj {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-conj {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| conj E E : E", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["h1 : (\\lam (e : E {G.F j'}) => finj-eq {J} {G} {j'} {j} h e left) = (\\lam (e : E {G.F j'}) => finj-eq {J} {G} {j'} {j} h e right)", "this : Cone ", "j' : Ob {J {\\this}}", "h : Hom {J {\\this}} j j'", "j : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {x : E {F {G {\\this}} j'}} -> \\Pi {f : J -> E {F {G {\\this}} j'}} ->\n  BasicCover {F {G {\\this}} j'} {J} x f -> BasicCover {apex {\\this}} {J} ((@) h1 i x) (\\lam (j : J) => (@) h1 i (f j)))\n  (func-basicCover {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-basicCover {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| func-basicCover {J : \\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| BasicCover {J : \\Set} E (J -> E) : \\Prop", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["h1 : (\\lam (e : E {G.F j'}) => finj-eq {J} {G} {j'} {j} h e left) = (\\lam (e : E {G.F j'}) => finj-eq {J} {G} {j'} {j} h e right)", "this : Cone ", "j' : Ob {J {\\this}}", "h : Hom {J {\\this}} j j'", "j : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (unit {F {G {\\this}} j'}) = unit {apex {\\this}})\n  (func-unit {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-unit {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-unit : func (unit {Dom}) = unit {Cod}", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| unit : E", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["J : Precat", "G : Functor J FrameUPresCat"], "Expected type": "Cone {Precat.op {J1}} {Precat.op {FrameUPresCat}} (Functor.op {G1}) (colimit-obj {J1} G1) {\n  | coneMap => colimitMap {J1} G1\n  | coneCoh => {?hidden}\n}", "Expression": "\\new Cone {\n  | J => _\n  | D => _\n  | G => op {G}\n  | apex => colimit-obj G\n  | coneMap => colimitMap G\n  | coneCoh => \\lam h => exts (\\lam x => path (finj-eq h x))\n}", "Premises": ["| apex : Ob {D}", "\\func colimitMap {J : Precat} (G : Functor J FrameUPresCat) (j : J.Ob) : FrameUPresHom (G.F j) (colimit-obj {J} G) {\n  | func => finj {J} {G} {j}\n} => \\new FrameUPresHom {\n  | func-conj => {?hidden}\n  | func-basicCover => {?hidden}\n  | func-unit => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "| D : Precat", "| G : Functor J D", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| J : Precat", "| F (Ob {C}) : Ob {D}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "finj-eq {j j' : J.Ob} (J.Hom j j') (E {G.F j}) I"]}
{"Context": ["g : \\Sigma (x : X.E) (U.1 x) -> E {Cod {reflectorMap X}}", "h1 : U.1 = (\\lam (e : X.E) => Cover {X} e {\\Sigma (j : \\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {reflectorMap X} j.1).1 x)}\n  (\\lam (p0 : \\Sigma (j : \\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {reflectorMap X} j.1).1 x)) => p0.2))", "X : Ob {D {\\this}}", "U : Opens X"], "Expected type": "Path (\\lam (i : I) => \\Pi (x : X.E) -> SCover {X} x (h1 @ i) -> (@) h1 i x) U.2\n  (Join {PresentedFrame X} {\\Sigma (x : X.E) (U.1 x)} g).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func SCover \\hlevels  {this : FramePres} (x : E) (U : E -> \\Prop) : \\Prop \n  => Cover x {\\Sigma (x : E) (U x)} (\\lam (t : \\Sigma (x : E) (U x)) => t.1)", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {reflector {\\this} X}} -> x <= y -> (@) h1 i x Y.<= (@) h1 i y)\n  (func-<= {ret {\\this} (f {\\this} f1)}) f.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| reflector (Ob {D}) : Ob {C}"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => (@) h1 i (top {reflector {\\this} X}) = Y.top) (func-top {ret {\\this} (f {\\this} f1)}) f.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| ret B : A", "| func-top : func (top {Dom}) = top {Cod}", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| reflector (Ob {D}) : Ob {C}"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => Y.top Y.<= (@) h1 i (top {reflector {\\this} X})) (func-top>= {ret {\\this} (f {\\this} f1)}) f.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| ret B : A", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| reflector (Ob {D}) : Ob {C}"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {reflector {\\this} X}} -> (@) h1 i (x \u2227 y) = (@) h1 i x Y.\u2227 (@) h1 i y)\n  (func-meet {ret {\\this} (f {\\this} f1)}) f.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| reflector (Ob {D}) : Ob {C}", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {reflector {\\this} X}} -> (@) h1 i x Y.\u2227 (@) h1 i y Y.<= (@) h1 i (x \u2227 y))\n  (func-meet>= {ret {\\this} (f {\\this} f1)}) f.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| reflector (Ob {D}) : Ob {C}", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {reflector {\\this} X}} ->\n  (@) h1 i (Join {reflector {\\this} X} {J} f) = Y.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {ret {\\this} (f {\\this} f1)}) f.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| reflector (Ob {D}) : Ob {C}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : Ob {C {\\this}}", "X : Ob {D {\\this}}", "h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func", "f : A {\\this}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {reflector {\\this} X}} ->\n  (@) h1 i (Join {reflector {\\this} X} {J} f) Y.<= Y.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {ret {\\this} (f {\\this} f1)}) f.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| reflector (Ob {D}) : Ob {C}"]}
{"Context": ["Y : Ob {C {\\this}}", "h1 : (\\lam (e : X.E) => func {adjointMap {X} {Y} f} (embed {X} e)) = f.func", "f : B {\\this}", "X : Ob {D {\\this}}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (X.conj x y) = conj {F {\\this} Y} ((@) h1 i x) ((@) h1 i y))\n  (func-conj {f {\\this} (sec {\\this} f1)}) f.func-conj", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)", "| F (Ob {C}) : Ob {D}", "| conj E E : E", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| sec B : A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : Ob {C {\\this}}", "h1 : (\\lam (e : X.E) => func {adjointMap {X} {Y} f} (embed {X} e)) = f.func", "f : B {\\this}", "X : Ob {D {\\this}}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {x : X.E} ->\n  \\Pi {f : J -> X.E} -> X.BasicCover {J} x f -> BasicCover {F {\\this} Y} {J} ((@) h1 i x) (\\lam (j : J) => (@) h1 i (f j)))\n  (func-basicCover {f {\\this} (sec {\\this} f1)}) f.func-basicCover", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| func-basicCover {J : \\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\lam (j : J) => func (f j))", "| BasicCover {J : \\Set} E (J -> E) : \\Prop", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| sec B : A"]}
{"Context": ["Y : Ob {C {\\this}}", "h1 : (\\lam (e : X.E) => func {adjointMap {X} {Y} f} (embed {X} e)) = f.func", "f : B {\\this}", "X : Ob {D {\\this}}", "this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F ", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {y : E {F {\\this} Y}} -> Cover {F {\\this} Y} y {X.E} (h1 @ i))\n  (func-image {f {\\this} (sec {\\this} f1)}) f.func-image", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| func-image {y : E {Cod}} : Cover {Cod} y {E {Dom}} func", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))", "| sec B : A"]}
{"Context": ["h1 : (\\lam (e : X.E) => Cover {X} e {\\Sigma} (\\lam (_ : \\Sigma) => X.unit)) = (\\lam (_ : X.E) => \\Sigma)", "X : Ob {D {\\this}}", "this : FrameUPresHom X (F "], "Expected type": "Path (\\lam (i : I) => \\Pi (x : X.E) -> SCover {X} x (h1 @ i) -> (@) h1 i x) (func {\\this} (unit {Dom {\\this}})).2\n  (unit {Cod {\\this}}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "\\func SCover \\hlevels  {this : FramePres} (x : E) (U : E -> \\Prop) : \\Prop \n  => Cover x {\\Sigma (x : E) (U x)} (\\lam (t : \\Sigma (x : E) (U x)) => t.1)", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| unit : E"]}
{"Context": ["this : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F ", "X : Ob {D {\\this}}"], "Expected type": "FrameUPresHom X (F {\\this} (reflector {\\this} X)) {\n  | func => embed {X}\n  | func-conj => {?hidden}\n  | func-basicCover => {?hidden}\n  | func-unit => {?hidden}\n}", "Expression": "\\new FrameUPresHom {\n  | FramePresHom => reflectorMap X\n  | func-unit => exts (\\lam e => ext (\\lam _ => (), \\lam _ => cover-basic isUnit))\n}", "Premises": ["\\func embed \\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\Sigma} (\\lam (_ : \\Sigma) => x)", "| F (Ob {C}) : Ob {D}", "| func-basicCover {J : \\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\lam (j : J) => func (f j))", "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))", "| func (E {Dom}) : E {Cod}", "| unit : E", "| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)", "cover-basic (P.BasicCover {J} x g)", "| reflector (Ob {D}) : Ob {C}", "\\func reflectorMap (X : FramePres) : FramePresHom X (F (PresentedFrame X)) {\n  | func => embed {X}\n} => \\new FramePresHom {\n  | func-conj => {?hidden}\n  | func-basicCover => {?hidden}\n  | func-image => {?hidden}\n}", "| isUnit {x : E} : BasicCover {\\Sigma} x (\\lam (_ : \\Sigma) => unit)"]}
{"Context": ["this : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F ", "Y : Ob {C {\\this}}", "h : B {\\this}", "arg : func {f {isReflective {X} {Y}} (ret {isReflective {X} {Y}} h)} = h.func", "X : Ob {D {\\this}}", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) arg i (X.conj x y) = conj {F {\\this} Y} ((@) arg i x) ((@) arg i y))\n  (func-conj {f {\\this} (sec {\\this} h)}) h.func-conj", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)", "| F (Ob {C}) : Ob {D}", "| conj E E : E", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| sec B : A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F ", "Y : Ob {C {\\this}}", "h : B {\\this}", "arg : func {f {isReflective {X} {Y}} (ret {isReflective {X} {Y}} h)} = h.func", "X : Ob {D {\\this}}", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {x : X.E} -> \\Pi {f : J -> X.E} ->\n  X.BasicCover {J} x f -> BasicCover {F {\\this} Y} {J} ((@) arg i x) (\\lam (j : J) => (@) arg i (f j)))\n  (func-basicCover {f {\\this} (sec {\\this} h)}) h.func-basicCover", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| func-basicCover {J : \\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\lam (j : J) => func (f j))", "| BasicCover {J : \\Set} E (J -> E) : \\Prop", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| sec B : A"]}
{"Context": ["this : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F ", "Y : Ob {C {\\this}}", "h : B {\\this}", "arg : func {f {isReflective {X} {Y}} (ret {isReflective {X} {Y}} h)} = h.func", "X : Ob {D {\\this}}", "this : QEquiv "], "Expected type": "Path (\\lam (i : I) => (@) arg i X.unit = unit {F {\\this} Y}) (func-unit {f {\\this} (sec {\\this} h)}) h.func-unit", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-unit : func (unit {Dom}) = unit {Cod}", "| F (Ob {C}) : Ob {D}", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| sec B : A", "| unit : E"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> x <= y -> (@) h1 i x <= (@) h1 i y)\n  (func-<= {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-<= {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (top {apex {\\this}}) = top {F {G {\\this}} j'})\n  (func-top {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-top {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "G : Functor J this", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => top {F {G {\\this}} j'} <= (@) h1 i (top {apex {\\this}}))\n  (func-top>= {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-top>= {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| F (Ob {C}) : Ob {D}", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h1 i (x \u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-meet {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x \u2227 y))\n  (func-meet>= {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-meet>= {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| F (Ob {C}) : Ob {D}", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "| meet \\alias \\infixl 7 \u2227 E E : E", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {apex {\\this}}} ->\n  (@) h1 i (Join {apex {\\this}} {J} f) = Join {F {G {\\this}} j'} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-Join {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "j : Ob {J {\\this}}", "h1 : (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\lam (e : \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j}) (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')", "h : Hom {J {\\this}} j j'", "j' : Ob {J {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {apex {\\this}}} ->\n  (@) h1 i (Join {apex {\\this}} {J} f) <= Join {F {G {\\this}} j'} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-Join>= {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| F (Ob {C}) : Ob {D}", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| G : Functor J D", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : Z.E} -> x Z.<= y -> (@) h1 i x <= (@) h1 i y) (func-<= {ret {\\this} (f {\\this} f1)})\n  f.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i Z.top = top {apex {\\this}}) (func-top {ret {\\this} (f {\\this} f1)}) f.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| ret B : A", "| apex : Ob {D}", "| func-top : func (top {Dom}) = top {Cod}", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "G : Functor J this", "J : Precat", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi (j : J.Ob) -> (top {apex {\\this}}).1 j <= ((@) h1 i Z.top).1 j)\n  (func-top>= {ret {\\this} (f {\\this} f1)}) f.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| ret B : A", "| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Ob : \\hType"]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : Z.E} -> (@) h1 i (x Z.\u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {ret {\\this} (f {\\this} f1)}) f.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : Z.E} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x Z.\u2227 y))\n  (func-meet>= {ret {\\this} (f {\\this} f1)}) f.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> Z.E} -> (@) h1 i (Z.Join {J} f) = Join {apex {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {ret {\\this} (f {\\this} f1)}) f.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| apex : Ob {D}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Limit ", "this : QEquiv ", "f : A {\\this}", "h1 : (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (func {ret {\\this} (f {\\this} f1)} e).2))) = (\\lam (e : Z.E) => (\n  \\have arg => \\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1 j}\n  \\in \n        \\let _ => path (\\lam (i : I) (j : J.Ob) => arg j @ i)\n        \\in ((func {ret {\\this} (conePullback {J} {G} (\\new this {}) Z f1)} e).1, (f.func e).2)))", "Z : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> Z.E} -> (@) h1 i (Z.Join {J} f) <= Join {apex {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {ret {\\this} (f {\\this} f1)}) f.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> x <= y -> (@) h1 i x <= (@) h1 i y)\n  (func-<= {f {\\this} \u2218 pbProj1 {\\this}}) (func-<= {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| g : Hom {D} y z", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| y : Ob {D}", "| apex : Ob {D}", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| x : Ob {D}"]}
{"Context": ["this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (top {apex {\\this}}) = top {z {\\this}}) (func-top {f {\\this} \u2218 pbProj1 {\\this}})\n  (func-top {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| g : Hom {D} y z", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| apex : Ob {D}", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| top : E", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| z : Ob {D}", "| x : Ob {D}"]}
{"Context": ["Z : Ob {\\this}", "this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => top {z {\\this}} Z.<= (@) h1 i (top {apex {\\this}})) (func-top>= {f {\\this} \u2218 pbProj1 {\\this}})\n  (func-top>= {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| g : Hom {D} y z", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| apex : Ob {D}", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| top : E", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| z : Ob {D}", "| x : Ob {D}"]}
{"Context": ["this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h1 i (x \u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {f {\\this} \u2218 pbProj1 {\\this}}) (func-meet {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| g : Hom {D} y z", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| y : Ob {D}", "| apex : Ob {D}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| x : Ob {D}"]}
{"Context": ["this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h1 i x \u2227 (@) h1 i y <= (@) h1 i (x \u2227 y))\n  (func-meet>= {f {\\this} \u2218 pbProj1 {\\this}}) (func-meet>= {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| g : Hom {D} y z", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| y : Ob {D}", "| apex : Ob {D}", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| x : Ob {D}"]}
{"Context": ["this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {apex {\\this}}} ->\n  (@) h1 i (Join {apex {\\this}} {J} f) = Join {z {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {f {\\this} \u2218 pbProj1 {\\this}}) (func-Join {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| g : Hom {D} y z", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| apex : Ob {D}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| Join {J : \\Set} (J -> E) : E", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| z : Ob {D}", "| x : Ob {D}"]}
{"Context": ["this : Pullback ", "h1 : (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => f.func e.1) = (\\lam (e : \\Sigma (x : X.E) (y : Y.E) (f.func x = g.func y)) => g.func e.2)"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {apex {\\this}}} ->\n  (@) h1 i (Join {apex {\\this}} {J} f) <= Join {z {\\this}} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {f {\\this} \u2218 pbProj1 {\\this}}) (func-Join>= {g {\\this} \u2218 pbProj2 {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| g : Hom {D} y z", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| apex : Ob {D}", "| f : Hom {D} x z", "| pbProj1 : Hom {D} apex x", "| Join {J : \\Set} (J -> E) : E", "| pbProj2 : Hom {D} apex y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| z : Ob {D}", "| x : Ob {D}"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : w.E} -> x w.<= y -> (@) h3 i x <= (@) h3 i y) h1.func-<= h2.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h3 i w.top = top {apex {\\this}}) h1.func-top h2.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top : func (top {Dom}) = top {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| apex : Ob {D}"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "Y : Ob {\\this}", "X : Ob {\\this}", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Sigma ((top {apex {\\this}}).1 X.<= ((@) h3 i w.top).1) ((top {apex {\\this}}).2 Y.<= ((@) h3 i w.top).2))\n  h1.func-top>= h2.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| apex : Ob {D}"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : w.E} -> (@) h3 i (x w.\u2227 y) = (@) h3 i x \u2227 (@) h3 i y) h1.func-meet h2.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : w.E} -> (@) h3 i x \u2227 (@) h3 i y <= (@) h3 i (x w.\u2227 y)) h1.func-meet>= h2.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> w.E} -> (@) h3 i (w.Join {J} f) = Join {apex {\\this}} {J} (\\lam (j : J) => (@) h3 i (f j))) h1.func-Join\n  h2.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| apex : Ob {D}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h1.func e).1, (h1.func e).2, (h1.func e).3))) = (\\lam (e : w.E) => (\n  \\have arg => (path (\\lam (i : I) => func {p @ i} e), path (\\lam (i : I) => func {q @ i} e))\n  \\in \n        \\let | _ => arg.1\n             | _ => arg.2\n        \\in ((h2.func e).1, (h2.func e).2, (h2.func e).3)))", "h1 : Hom {D {\\this}} w (apex {\\this})", "h2 : Hom {D {\\this}} w (apex {\\this})", "this : Pullback ", "w : Ob {D {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> w.E} -> (@) h3 i (w.Join {J} f) <= Join {apex {\\this}} {J} (\\lam (j : J) => (@) h3 i (f j)))\n  h1.func-Join>= h2.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| apex : Ob {D}"]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> x <= y -> (@) h3 i x Z.<= (@) h3 i y) h1.func-<= h2.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => (@) h3 i (top {apex {\\this}}) = Z.top) h1.func-top h2.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| apex : Ob {D}", "| func-top : func (top {Dom}) = top {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => Z.top Z.<= (@) h3 i (top {apex {\\this}})) h1.func-top>= h2.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h3 i (x \u2227 y) = (@) h3 i x Z.\u2227 (@) h3 i y) h1.func-meet h2.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h3 i x Z.\u2227 (@) h3 i y Z.<= (@) h3 i (x \u2227 y)) h1.func-meet>=\n  h2.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> E {apex {\\this}}} -> (@) h3 i (Join {apex {\\this}} {J} f) = Z.Join {J} (\\lam (j : J) => (@) h3 i (f j)))\n  h1.func-Join h2.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Z : Ob {D {\\this}}", "this : Product ", "h1 : h1.func = h2.func", "h2 : Hom {D {\\this}} Z (apex {\\this})", "h1 : Hom {D {\\this}} Z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} ->\n  \\Pi {f : J -> E {apex {\\this}}} -> (@) h3 i (Join {apex {\\this}} {J} f) Z.<= Z.Join {J} (\\lam (j : J) => (@) h3 i (f j)))\n  h1.func-Join>= h2.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| apex : Ob {D}", "| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["this : QEquiv ", "arg : (ret {\\this} (f.func x.1)).1 = x.1", "f : FrameHom", "x : A {\\this}"], "Expected type": "Path (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| nucleus (E {L}) : E {L}", "| ret B : A", "| \\infix 4 <= E E : \\Prop", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["n : Nucleus ", "L : Ob {C {\\this}}", "this : OFS ", "h : Hom {C {\\this}} L M", "h1 : func {map {n} \u2218 \\new FrameHom (locale {n}) L {\n  | func => \\lam (x : Subtype {n}) => h.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}} = h.func", "M : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i M.top = L.top) (func-top {map {n} \u2218 \\new FrameHom (locale {n}) L {\n  | func => \\lam (x : E {Dom {\\this}}) => h.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) h.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| Join {J : \\Set} (J -> E) : E", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| \\infix 4 <= E E : \\Prop", "| func-top : func (top {Dom}) = top {Cod}", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| func (E {Dom}) : E {Cod}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| top : E", "| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["n : Nucleus ", "L : Ob {C {\\this}}", "this : OFS ", "h : Hom {C {\\this}} L M", "h1 : func {map {n} \u2218 \\new FrameHom (locale {n}) L {\n  | func => \\lam (x : Subtype {n}) => h.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}} = h.func", "M : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => L.top L.<= (@) h1 i M.top) (func-top>= {map {n} \u2218 \\new FrameHom (locale {n}) L {\n  | func => \\lam (x : E {Dom {\\this}}) => h.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) h.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| Join {J : \\Set} (J -> E) : E", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| func-top : func (top {Dom}) = top {Cod}", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "| func (E {Dom}) : E {Cod}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| top : E", "| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["d : Ob {C {\\this}}", "lem : \\Pi (x : d.E) -> s.func (direct {g} (g.func x)) = s.func x", "h1 : (\\lam (e : d.E) => s.func (direct {g} (g.func e))) = s.func", "s : Hom b d", "b : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "Rg : R {\\this} {c} {d} g", "c : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : d.E} -> x d.<= y -> (@) h1 i x b.<= (@) h1 i y) (func-<= {g \u2218 \\new FrameHom c b {\n  | func => \\lam (x : E {Dom {\\this}}) => s.func (direct {g} x)\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) s.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Join {J : \\Set} (J -> E) : E", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func direct \\hlevels  {this : FrameHom} (y : E {Cod}) : E {Dom} => SJoin {Dom} (\\lam (p0 : E {Dom}) => func p0 <= y)", "| \\infix 4 <= E E : \\Prop", "| func-top : func (top {Dom}) = top {Cod}", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| func (E {Dom}) : E {Cod}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| top : E", "| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["d : Ob {C {\\this}}", "lem : \\Pi (x : d.E) -> s.func (direct {g} (g.func x)) = s.func x", "h1 : (\\lam (e : d.E) => s.func (direct {g} (g.func e))) = s.func", "s : Hom b d", "b : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "Rg : R {\\this} {c} {d} g", "c : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i d.top = b.top) (func-top {g \u2218 \\new FrameHom c b {\n  | func => \\lam (x : E {Dom {\\this}}) => s.func (direct {g} x)\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) s.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Join {J : \\Set} (J -> E) : E", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func direct \\hlevels  {this : FrameHom} (y : E {Cod}) : E {Dom} => SJoin {Dom} (\\lam (p0 : E {Dom}) => func p0 <= y)", "| \\infix 4 <= E E : \\Prop", "| func-top : func (top {Dom}) = top {Cod}", "| func (E {Dom}) : E {Cod}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| top : E", "| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["d : Ob {C {\\this}}", "lem : \\Pi (x : d.E) -> s.func (direct {g} (g.func x)) = s.func x", "h1 : (\\lam (e : d.E) => s.func (direct {g} (g.func e))) = s.func", "s : Hom b d", "b : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "Rg : R {\\this} {c} {d} g", "c : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => b.top b.<= (@) h1 i d.top) (func-top>= {g \u2218 \\new FrameHom c b {\n  | func => \\lam (x : E {Dom {\\this}}) => s.func (direct {g} x)\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) s.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Join {J : \\Set} (J -> E) : E", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func direct \\hlevels  {this : FrameHom} (y : E {Cod}) : E {Dom} => SJoin {Dom} (\\lam (p0 : E {Dom}) => func p0 <= y)", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "| func-top : func (top {Dom}) = top {Cod}", "| func (E {Dom}) : E {Cod}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| top : E", "| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["d : Ob {C {\\this}}", "lem : \\Pi (x : d.E) -> s.func (direct {g} (g.func x)) = s.func x", "h1 : (\\lam (e : d.E) => s.func (direct {g} (g.func e))) = s.func", "s : Hom b d", "b : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "Rg : R {\\this} {c} {d} g", "c : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : d.E} -> (@) h1 i (x d.\u2227 y) = (@) h1 i x b.\u2227 (@) h1 i y) (func-meet {g \u2218 \\new FrameHom c b {\n  | func => \\lam (x : E {Dom {\\this}}) => s.func (direct {g} x)\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) s.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Join {J : \\Set} (J -> E) : E", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func direct \\hlevels  {this : FrameHom} (y : E {Cod}) : E {Dom} => SJoin {Dom} (\\lam (p0 : E {Dom}) => func p0 <= y)", "| \\infix 4 <= E E : \\Prop", "| func-top : func (top {Dom}) = top {Cod}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "| top : E", "| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> x M.<= y -> (@) h1 i x L.<= (@) h1 i y)\n  (func-<= {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => (@) h1 i M.top = L.top) (func-top {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top : func (top {Dom}) = top {Cod}", "\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => L.top L.<= (@) h1 i M.top) (func-top>= {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) h1 i (x M.\u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y)\n  (func-meet {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) h1 i x L.\u2227 (@) h1 i y L.<= (@) h1 i (x M.\u2227 y))\n  (func-meet>= {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> M.E} -> (@) h1 i (M.Join {J} f) = L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["M : Ob {C {\\this}}", "h : Hom {C {\\this}} L M", "L : Ob {C {\\this}}", "h1 : (\\lam (e : M.E) => h.func (M.Meet {\\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {M}) (\\Pi {P : \\Prop} -> \\Pi {x : M.E} -> h.func x L.<= pHat {L} P -> x M.<= j.nucleus (pHat {M} P))) =>\n    nucleus {j.1} e))) = h.func", "this : OFS "], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> M.E} -> (@) h1 i (M.Join {J} f) L.<= L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {map {wclosed-image {h}} \u2218 wclosed-factor {h}}) h.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func wclosed-factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| Join {J : \\Set} (J -> E) : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\func wclosed-image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func map \\hlevels  {this2 : Nucleus} : FrameHom L locale {\n  | func => \\lam (x : E {Dom {\\this}}) => (nucleus x, nucleus-join>= {x})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : d.E} -> x d.<= y -> (@) h1 i x b.<= (@) h1 i y)\n  (func-<= {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => (@) h1 i d.top = b.top)\n  (func-top {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-top : func (top {Dom}) = top {Cod}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => b.top b.<= (@) h1 i d.top)\n  (func-top>= {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : d.E} -> (@) h1 i (x d.\u2227 y) = (@) h1 i x b.\u2227 (@) h1 i y)\n  (func-meet {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : d.E} -> (@) h1 i x b.\u2227 (@) h1 i y b.<= (@) h1 i (x d.\u2227 y))\n  (func-meet>= {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> d.E} -> (@) h1 i (d.Join {J} f) = b.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })"]}
{"Context": ["g<=s : \\Pi {x : E {g.Dom}} -> direct {g} (g.func x) <= nucleus {image {s}} x", "s : Hom b d", "d : Ob {C {\\this}}", "g : Hom {C {\\this}} c d", "c : Ob {C {\\this}}", "b : Ob {C {\\this}}", "h1 : func {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})} = s.func", "Rg : R {\\this} {c} {d} g"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> d.E} -> (@) h1 i (d.Join {J} f) b.<= b.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {g \u2218 (hinv {surj_equiv {g} Rg.1} \u2218 <=-map {d} (image {g}) (image {s}) g<=s \u2218 factor {s})}) s.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\func factor \\hlevels  {this2 : FrameHom} : FrameHom (locale {image}) Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => func x.1\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "\\func image \\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\lam (x : E {L {\\this}}) => direct (func x)) => \\new Nucleus {\n  | nucleus-meet => {?hidden}\n  | nucleus-meet>= => {?hidden}\n  | nucleus-<= => {?hidden}\n  | nucleus-unit => {?hidden}\n  | nucleus-join>= => {?hidden}\n  | nucleus-join => {?hidden}\n}", "| hinv : Hom {C} cod dom", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func surj_equiv {f1 : FrameHom} (sur : IsSurj {E {f.Dom}} {E {f.Cod}} f.func) :\nIso {FrameCat} {locale {image {f1}}} {f.Cod} (\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}) {\n  | hinv => \\new FrameHom (cod {\\this}) (dom {\\this}) {\n    | func => \\lam (x : E {f.Cod}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n} => equiv_iso {\\new FrameHom (locale {image {f1}}) f.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func x.1\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}\n  (\\new QEquiv {E} {E {f.Cod}} (\\lam (x : E) => f.func x.1) {\n    | ret => \\lam (x : B {\\this}) => (direct {f1} x,\n      direct-<= {f1} {f.func (direct {f1} x)} {x} (=_<= {f.Cod} {f.func (direct {f1} x)} {x} (surjective-split {f1} sur x)))\n    | ret_f => \\lam (x : A {\\this}) => path (\\lam (i : I) => (\n      \\have arg => <=-antisymmetric {f.Dom} {(ret {\\this} (f.func x.1)).1} {x.1} x.2 (direct-unit {f1} {x.1})\n      \\in (arg @ i, prop-dpi (\\lam (i : I) => nucleus {image {f1}} (arg @ i) <= arg @ i) (ret {\\this} (f {\\this} x)).2 x.2 @ i)))\n    | f_sec => surjective-split {f1} sur\n  })"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "h1 : S.isOpen = T.isOpen", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top) S.open-top T.open-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| open-top : isOpen top", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h1 : S.isOpen = T.isOpen"], "Expected type": "Path (\\lam (i : I) => \\Pi {U V : Set X} -> (@) h1 i U -> (@) h1 i V -> (@) h1 i (U \u2227 V)) S.open-inter T.open-inter", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h1 : S.isOpen = T.isOpen"], "Expected type": "Path (\\lam (i : I) => \\Pi {S : Set (Set X)} -> (\\Pi {U : Set X} -> S U -> (@) h1 i U) -> (@) h1 i (Union {X} S)) S.open-Union\n  T.open-Union", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| open-Union {S : Set (Set E)} (\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func Union \\hlevels  {X : \\hType} (S : Set X -> \\hType) : Set X => \\lam (a : X) => TruncP (\\Sigma (U : Set X) (S U) (U a))"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h2 : S.isCauchy = T.isCauchy"], "Expected type": "Path (\\lam (i : I) => \\Pi {C : Set (Set X)} -> (@) h2 i C -> \\Pi (x : X) -> TruncP (\\Sigma (U : Set X) (C U) (U x)))\n  S.cauchy-cover T.cauchy-cover", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\Sigma (U : Set E) (C U) (U x))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h2 : S.isCauchy = T.isCauchy"], "Expected type": "Path (\\lam (i : I) => (@) h2 i (single {X -> \\Prop} top)) S.cauchy-top T.cauchy-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "\\func single \\hlevels  {X : \\Set} (a : X) : Set X => (=) a", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| cauchy-top : isCauchy (single {E -> \\Prop} top)"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h2 : S.isCauchy = T.isCauchy"], "Expected type": "Path (\\lam (i : I) => \\Pi {C D : Set (Set X)} -> (@) h2 i C -> Refines {X} C D -> (@) h2 i D) S.cauchy-refine T.cauchy-refine", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func Refines \\hlevels  {X : \\hType} (C D : Set (Set X)) : \\Prop => \\Pi {U : Set X} -> C U -> TruncP (\\Sigma (V : Set X) (D V) (U \u2286 V))"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h2 : S.isCauchy = T.isCauchy"], "Expected type": "Path (\\lam (i : I) => \\Pi {C : Set (Set X)} -> (@) h2 i C -> \\Pi {D : Set X -> Set (Set X)} -> (\\Pi {U : Set X} -> C U -> (@) h2 i (D U)) ->\n  (@) h2 i (\\lam (U : Set X) => TruncP (\\Sigma (V W : Set X) (C V) (D V W) (U = V \u2227 W)))) S.cauchy-glue T.cauchy-glue", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\lam (U : Set E) => TruncP (\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["T : PrecoverSpace X", "S : PrecoverSpace X", "X : \\Set", "h1 : S.isOpen = T.isOpen", "h2 : S.isCauchy = T.isCauchy"], "Expected type": "Path (\\lam (i : I) => \\Pi {S : Set X} -> (@) h1 i S <-> (\\Pi {x : X} -> S x -> (@) h2 i (\\lam (U : Set X) => U x -> U \u2286 S)))\n  S.cauchy-open T.cauchy-open", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 0 <-> \\plevels  \\hlevels  (P Q : \\Prop) : \\Prop => \\Sigma (P -> Q) (Q -> P)", "| cauchy-open {S : Set E} : isOpen S <-> (\\Pi {x : E} -> S x -> isCauchy (\\lam (U : Set E) => U x -> U \u2286 S))"]}
{"Context": ["D : Set (Set (E {Cod {\\this}}))", "X : PrecoverSpace", "DU : D U", "U : Set X.E", "Y : PrecoverSpace", "this : PrecoverMap Y X ", "Ux : U x"], "Expected type": "TruncP (\\Sigma (V : Set X.E) (D V) (top = func {\\this} ^-1 V))", "Expression": "inP (later (U, DU, ext (\\lam y => ext (\\lam _ => Ux, \\lam _ => ()))))", "Premises": ["| top : E", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\func \\infix 8 ^-1 \\hlevels  {X Y : \\hType} (f : X -> Y) (S : Set Y) : Set X => \\lam (a : X) => S (f a)", "inP A", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : at {IsEmbedding :: (\\Pi {X : PrecoverSpace (E {Dom})} -> PrecoverMap X Cod {\n  | func => func\n} -> \\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C -> X.isCauchy C) :: (\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C -> isCauchy C) :: (\\new Dom {} = PrecoverTransfer {E {Dom}} {Cod} func) :: nil}\n  2", "this : PrecoverMap"], "Expected type": "\\new Dom {} = PrecoverTransfer {E {Dom}} {Cod} func", "Expression": "PrecoverSpace-ext {_} {{?}} {{?}} {?}", "Premises": ["| Dom : BaseSet", "| Cod : BaseSet", "\\lemma PrecoverSpace-ext \\hlevels  {X : \\Set} {S T : PrecoverSpace X} (_ : \\Pi {C : Set (Set X)} -> S.isCauchy C <-> T.isCauchy C) : S = T ", "| E : \\Set", "\\func PrecoverTransfer \\hlevels  {X : \\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\n  | isOpen => PrecoverSpace.isOpen\n  | isCauchy => \\lam (C : Set (Set (E {\\this}))) =>\n    Y.isCauchy (\\lam (V : Set Y.E) => TruncP (\\Sigma (U : Set (E {\\this})) (C U) (f ^-1 V \u2286 U)))\n} => \\new PrecoverSpace {\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n}", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["h2 : Path (\\lam (i : I) => \\Pi {C : Set (Set X)} -> (@) h2 i C -> \\Pi (x : X) -> TruncP (\\Sigma (U : Set X) (C U) (U x)))\n  S.cauchy-cover T.cauchy-cover", "h2 : Path (\\lam (i : I) => \\Pi {C D : Set (Set X)} -> (@) h2 i C -> Refines {X} C D -> (@) h2 i D) S.cauchy-refine T.cauchy-refine", "h1 : Path (\\lam (i : I) => \\Pi {S : Set (Set X)} -> (\\Pi {U : Set X} -> S U -> (@) h1 i U) -> (@) h1 i (Union {X} S)) S.open-Union\n  T.open-Union", "T : CoverSpace X", "h1 : Path (\\lam (i : I) => \\Pi {U V : Set X} -> (@) h1 i U -> (@) h1 i V -> (@) h1 i (U \u2227 V)) S.open-inter T.open-inter", "h2 : Path (\\lam (i : I) => \\Pi {S : Set X} -> (@) h1 i S <-> (\\Pi {x : X} -> S x -> (@) h2 i (\\lam (U : Set X) => U x -> U \u2286 S)))\n  S.cauchy-open T.cauchy-open", "h1 : S.isOpen = T.isOpen", "h2 : Path (\\lam (i : I) => (@) h2 i (single {X -> \\Prop} top)) S.cauchy-top T.cauchy-top", "S : CoverSpace X", "h2 : S.isCauchy = T.isCauchy", "X : \\Set", "h2 : Path (\\lam (i : I) => \\Pi {C : Set (Set X)} -> (@) h2 i C -> \\Pi {D : Set X -> Set (Set X)} -> (\\Pi {U : Set X} -> C U -> (@) h2 i (D U)) ->\n  (@) h2 i (\\lam (U : Set X) => TruncP (\\Sigma (V W : Set X) (C V) (D V W) (U = V \u2227 W)))) S.cauchy-glue T.cauchy-glue", "h1 : Path (\\lam (i : I) => (@) h1 i top) S.open-top T.open-top"], "Expected type": "Path (\\lam (i : I) => \\Pi {C : Set (Set X)} -> (@) h10 i C -> (@) h10 i (\\lam (V : Set X) => TruncP (\\Sigma (U : Set X) (C U) (V <=< U))))\n  S.isRegular T.isRegular", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\type \\infix 4 <=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\lam (V : Set E) => TruncP (\\Sigma (U : Set E) (C U) (V <=< U)))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : X.E", "X : ExPseudoNormedAbGroup", "y : X.E", "h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> a <= b -> (@) h1 i b) (filter-mono {pointCF {X} x})\n  (filter-mono {pointCF {X} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| filter-mono {a b : E {A}} (F a) (a <= b) : F b", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["x : X.E", "X : ExPseudoNormedAbGroup", "y : X.E", "h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top) (filter-top {pointCF {X} x}) (filter-top {pointCF {X} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| filter-top : F (top {A})", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["x : X.E", "X : ExPseudoNormedAbGroup", "y : X.E", "h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> (@) h1 i b -> (@) h1 i (a \u2227 b)) (filter-meet {pointCF {X} x})\n  (filter-meet {pointCF {X} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["x : X.E", "X : ExPseudoNormedAbGroup", "y : X.E", "h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)"], "Expected type": "Path (\\lam (i : I) => \\Pi {C : Set (Set X.E)} -> X.isCauchy C -> TruncP (\\Sigma (U : Set X.E) (C U) ((@) h1 i U)))\n  (isCauchyFilter {pointCF {X} x}) (isCauchyFilter {pointCF {X} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isCauchy (Set (Set E)) : \\Prop", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isCauchyFilter {C : Set (Set (E {S}))} (isCauchy {S} C) : TruncP (\\Sigma (U : Set (E {S})) (C U) (F U))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : X.E", "X : ExPseudoNormedAbGroup", "y : X.E", "h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set X.E} -> (@) h1 i U -> TruncP (\\Sigma (x : X.E) (U x))) (isProper {pointCF {X} x})\n  (isProper {pointCF {X} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "| isProper {U : Set X} (F U) : TruncP (\\Sigma (x : X) (U x))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : X.E", "X : ExPseudoNormedAbGroup", "y : X.E", "h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set X.E} -> (@) h1 i U -> TruncP (\\Sigma (V : Set X.E) (V <=< U) ((@) h1 i V)))\n  (isRegularFilter {pointCF {X} x}) (isRegularFilter {pointCF {X} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\type \\infix 4 <=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\Sigma (V : Set (E {S})) (V <=< U) (F V))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["S : Set X.E", "p : a.1 = a'.1", "a' : Elem {X.E} S", "a : Elem {X.E} S"], "Expected type": "Path (\\lam (i : I) => S (p @ i)) a.2 a'.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["y : E {\\this}", "p : dist {\\this} x y = zro", "x : E {\\this}"], "Expected type": "rat (pos 1) (suc x) {?hidden} {?hidden} = finv (fromInt (pos (suc y)))", "Expression": "dist-ext {RatNormed} {_} {finv (suc _)} p", "Premises": ["pos Nat", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| dist-ext {x y : E} (dist x y = zro) : x = y", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\func finv (_ : Rat) : Rat \n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}", "suc Nat", "\\func fromInt \\plevels  \\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}"]}
{"Context": ["null : z2 - y < eps * fromRat (ratio (pos 1) 4)", "z2 : Real", "y : Real", "null : z1 = z2", "x : Real", "z1 : Real", "eps : Real", "null : x - z1 < eps * fromRat (ratio (pos 1) 4)"], "Expected type": "x - y < eps * fromRat (ratio (pos 1) 2)", "Expression": "linarith (abs>=id {RealAbGroup} <\u2218r d1, abs>=_- {RealAbGroup} <\u2218r d2, real-lower-ext $ z1=z *> inv z2=z)", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\func ratio \\plevels  \\hlevels  (_ : Int) (_ : Nat) : Rat \n  | nom, 0 => fromInt (pos 0)\n  | nom, suc d => makeRat nom (suc d) (\\lam (p0 : suc d = 0) => (\\case p0 \\with {}))", "| R : Semiring", "| \\infixl 7 * E E : E", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "pos Nat", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func fromRat \\hlevels  (x : Rat) : Real (\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\new Real {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}"]}
{"Context": ["null : z1 - x < eps * fromRat (ratio (pos 1) 4)", "y : Real", "z2 : Real", "null : y - z2 < eps * fromRat (ratio (pos 1) 4)", "x : Real", "z1 : Real", "eps : Real", "null : z1 = z2"], "Expected type": "negative (x - y) < eps * fromRat (ratio (pos 1) 2)", "Expression": "linarith (abs>=_- {RealAbGroup} <\u2218r d1, abs>=id {RealAbGroup} <\u2218r d2, real-lower-ext $ z1=z *> inv z2=z)", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\func ratio \\plevels  \\hlevels  (_ : Int) (_ : Nat) : Rat \n  | nom, 0 => fromInt (pos 0)\n  | nom, suc d => makeRat nom (suc d) (\\lam (p0 : suc d = 0) => (\\case p0 \\with {}))", "| R : Semiring", "| \\infixl 7 * E E : E", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| negative E : E", "pos Nat", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func fromRat \\hlevels  (x : Rat) : Real (\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\new Real {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}"]}
{"Context": ["z : InfReal", "z2 : Real", "z1=z : z1 = z", "z1 : Real", "z2=z : z2 = z"], "Expected type": "z1 = z2", "Expression": "real-lower-ext {?}", "Premises": ["\\lemma real-lower-ext \\plevels  \\hlevels  {x y : Real} (_ : x = y) : x = y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y1=x : y1 = x", "x : InfReal", "y2 : Real", "y1 : Real", "y2=x : y2 = x"], "Expected type": "y2 = y1", "Expression": "real-lower-ext {?}", "Premises": ["\\lemma real-lower-ext \\plevels  \\hlevels  {x y : Real} (_ : x = y) : x = y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y1=x : y1 = x", "x : InfReal", "y : Real", "y2 : Real", "eps2 : Real", "y1 : Real", "d : abs {RealAbGroup} (y1 - y) < eps1 \u2227 eps2", "y2=x : y2 = x", "eps1 : Real"], "Expected type": "abs {RealAbGroup} (y2 - y) < eps2", "Expression": "rewrite (real-lower-ext $ y2=x *> {InfReal} inv y1=x) {?}", "Premises": ["\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| \\infix 4 < E E : \\Prop", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\lemma real-lower-ext \\plevels  \\hlevels  {x y : Real} (_ : x = y) : x = y ", "\\func abs \\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x"]}
{"Context": ["y1=x : y1 = x", "x : InfReal", "y2 : Real", "eps1>0 : zro < eps1", "y2=x : y2 = x", "eps1 : Real", "g1 : \\Pi {y : Real} -> abs {RealAbGroup} (y1 - y) < eps1 -> a y", "a : E {A {\\this}}", "eps2>0 : zro < eps2", "g2 : \\Pi {y : Real} -> abs {RealAbGroup} (y2 - y) < eps2 -> b y", "eps2 : Real", "y1 : Real", "b : E {A {\\this}}"], "Expected type": "(\\Sigma (eps : Real) (zro StrictPoset.< eps) (x1 : Real) (x1 = x)\n  (\\Pi {y : Real} -> abs {RealAbGroup} (x1 - y) StrictPoset.< eps -> (\u2227) a b y)) || (\\Sigma (B : Real) (B InfRealAbMonoid.< x) (\\Pi {y : InfReal} -> B InfRealAbMonoid.< y -> (\u2227) a b y))", "Expression": "byLeft (eps1 \u2227 eps2, <_meet-univ eps1>0 eps2>0, y1, y1=x,\n  \\lam d => (g1 $ d <\u2218l meet-left, g2 $ rewrite (real-lower-ext $ y2=x *> {InfReal} inv y1=x) $ d <\u2218l meet-right))", "Premises": ["byLeft A", "\\type \\infix 4 < \\plevels  \\hlevels  (x y : InfReal) : \\Prop => TruncP (\\Sigma (a : Rat) (x.U a) (y.L a))", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| meet-right {x y : E} : x \u2227 y <= y", "\\lemma real-lower-ext \\plevels  \\hlevels  {x y : Real} (_ : x = y) : x = y ", "\\func abs \\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B", "| meet-left {x y : E} : x \u2227 y <= x", "| \\infix 4 < E E : \\Prop", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| zro : E", "| meet \\alias \\infixl 7 \u2227 E E : E", "| <_meet-univ {x y z : E} (x < y) (x < z) : x < y \u2227 z"]}
{"Context": ["y : Real", "y' : Real", "z : Real", "w' : Real", "null : y' = y", "null : w' - z < half (eps - abs {RealAbGroup} (y - x))", "x : Real", "eps : Real", "null : y - x <= abs {RealAbGroup} (y - x)", "null : z - y' < half (eps - abs {RealAbGroup} (y - x))"], "Expected type": "w' - x < eps", "Expression": "linarith (real-lower-ext y'=y, abs>=id {RealAbGroup} {y - x}, abs>=id {RealAbGroup} <\u2218r d, abs>=_- {RealAbGroup} <\u2218r e)", "Premises": ["| R : Semiring", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "| \\infix 4 < E E : \\Prop", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["null : y' = y", "y : Real", "null : x - y <= abs {RealAbGroup} (y - x)", "y' : Real", "z : Real", "w' : Real", "null : z - w' < half (eps - abs {RealAbGroup} (y - x))", "x : Real", "eps : Real", "null : y' - z < half (eps - abs {RealAbGroup} (y - x))"], "Expected type": "x - w' < eps", "Expression": "linarith (real-lower-ext y'=y, abs>=_- {RealAbGroup} {y} {x}, abs>=_- {RealAbGroup} <\u2218r d, abs>=id {RealAbGroup} <\u2218r e)", "Premises": ["| R : Semiring", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "| \\infix 4 < E E : \\Prop", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : Real", "y'=y : y' = y", "y' : Real"], "Expected type": "y' = y", "Expression": "real-lower-ext y'=y", "Premises": ["\\lemma real-lower-ext \\plevels  \\hlevels  {x y : Real} (_ : x = y) : x = y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["q : V \u2286 h.1", "X : TopSpace", "h : A {\\this}", "q : U \u2286 g.1", "Y : TopSpace", "V : Set X.E", "Ux : U x", "e : \\Pi {x : X.E} -> \\Pi (Vx : V x) -> func {g.4} (x, p {x} Vx) = func {h.4} (x, q {x} Vx)", "p : V \u2286 g.1", "r : \\Pi {x : X.E} -> \\Pi (Vx : U x) -> func {f.4} (x, p {x} Vx) = func {g.4} (x, q {x} Vx)", "x : X.E", "Uo : X.isOpen U", "Vo : X.isOpen V", "p : U \u2286 f.1", "f : A {\\this}", "Vx : V x", "g : A {\\this}", "U : Set X.E"], "Expected type": "TruncP (\\Sigma (V : Set X.E) (X.isOpen V) (V x) (p : V \u2286 f.1) (q : V \u2286 h.1)\n  (\\Pi {x : X.E} -> \\Pi (Vx : V x) -> func {f.4} (x, p {x} Vx) = func {h.4} (x, q {x} Vx)))", "Expression": "inP (U \u2227 V, open-inter Uo Vo, (Ux, Vx), meet-left <=\u2218 p, meet-right <=\u2218 q,\n  \\lam s => pmap f.4 (ext idp) *> r s.1 *> pmap g.4 (ext idp) *> e s.2 *> pmap h.4 (ext idp))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| meet-right {x y : E} : x \u2227 y <= y", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| meet-left {x y : E} : x \u2227 y <= x", "| isOpen (Set E) : \\Prop", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "inP A", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : S1.isOpen = S2.isOpen", "S2 : TopSpace X", "X : \\Set", "S1 : TopSpace X"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top) S1.open-top S2.open-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| open-top : isOpen top", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : S1.isOpen = S2.isOpen", "S2 : TopSpace X", "X : \\Set", "S1 : TopSpace X"], "Expected type": "Path (\\lam (i : I) => \\Pi {U V : Set X} -> (@) h1 i U -> (@) h1 i V -> (@) h1 i (U \u2227 V)) S1.open-inter S2.open-inter", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)"]}
{"Context": ["h1 : S1.isOpen = S2.isOpen", "S2 : TopSpace X", "X : \\Set", "S1 : TopSpace X"], "Expected type": "Path (\\lam (i : I) => \\Pi {S : Set (Set X)} -> (\\Pi {U : Set X} -> S U -> (@) h1 i U) -> (@) h1 i (Union {X} S)) S1.open-Union\n  S2.open-Union", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| open-Union {S : Set (Set E)} (\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func Union \\hlevels  {X : \\hType} (S : Set X -> \\hType) : Set X => \\lam (a : X) => TruncP (\\Sigma (U : Set X) (S U) (U a))"]}
{"Context": ["this : Cat TopSpace ", "q : \\new TopSpace (E {e.dom}) {\n  | isOpen => isOpen {e.dom}\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n} = \\new TopSpace (E {e.cod}) {\n  | isOpen => isOpen {e.cod}\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n}", "e : Iso", "h1 : func {transport {TopSpace} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : E {e.cod} -> \\Prop} -> isOpen {e.cod} U -> isOpen {e.dom} (\\lam (x : E {e.dom}) => U ((@) h1 i x)))\n  (func-cont {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-cont {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-cont {U : E {Cod} -> \\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\lam (x : E {Dom}) => U (func x))", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "| isOpen (Set E) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["y : E {\\this}", "S : CoverSpace", "h1 : x.F = y.F", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> a <= b -> (@) h1 i b) x.filter-mono y.filter-mono", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| filter-mono {a b : E {A}} (F a) (a <= b) : F b", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["y : E {\\this}", "S : CoverSpace", "h1 : x.F = y.F", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top) x.filter-top y.filter-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| filter-top : F (top {A})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["y : E {\\this}", "S : CoverSpace", "h1 : x.F = y.F", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> (@) h1 i b -> (@) h1 i (a \u2227 b)) x.filter-meet y.filter-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["y : E {\\this}", "S : CoverSpace", "h1 : x.F = y.F", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i bottom -> Empty) x.isWeaklyProper y.isWeaklyProper", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Empty \\plevels  \\hlevels  ", "| bottom : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isWeaklyProper : Not (F bottom)"]}
{"Context": ["y : E {\\this}", "S : CoverSpace", "h1 : x.F = y.F", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\Sigma (U : Set S.E) (C U) ((@) h1 i U)))\n  x.isCauchyFilter y.isCauchyFilter", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isCauchy (Set (Set E)) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isCauchyFilter {C : Set (Set (E {S}))} (isCauchy {S} C) : TruncP (\\Sigma (U : Set (E {S})) (C U) (F U))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["F : StronglyRegularCauchyFilter X", "G : StronglyRegularCauchyFilter X", "h1 : F.F = G.F", "X : StronglyRegularCoverSpace"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> a <= b -> (@) h1 i b) F.filter-mono G.filter-mono", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| filter-mono {a b : E {A}} (F a) (a <= b) : F b", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["F : StronglyRegularCauchyFilter X", "G : StronglyRegularCauchyFilter X", "h1 : F.F = G.F", "X : StronglyRegularCoverSpace"], "Expected type": "Path (\\lam (i : I) => (@) h1 i top) F.filter-top G.filter-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| filter-top : F (top {A})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["F : StronglyRegularCauchyFilter X", "G : StronglyRegularCauchyFilter X", "h1 : F.F = G.F", "X : StronglyRegularCoverSpace"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> (@) h1 i b -> (@) h1 i (a \u2227 b)) F.filter-meet G.filter-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["F : StronglyRegularCauchyFilter X", "G : StronglyRegularCauchyFilter X", "h1 : F.F = G.F", "X : StronglyRegularCoverSpace"], "Expected type": "Path (\\lam (i : I) => (@) h1 i bottom -> Empty) F.isWeaklyProper G.isWeaklyProper", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Empty \\plevels  \\hlevels  ", "| bottom : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isWeaklyProper : Not (F bottom)"]}
{"Context": ["F : StronglyRegularCauchyFilter X", "G : StronglyRegularCauchyFilter X", "h1 : F.F = G.F", "X : StronglyRegularCoverSpace"], "Expected type": "Path (\\lam (i : I) => \\Pi {C : Set (Set X.E)} -> X.isCauchy C -> TruncP (\\Sigma (U : Set X.E) (C U) ((@) h1 i U)))\n  F.isCauchyFilter G.isCauchyFilter", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isCauchy (Set (Set E)) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isCauchyFilter {C : Set (Set (E {S}))} (isCauchy {S} C) : TruncP (\\Sigma (U : Set (E {S})) (C U) (F U))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["F : StronglyRegularCauchyFilter X", "G : StronglyRegularCauchyFilter X", "h1 : F.F = G.F", "X : StronglyRegularCoverSpace"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set X.E} -> (@) h1 i U -> TruncP (\\Sigma (V : Set X.E) (V s<=< U) ((@) h1 i V)))\n  F.isStronglyRegularFilter G.isStronglyRegularFilter", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\type \\infix 4 s<=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))", "| isStronglyRegularFilter {U : Set (E {S})} (F U) : TruncP (\\Sigma (V : Set (E {S})) (V s<=< U) (F V))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["Y : CoverSpace", "arg : \\Sigma (x.1 = x'.1) (x.2 = x'.2)", "f : CoverMap X Y", "X : CoverSpace", "h1 : x.1 = x'.1", "x' : E", "x : E"], "Expected type": "Path (\\lam (i : I) => F {pointCF {Y} (arg.2 @ i)} \u2286 F {SetFilter-map {X.E} {Y.E} f.func (h1 @ i)}) x.3 x'.3", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func SetFilter-map \\hlevels  {X1 Y : \\Set} (f : X1 -> Y) (F1 : SetFilter X1) : SetFilter Y (\\lam (V : E {A {\\this}}) => F.F (f ^-1 V)) \n=> \\new SetFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n}", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| F (E {A}) : \\Prop", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["Z : Ob {C {\\this}}", "l1 : CoverMap Y Z", "l2 : CoverMap Y Z", "Y : Ob {C {\\this}}", "h1 : l1.func = l2.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Z.E -> \\Prop} -> Z.isOpen U -> Y.isOpen (\\lam (x : Y.E) => U ((@) h1 i x))) l1.func-cont\n  l2.func-cont", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-cont {U : E {Cod} -> \\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\lam (x : E {Dom}) => U (func x))", "| isOpen (Set E) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["Z : Ob {C {\\this}}", "l1 : CoverMap Y Z", "l2 : CoverMap Y Z", "Y : Ob {C {\\this}}", "h1 : l1.func = l2.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {D : Set (Set Z.E)} ->\n  Z.isCauchy D -> Y.isCauchy (\\lam (U : Set Y.E) => TruncP (\\Sigma (V : Set Z.E) (D V) (U = h1 @ i ^-1 V)))) l1.func-cover\n  l2.func-cover", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isCauchy (Set (Set E)) : \\Prop", "\\func \\infix 8 ^-1 \\hlevels  {X Y : \\hType} (f : X -> Y) (S : Set Y) : Set X => \\lam (a : X) => S (f a)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\lam (U : Set (E {Dom})) => TruncP (\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))"]}
{"Context": ["T : Ob {C {\\this}}", "Z : Ob {C {\\this}}", "g : Hom {C {\\this}} Z T", "r : \\Sigma (t : Hom X Z) (s : Hom Y T) (g \u2218 t = s \u2218 f)", "Y : Ob {C {\\this}}", "sq : \\Pi (x : X.E) -> func {r.2 \u2218 f} x = func {g \u2218 r.1} x", "X : Ob {C {\\this}}", "fd : L {\\this} {X} {Y} f", "f : Hom {C {\\this}} X Y", "gc : R {\\this} {Z} {T} g"], "Expected type": "TruncP (\\Sigma (x : CoverMap Y Z) ((x \u2218 f, g \u2218 x, inv {Hom X T} {g \u2218 x \u2218 f} {g \u2218 (x \u2218 f)} (o-assoc {X} {Y} {Z} {T} {g} {x} {f})) = r))", "Expression": "inP (dense-relative-lift g gc.2 gc.1 f r.1 r.2 fd sq,\n  ext (exts (\\lam x => dense-relative-lift-char sq), exts (\\lam y => dense-relative-lift-proj gc.1 sq)))", "Premises": ["| Hom Ob Ob : \\Set", "\\lemma dense-relative-lift-proj \\hlevels  {X Y Z T : CoverSpace} {p : Z.E -> T.E} {pc : IsRelativelyComplete {Z} {T} p} (ph : IsRelativelyHausdorff {Z} {T} p)\n  {i : CoverMap X Y} {f : CauchyMap X Z} {g : ContMap Y T} {id : IsDenseEmbedding {i}}\n  (sq : \\Pi (x : X.E) -> g.func (i.func x) = p (f.func x)) {y : Y.E} :\n  p (lift-contr {i.Dom} {i.Cod} {Z} {T} {p} pc ph {i} {f} {g} id sq y).1 = g.func y ", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func dense-relative-lift \\hlevels  {X Y Z T : CoverSpace} (p : Z.E -> T.E) (pc : IsRelativelyComplete {Z} {T} p) (ph : IsRelativelyHausdorff {Z} {T} p)\n  (i : CoverMap X Y) (f : CoverMap X Z) (g : ContMap Y T) (id : IsDenseEmbedding {i})\n  (sq : \\Pi (x : X.E) -> g.func (i.func x) = p (f.func x)) : CoverMap Y Z {\n  | func => \\lam (y : E {Dom {\\this}}) => (lift-contr {i.Dom} {i.Cod} {Z} {T} {p} pc ph {i} {f} {g} id sq y).1\n} => \\new CoverMap {\n  | func-cont => {?hidden}\n  | func-cover => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma dense-relative-lift-char \\hlevels  {X Y Z T : CoverSpace} {p : Z.E -> T.E} {pc : IsRelativelyComplete {Z} {T} p} {ph : IsRelativelyHausdorff {Z} {T} p}\n  {f : CauchyMap X Z} {i : CoverMap X Y} {g : ContMap Y T} {id : IsDenseEmbedding {i}}\n  (sq : \\Pi (x : X.E) -> g.func (i.func x) = p (f.func x)) {x : X.E} :\n  func {dense-cauchy-relative-lift {X} {Y} {Z} {T} p pc ph i f g id sq} (i.func x) = f.func x ", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> x M.<= y -> (@) h1 i x L.<= (@) h1 i y) a.func-<= a'.func-<=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => (@) h1 i M.top = L.top) a.func-top a'.func-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| func-top : func (top {Dom}) = top {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => L.top L.<= (@) h1 i M.top) a.func-top>= a'.func-top>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| func-top>= : top {Cod} <= func (top {Dom})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) h1 i (x M.\u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y) a.func-meet a'.func-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y"]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) h1 i x L.\u2227 (@) h1 i y L.<= (@) h1 i (x M.\u2227 y)) a.func-meet>= a'.func-meet>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> M.E} -> (@) h1 i (M.Join {J} f) = L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  a.func-Join a'.func-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-Join {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\lam (j : J) => func (f j))", "| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : a.func = a'.func", "M : Locale", "L : Locale", "a' : FrameHom M L", "a : FrameHom M L"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> M.E} -> (@) h1 i (M.Join {J} f) L.<= L.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  a.func-Join>= a'.func-Join>=", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| Join {J : \\Set} (J -> E) : E", "| func-Join>= {J : \\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\lam (j : J) => func (f j))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["L : Locale", "x : E {\\this}", "y : E {\\this}", "h1 : x.F = y.F"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : L.E} -> (@) h1 i a -> a L.<= b -> (@) h1 i b) x.filter-mono y.filter-mono", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infix 4 <= E E : \\Prop", "| filter-mono {a b : E {A}} (F a) (a <= b) : F b", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["L : Locale", "x : E {\\this}", "y : E {\\this}", "h1 : x.F = y.F"], "Expected type": "Path (\\lam (i : I) => (@) h1 i L.top) x.filter-top y.filter-top", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| filter-top : F (top {A})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["L : Locale", "x : E {\\this}", "y : E {\\this}", "h1 : x.F = y.F"], "Expected type": "Path (\\lam (i : I) => \\Pi {a b : L.E} -> (@) h1 i a -> (@) h1 i b -> (@) h1 i (a L.\u2227 b)) x.filter-meet y.filter-meet", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E"]}
{"Context": ["L : Locale", "x : E {\\this}", "y : E {\\this}", "h1 : x.F = y.F"], "Expected type": "Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> L.E} -> (@) h1 i (L.Join {J} f) -> TruncP (\\Sigma (j : J) ((@) h1 i (f j))))\n  x.filter-Join y.filter-Join", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Join {J : \\Set} (J -> E) : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| filter-Join {J : \\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\Sigma (j : J) (F (f j)))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["Y : CompleteCoverSpace", "s : E {X \u2a2f Y}", "X : CompleteCoverSpace"], "Expected type": "func {tuple {X} {Y} {coverSpace {X \u2a2f Y}} (completion-lift {X \u2a2f Y} {X} (proj1 {X} {Y})) (completion-lift {X \u2a2f Y} {Y} (proj2 {X} {Y}))}\n  (pointCF {X \u2a2f Y} s) = s", "Expression": "ext (completion-lift-char s, completion-lift-char s)", "Premises": ["\\lemma completion-lift-char \\hlevels  {X : CoverSpace} {Z : CompleteCoverSpace} {g : CoverMap X Z} (x : X.E) :\n  func {completion-lift {X} {Z} g} (pointCF {X} x) = g.func x ", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func completion-lift \\hlevels  {X : CoverSpace} {Z : CompleteCoverSpace} (g : CoverMap X Z) : CoverMap (coverSpace {X}) Z {\n  | func => cauchy-lift {X} {coverSpace {X}} {Z} (completion {X}) {?hidden} g\n} => dense-lift {X} {coverSpace {X}} {Z} (completion {X}) (isDenseEmbedding {X}) g", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "\\lemma proj1 \\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} ", "\\func tuple \\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\n  | func => \\lam (z : E {Dom {\\this}}) => (f.func z, g.func z)\n} => \\new CoverMap {\n  | func-cont => {?hidden}\n  | func-cover => {?hidden}\n}", "\\func coverSpace \\hlevels  {X1 : CoverSpace} : CoverSpace (RegularCauchyFilter X1) {\n  | isOpen => PrecoverSpace.isOpen\n  | isCauchy => isCCauchy {X1}\n} => \\new CoverSpace {\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n  | isRegular => {?hidden}\n}", "\\lemma proj2 \\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) Y {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.2\n} "]}
{"Context": ["Y : CompleteCoverSpace", "X : CompleteCoverSpace"], "Expected type": "TruncP (\\Sigma (g : PrecoverMap (Completion (X \u2a2f Y)) (X \u2a2f Y)) (\\Pi (x : E {X \u2a2f Y}) -> g.func (pointCF {X \u2a2f Y} x) = x))", "Expression": "inP (tuple (completion-lift proj1) (completion-lift proj2), \\lam s => ext (completion-lift-char s, completion-lift-char s))", "Premises": ["| func (E {Dom}) : E {Cod}", "\\lemma completion-lift-char \\hlevels  {X : CoverSpace} {Z : CompleteCoverSpace} {g : CoverMap X Z} (x : X.E) :\n  func {completion-lift {X} {Z} g} (pointCF {X} x) = g.func x ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func completion-lift \\hlevels  {X : CoverSpace} {Z : CompleteCoverSpace} (g : CoverMap X Z) : CoverMap (coverSpace {X}) Z {\n  | func => cauchy-lift {X} {coverSpace {X}} {Z} (completion {X}) {?hidden} g\n} => dense-lift {X} {coverSpace {X}} {Z} (completion {X}) (isDenseEmbedding {X}) g", "\\func pointCF \\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\new RegularCauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n  | isRegularFilter => {?hidden}\n}", "inP A", "| E : \\Set", "\\func tuple \\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\n  | func => \\lam (z : E {Dom {\\this}}) => (f.func z, g.func z)\n} => \\new CoverMap {\n  | func-cont => {?hidden}\n  | func-cover => {?hidden}\n}", "\\lemma proj1 \\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} ", "\\lemma proj2 \\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) Y {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.2\n} ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["X : \\Set", "c : PrecoverMap S1 S2 ", "S1 : PrecoverSpace X", "d : PrecoverMap S2 S1 ", "S2 : PrecoverSpace X"], "Expected type": "S1 = S2", "Expression": "PrecoverSpace-ext {?}", "Premises": ["\\lemma PrecoverSpace-ext \\hlevels  {X : \\Set} {S T : PrecoverSpace X} (_ : \\Pi {C : Set (Set X)} -> S.isCauchy C <-> T.isCauchy C) : S = T ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Cat PrecoverSpace ", "h1 : func {transport {PrecoverSpace} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "q : \\new PrecoverSpace (E {e.dom}) {\n  | isOpen => isOpen {e.dom}\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | isCauchy => isCauchy {e.dom}\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n} = \\new PrecoverSpace (E {e.cod}) {\n  | isOpen => isOpen {e.cod}\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | isCauchy => isCauchy {e.cod}\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n}", "e : Iso"], "Expected type": "Path (\\lam (i : I) => \\Pi {D : Set (Set (E {e.cod}))} -> isCauchy {e.cod} D ->\n  isCauchy {e.dom} (\\lam (U : Set (E {e.dom})) => TruncP (\\Sigma (V : Set (E {e.cod})) (D V) (U = h1 @ i ^-1 V))))\n  (func-cover {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-cover {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| isCauchy (Set (Set E)) : \\Prop", "\\func \\infix 8 ^-1 \\hlevels  {X Y : \\hType} (f : X -> Y) (S : Set Y) : Set X => \\lam (a : X) => S (f a)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType", "| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\lam (U : Set (E {Dom})) => TruncP (\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : x.F = y.F", "y : E {\\this}", "S : CoverSpace", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set S.E} -> (@) h1 i U -> TruncP (\\Sigma (x : S.E) (U x))) x.isProper y.isProper", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isProper {U : Set X} (F U) : TruncP (\\Sigma (x : X) (U x))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["X : CoverSpace", "h1 : F.F = G.F", "G : RegularCauchyFilter X", "F : RegularCauchyFilter X"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set X.E} -> (@) h1 i U -> TruncP (\\Sigma (x : X.E) (U x))) F.isProper G.isProper", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isProper {U : Set X} (F U) : TruncP (\\Sigma (x : X) (U x))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["X : CoverSpace", "h1 : F.F = G.F", "G : RegularCauchyFilter X", "F : RegularCauchyFilter X"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set X.E} -> (@) h1 i U -> TruncP (\\Sigma (V : Set X.E) (V <=< U) ((@) h1 i V)))\n  F.isRegularFilter G.isRegularFilter", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\type \\infix 4 <=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\Sigma (V : Set (E {S})) (V <=< U) (F V))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["X : PrecoverSpace", "f : PrecoverMap X Y", "Y : CoverSpace"], "Expected type": "PrecoverMap (RegPrecoverSpace X) Y {\n  | func => f.func\n}", "Expression": "regPrecoverSpace-extend f", "Premises": ["| func (E {Dom}) : E {Cod}", "\\lemma regPrecoverSpace-extend \\hlevels  {X : PrecoverSpace} {Y : CoverSpace} (f : PrecoverMap X Y) : PrecoverMap (RegPrecoverSpace X) Y {\n  | func => f.func\n} ", "\\func RegPrecoverSpace \\hlevels  (X : PrecoverSpace) : CoverSpace X.E => SJoin {CoverLattice X.E} (\\lam (A : E) => A <= \\new X {})"]}
{"Context": ["S : Set X.E", "D : Set (Set X.E)", "X : CoverSpace", "p0 : RegularClosure {X} (single {(X.E -> \\Prop) -> \\Prop} (single {X.E -> \\Prop} S)) D"], "Expected type": "RegularClosure {X} (single {(X.E -> \\Prop) -> \\Prop} (single {X.E -> \\Prop} S))\n  (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (D U) (V <=< U)))", "Expression": "regular-closure-extends p0 idp", "Premises": ["\\type \\infix 4 <=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "\\func single \\hlevels  {X : \\Set} (a : X) : Set X => (=) a", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\data RegularClosure \\hlevels  {X : CoverSpace} (Set (Set X.E) -> \\Prop) (Set (Set X.E)) : \\Prop \n  | regular-closure (A C)\n  | regular-closure-extends {D : Set (Set X.E)} (RegularClosure {X} A D) (C = (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (D U) (V <=< U))))", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : \\Set", "regular-closure-extends {D : Set (Set X.E)} (RegularClosure {X} A D) (C = (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (D U) (V <=< U))))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["p : a <= b", "X : CoverSpace", "S : Set X.E", "a : E {A {\\this}}", "b : E {A {\\this}}"], "Expected type": "extend {X.E} {S} a \u2286 extend {X.E} {S} b", "Expression": "extend-mono p", "Premises": ["\\lemma extend-mono {X : \\Type} {U : Set X} {V W : Set (Total {X} U)} (_ : V \u2286 W) : extend {X} {U} V \u2286 extend {X} {U} W ", "| E : \\Set", "\\func extend {X : \\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\lam (x : X) => \\Sigma (Ux : U x) (V (x, Ux))"]}
{"Context": ["p : F {\\this} a", "q : F {\\this} b", "X : CoverSpace", "a : E {A {\\this}}", "b : E {A {\\this}}", "S : Set X.E", "x' : Total {X.E} S"], "Expected type": "single {X.E} x'.1 <=< extend {X.E} {S} (a \u2227 b)", "Expression": "rewrite extend_meet {?}", "Premises": ["\\type \\infix 4 <=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "\\func single \\hlevels  {X : \\Set} (a : X) : Set X => (=) a", "\\lemma extend_meet {X : \\Type} {U : Set X} {V W : Set (Total {X} U)} : extend {X} {U} (V \u2227 W) = extend {X} {U} V \u2227 extend {X} {U} W ", "| E : \\Set", "| meet \\alias \\infixl 7 \u2227 E E : E", "\\func extend {X : \\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\lam (x : X) => \\Sigma (Ux : U x) (V (x, Ux))"]}
{"Context": ["V' : Set E", "X : CoverSpace", "h : \\Sigma (e : \\Sigma (x : X.E) (\\property (S x))) ((\u2227) (single {\\Sigma (x : X.E) (\\property (S x))} x') V' e) -> V' \u2286 U'", "U' : Set (Total {X.E} S)", "S : Set X.E", "x'<=<V' : single {X.E} x'.1 <=< extend {X.E} {S} V'", "x' : Total {X.E} S"], "Expected type": "V' \u2286 U'", "Expression": "h (x', (idp, transport V' (ext idp) (<=<_<= x'<=<V' idp).2))", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\lemma <=<_<= \\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U "]}
{"Context": ["V' : Set E", "X : CoverSpace", "h : \\Sigma (e : \\Sigma (x : X.E) (\\property (S x))) ((\u2227) (single {\\Sigma (x : X.E) (\\property (S x))} x') V' e) -> V' \u2286 U'", "U' : Set (Total {X.E} S)", "S : Set X.E", "x'<=<V' : single {X.E} x'.1 <=< extend {X.E} {S} V'", "x' : Total {X.E} S"], "Expected type": "extend {X.E} {S} V' \u2286 extend {X.E} {S} U'", "Expression": "extend-mono {?}", "Premises": ["\\lemma extend-mono {X : \\Type} {U : Set X} {V W : Set (Total {X} U)} (_ : V \u2286 W) : extend {X} {U} V \u2286 extend {X} {U} W ", "| E : \\Set", "\\func extend {X : \\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\lam (x : X) => \\Sigma (Ux : U x) (V (x, Ux))"]}
{"Context": ["X : \\Set", "F : ProperFilter (Total ", "U : Set X"], "Expected type": "SetFilter X1 (\\lam (V : E {A {\\this}}) => F.F (\\lam (s : F.X) => V s.1))", "Expression": "filter-extend U F", "Premises": ["| X : \\Set", "\\func filter-extend \\hlevels  {X1 : \\Set} (U : Set X1) (F1 : SetFilter (Total {X1} U)) :\n  SetFilter X1 (\\lam (V : E {A {\\this}}) => F.F (\\lam (s : F.X) => V s.1)) => \\new SetFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n}", "| E : \\Set", "| F (E {A}) : \\Prop", "| A : TopMeetSemilattice"]}
{"Context": ["X : \\Set", "F : ProperFilter (Total ", "U : Set X"], "Expected type": "ProperFilter X1 (\\lam (V : E {A {filter-extend {X1} U F1}}) => F.F (\\lam (s : F.X) => V s.1)) {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isProper => {?hidden}\n}", "Expression": "\\new ProperFilter {\n  | X => X\n  | SetFilter => filter-extend U F\n  | isProper => \\lam c => (\\scase isProper {F} c \\with {\n    | inP (s, Us) => inP (s.1, Us)\n  })\n}", "Premises": ["| X : \\Set", "| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)", "| filter-top : F (top {A})", "\\func filter-extend \\hlevels  {X1 : \\Set} (U : Set X1) (F1 : SetFilter (Total {X1} U)) :\n  SetFilter X1 (\\lam (V : E {A {\\this}}) => F.F (\\lam (s : F.X) => V s.1)) => \\new SetFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n}", "| F (E {A}) : \\Prop", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| filter-mono {a b : E {A}} (F a) (a <= b) : F b", "| isProper {U : Set X} (F U) : TruncP (\\Sigma (x : X) (U x))", "inP A", "| E : \\Set", "| A : TopMeetSemilattice"]}
{"Context": ["S : Set X.E", "F : CauchyFilter (OpenCoverSpace X ", "X : CoverSpace"], "Expected type": "ProperFilter X.E (\\lam (V : E {A {filter-extend {X.E} S F1}}) => F.F (\\lam (s : F.X) => V s.1))", "Expression": "proper-filter-extend S F", "Premises": ["| X : \\Set", "\\func proper-filter-extend \\hlevels  {X1 : \\Set} (U : Set X1) (F1 : ProperFilter (Total {X1} U)) :\n  ProperFilter X1 (\\lam (V : E {A {filter-extend {X1} U F1}}) => F.F (\\lam (s : F.X) => V s.1)) => \\new ProperFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isProper => {?hidden}\n}", "\\func filter-extend \\hlevels  {X1 : \\Set} (U : Set X1) (F1 : SetFilter (Total {X1} U)) :\n  SetFilter X1 (\\lam (V : E {A {\\this}}) => F.F (\\lam (s : F.X) => V s.1)) => \\new SetFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n}", "| E : \\Set", "| F (E {A}) : \\Prop", "| A : TopMeetSemilattice"]}
{"Context": ["X : CompleteCoverSpace", "So : X.isOpen S", "S : Set X.E"], "Expected type": "TruncP (\\Sigma (Y : SeparatedCoverSpace) (f : PrecoverMap (OpenCoverSpace X {S} So) Y) (IsInj {E} {Y.E} f.func))", "Expression": "inP (X, func X So, \\lam p => ext p)", "Premises": ["\\func func \\hlevels  (X : CoverSpace) {S : Set X.E} (So : X.isOpen S) : PrecoverMap (OpenCoverSpace X {S} So) X {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => \\new PrecoverMap {\n  | func-cont => {?hidden}\n  | func-cover => {?hidden}\n}", "\\func OpenCoverSpace \\hlevels  (X : CoverSpace) {S : Set X.E} (So : X.isOpen S) : CoverSpace (\\Sigma (x : X.E) (\\property (S x))) {\n  | isOpen => PrecoverSpace.isOpen\n    {ClosurePrecoverSpace {\\Sigma (x : X.E) (\\property (S x))} (isBasicCover {X} {S}) (basicCover-cover {X} {S} {So})}\n  | isCauchy => Closure {\\Sigma (x : X.E) (\\property (S x))} (isBasicCover {X} {S})\n} => ClosureCoverSpace\n  {\\Sigma (x : X.E) (\\property (S x))} (isBasicCover {X} {S}) (basicCover-cover {X} {S} {So}) (basicCover-regular {X} {S})", "inP A", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func IsInj \\hlevels  {A B : \\Set} (f : A -> B) : \\Prop => \\Pi {a a' : A} -> f a = f a' -> a = a'", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["X : CompleteCoverSpace", "So : X.isOpen S", "F : RegularCauchyFilter this", "S : Set X.E"], "Expected type": "CauchyFilter X1 (\\lam (V : E {A {filter-extend {X.E} S F1}}) => F.F (\\lam (s : F.X) => V s.1))", "Expression": "cauchy-filter-extend X So F", "Premises": ["| X : \\Set", "\\func filter-extend \\hlevels  {X1 : \\Set} (U : Set X1) (F1 : SetFilter (Total {X1} U)) :\n  SetFilter X1 (\\lam (V : E {A {\\this}}) => F.F (\\lam (s : F.X) => V s.1)) => \\new SetFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n}", "\\func cauchy-filter-extend \\hlevels  (X1 : CoverSpace) {S1 : Set X.E} (So : X.isOpen S1) (F1 : CauchyFilter (OpenCoverSpace X1 {S1} So)) :\n  CauchyFilter X1 (\\lam (V : E {A {filter-extend {X.E} S1 F1}}) => F.F (\\lam (s : F.X) => V s.1)) => \\new CauchyFilter {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n}", "| E : \\Set", "| F (E {A}) : \\Prop", "| A : TopMeetSemilattice"]}
{"Context": ["X : CompleteCoverSpace", "S : Set X.E"], "Expected type": "RegularClosure {X} (single {(E {X} -> \\Prop) -> \\Prop} (single {E {X} -> \\Prop} S))\n  (\\lam (V : Set (E {X})) => TruncP (\\Sigma (U : Set (E {X})) (single {E {X} -> \\Prop} S U) (V <=< U)))", "Expression": "regular-closure-extends {?} idp", "Premises": ["\\type \\infix 4 <=< \\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\Prop => X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "\\func single \\hlevels  {X : \\Set} (a : X) : Set X => (=) a", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "\\data RegularClosure \\hlevels  {X : CoverSpace} (Set (Set X.E) -> \\Prop) (Set (Set X.E)) : \\Prop \n  | regular-closure (A C)\n  | regular-closure-extends {D : Set (Set X.E)} (RegularClosure {X} A D) (C = (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (D U) (V <=< U))))", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : \\Set", "regular-closure (A C)", "regular-closure-extends {D : Set (Set X.E)} (RegularClosure {X} A D) (C = (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (D U) (V <=< U))))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : X.E -> Partial Y.E", "x' : X.E", "Y : TopSpace", "V'x'_Wx' : (\u2227) (\\lam (x : X.E) => isDefined {f x}) W x'"], "Expected type": "make {Y.E} (isDefined {f x'}) (value {f x'}) = defined {Y.E} (value {make {Y.E} (isDefined {f x'}) (value {f x'})} {?hidden})", "Expression": "defined-ext {_} {{?}} {?} idp", "Premises": ["\\func defined \\hlevels  {X : \\Set} (x : X) : Partial X {\n  | isDefined => \\Sigma\n  | value => \\lam (_ : isDefined {\\this}) => x\n} => \\new Partial", "| value isDefined : E", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| isDefined : \\Prop", "| E : \\Set", "\\func make \\hlevels  {X : \\Set} (P : \\Prop) (f : P -> X) : Partial X {\n  | isDefined => P\n  | value => f\n} => \\new Partial", "\\lemma defined-ext \\hlevels  {X : \\Set} {u : Partial X} {x : X} (d : u.isDefined) (_ : u.value d = x) : u = defined {X} x "]}
{"Context": ["f : X.E -> Partial Y.E", "W : Set X.E", "p : (\\lam (x : E {Dom {p0.2}}) => U' (func {p0.2} x)) = (\\lam (p0 : Total {X.E} (\\lam (x : X.E) => isDefined {f x})) => p0.1) ^-1 W", "U : E {Cod {\\this}} -> \\Prop", "g : \\Pi {y' : Y.E} -> U' y' -> U (defined {Y.E} y')", "X : TopSpace", "p0 : (\u2227) (\\lam (x : X.E) => isDefined {f x}) W x'", "x' : X.E", "Y : TopSpace", "U' : Set Y.E", "V'o_fc : \\Sigma (X.isOpen (\\lam (x : X.E) => isDefined {f x}))\n  (ContMap (TopTransfer {Total {X.E} (\\lam (x : X.E) => isDefined {f x})} {X}\n    (\\lam (p0 : Total {X.E} (\\lam (x : X.E) => isDefined {f x})) => p0.1)) Y {\n    | func => \\lam (x : E {Dom {\\this}}) => value {f x.1} x.2\n  })"], "Expected type": "U (f x')", "Expression": "\n  \\let (V'x', Wx') => p0\n  \\in transportInv U (defined-ext {_} {make _ _} (\\box V'x') idp) $ g $ (<->_=.2 $ pmap (\\lam p0 => p0 (x', V'x')) p).2 Wx'", "Premises": ["\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\lemma defined-ext \\hlevels  {X : \\Set} {u : Partial X} {x : X} (d : u.isDefined) (_ : u.value d = x) : u = defined {X} x ", "\\func transportInv {A : \\Type} (B : A -> \\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \n  | {A}, B, {a}, {a'}, idp, b => b", "\\func defined \\hlevels  {X : \\Set} (x : X) : Partial X {\n  | isDefined => \\Sigma\n  | value => \\lam (_ : isDefined {\\this}) => x\n} => \\new Partial", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func make \\hlevels  {X : \\Set} (P : \\Prop) (f : P -> X) : Partial X {\n  | isDefined => P\n  | value => f\n} => \\new Partial", "\\lemma <->_= \\plevels  \\hlevels  {P Q : \\Prop} : (P <-> Q) <-> P = Q "]}
{"Context": ["Z : TopSpace", "x : E", "X : TopSpace", "y : E", "f : ContMap (X \u2a2f Y) Z", "Y : TopSpace", "d1 : \\Sigma (d : x.isDefined) (U' (x.value d))", "d2 : \\Sigma (d : y.isDefined) (V' (y.value d))"], "Expected type": "plift2 {X.E} {Y.E} {Z.E} (\\lam (x : X.E) (y : Y.E) => f.func (x, y)) x y = defined {Z.E} (value {plift2 {X.E} {Y.E} {Z.E} (\\lam (x : X.E) (y : Y.E) => f.func (x, y)) x y} (d1.1, d2.1))", "Expression": "defined-ext {_} {{?}} {?} idp", "Premises": ["\\func defined \\hlevels  {X : \\Set} (x : X) : Partial X {\n  | isDefined => \\Sigma\n  | value => \\lam (_ : isDefined {\\this}) => x\n} => \\new Partial", "| value isDefined : E", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func plift2 \\hlevels  {X Y Z : \\Set} (f : X -> Y -> Z) (p : Partial X) (q : Partial Y) : Partial Z {\n  | isDefined => \\Sigma p.isDefined q.isDefined\n  | value => \\lam (d : isDefined {\\this}) => f (p.value d.1) (q.value d.2)\n} => \\new Partial", "\\lemma defined-ext \\hlevels  {X : \\Set} {u : Partial X} {x : X} (d : u.isDefined) (_ : u.value d = x) : u = defined {X} x "]}
{"Context": ["Y : TopLModule R", "X : TopLModule R", "r' : E {R {\\this}}", "r : E {R {\\this}}", "this : TopLModule R1 (\\Sigma X.E Y.E) ", "a : E {\\this}"], "Expected type": "r * r' *c a = r *c (r' *c a)", "Expression": "ext (*c-assoc, *c-assoc)", "Premises": ["| \\infixl 7 * E E : E", "| \\infixl 7 *c (E {R}) E : E", "| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : TopLModule R", "X : TopLModule R", "r : E {R {\\this}}", "this : TopLModule R1 (\\Sigma X.E Y.E) ", "b : E {\\this}", "a : E {\\this}"], "Expected type": "r *c (a + b) = r *c a + r *c b", "Expression": "ext (*c-ldistr, *c-ldistr)", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : E {\\this}", "s : E {R {\\this}}", "Y : TopLModule R", "X : TopLModule R", "this : TopLModule R1 (\\Sigma X.E Y.E) ", "r : E {R {\\this}}"], "Expected type": "(r + s) *c a = r *c a + s *c a", "Expression": "ext (*c-rdistr, *c-rdistr)", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *c-rdistr {r s : E {R}} {a : E} : (r + s) *c a = r *c a + s *c a"]}
{"Context": ["a : E {\\this}", "Y : TopLModule R", "X : TopLModule R", "this : TopLModule R1 (\\Sigma X.E Y.E) "], "Expected type": "ide {R {\\this}} *c a = a", "Expression": "ext (ide_*c, ide_*c)", "Premises": ["| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| ide_*c {a : E} : ide {R} *c a = a", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["t : TruncP (\\Sigma (V : Set E) (E1 V) (U = cu.func ^-1 V))", "E : Set (Set (E {Cod {\\this}}))", "q : Rat", "U : Set E", "cu : UniformMap this this ", "this : TopAbGroupMap this this ", "this : TopRieszSpace"], "Expected type": "TruncP (\\Sigma (V : Set E) (E1 V) (U = func {\\this} ^-1 V))", "Expression": "map t (\\lam s => later $ (s.1, s.2,\n  s.3 *> ext (\\lam x => pmap s.1 $ inv (*q_*i ) *> inv (*q-assoc ) *> pmap (\\lam _x => _x *q  x) (inv rat-split))))", "Premises": ["\\func \\infixl 7 *i \\hlevels  {this2 : AddGroup} (_ : Int) (_ : E) : E \n  | {this}, pos n, a => n *n a\n  | {this}, neg n, a => n *n negative a", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func \\infix 8 ^-1 \\hlevels  {X Y : \\hType} (f : X -> Y) (S : Set Y) : Set X => \\lam (a : X) => S (f a)", "\\lemma *q_*i \\hlevels  {this : QModule} {x : Int} {a : E} : fromInt x *q a = x *i a ", "\\lemma rat-split \\plevels  \\hlevels  {q : Rat} : q = fromInt (ratNom q) * finv (fromInt (pos (ratDenom q))) ", "\\infixl 7 *q \\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "| \\infixl 7 * E E : E", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma *q-assoc \\hlevels  {this : QModule} {q r : Rat} {a : E} : q * r *q a = q *q (r *q a) ", "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\func * (_ _ : Rat) : Rat \n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}"]}
{"Context": ["p : E {\\this}", "B : A.E -> DecSet", "e : p.1 = q.1", "A : DecSet", "this : DecSet (\\Sigma (a : A.E) (E ", "q : E {\\this}", "e' : transport {A.E} (\\lam (a : A.E) => E {B a}) {p.1} {q.1} e p.2 = q.2"], "Expected type": "p = q", "Expression": "ext (e, e')", "Premises": ["\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["X : CoverSpace", "I : DirectedSet", "fc : \\Pi {D : Set (Set Y.E)} -> Y.isCauchy D -> X.isCauchy (\\lam (U : Set X.E) =>\n  TruncP (\\Sigma (N : I.E) (V : Set Y.E) (D V) (\\Pi {n : I.E} -> \\Pi {x : X.E} -> N I.<= n -> U x -> V (func {f n} x))))", "f : I.E -> CoverMap X Y", "Y : CoverSpace"], "Expected type": "CoverMap (RegPrecoverSpace (precover {I} \u2a2f X)) Y {\n  | func => \\lam (s : E {precover {I} \u2a2f X}) => func {f s.1} s.2\n}", "Expression": "regPrecoverSpace-extend-coverMap {precover \u2a2f X} {?}", "Premises": ["\\lemma regPrecoverSpace-extend-coverMap \\hlevels  {X : PrecoverSpace} {Y : CoverSpace} (f : PrecoverMap X Y) : CoverMap (RegPrecoverSpace X) Y {\n  | func => f.func\n} ", "| E : \\Set", "\\func precover \\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\n  | isOpen => PrecoverSpace.isOpen\n  | isCauchy => \\lam (C : Set (Set (E {\\this}))) =>\n  \\Sigma (TruncP (\\Sigma (U : Set (E {\\this})) (C U) (N : I.E) (\\Pi {n : I.E} -> N I.<= n -> U n)))\n    (\\Pi (n : I.E) -> TruncP (\\Sigma (V : Set (E {\\this})) (C V) (V n)))\n} => \\new PrecoverSpace {\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func RegPrecoverSpace \\hlevels  (X : PrecoverSpace) : CoverSpace X.E => SJoin {CoverLattice X.E} (\\lam (A : E) => A <= \\new X {})"]}
{"Context": ["X : TopLModule R", "R : NearSkewField", "Y : HausdorffTopLModule R", "u : \\Sigma (f' : ContMap (DerivDom {R} {X} U) Y) (IsDerivQuot {R} {X} {Y} {U} f f'.func)", "f : Total {X.E} U -> Y.E", "U : Set X.E", "v : \\Sigma (f' : ContMap (DerivDom {R} {X} U) Y) (IsDerivQuot {R} {X} {Y} {U} f f'.func)", "Uo : X.isOpen U"], "Expected type": "u = v", "Expression": "ext (exts (\\lam s => unique f Uo u.1 v.1 u.2 v.2))", "Premises": ["\\lemma unique \\hlevels  {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} {U : Set X.E} (f : Total {X.E} U -> Y.E)\n  (_ : X.isOpen U) (f'1 f'2 : ContMap (DerivDom {R} {X} U) Y) (_ : IsDerivQuot {R} {X} {Y} {U} f f'1.func)\n  (_ : IsDerivQuot {R} {X} {Y} {U} f f'2.func) {s : E} : f'1.func s = f'2.func s ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : MeasureRing", "x : E {\\this}"], "Expected type": "meas x = zro -> x = zro", "Expression": "meas-ext ", "Premises": ["| meas E : ExUpperReal", "| meas-ext {x : E} (meas x = zro) : x = zro", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : X.E", "eps : Rat", "FB : F.F (\\lam (y : X.E) => U {X.meas (a X.* (X.zro X.+ (x - y)))} eps)", "X : PremeasureRing", "F : SetFilter X.E", "x : X.E"], "Expected type": "TruncP (\\Sigma (x : X.E) (F.F (OBall {X} a eps x)))", "Expression": "inP (x, transport F (ext (\\lam y => pmap (\\lam z => U {meas (a * z)} _) $ zro-left *> pmap ((+) x) negative=id)) FB)", "Premises": ["| meas E : ExUpperReal", "| \\infixl 7 * E E : E", "| U Rat : \\Prop", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| negative E : E", "| F (E {A}) : \\Prop", "\\lemma negative=id \\hlevels  {this : BooleanRing} {x : E} : negative x = x ", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| \\infixl 6 + E E : E", "\\func OBall \\hlevels  {this : PremeasureRing} (a : E) (eps : Rat) (c : E) : Set E => \\lam (z : E) => U {meas (a * (c + z))} eps", "| zro-left {x : E} : zro + x = x", "inP A", "| E : \\Set", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["a : \\Sigma V.E B.E", "p : \\Pi (i : Fin (suc l.len)) -> (at {a :: l} i).1 = x.1", "B : BooleanRing", "n : Nat", "l : Array (\\Sigma V.E B.E) n", "x : \\Sigma V.E B.E", "q : BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (a :: l)) = x.2", "V : PosetQModule"], "Expected type": "a = (x.1, a.2 B.* x.2)", "Expression": "ext (p 0, <=-antisymmetric (meet-univ <=-refl $ BigJoin-cond {B} {map (\\lam p0 => p0.2) (a :: l)} 0 <=\u2218 =_<= q) meet-left)", "Premises": ["| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "| \\infixl 7 * E E : E", "\\lemma BigJoin-cond \\hlevels  {this : BottomJoinSemilattice} {l : Array E} (j : Fin l.len) : l.at j <= BigJoin l ", "\\lemma =_<= \\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| <=-refl {x : E} : x <= x", "| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y", "| meet-left {x y : E} : x \u2227 y <= x", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func BigJoin \\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l"]}
{"Context": ["B : BooleanRing", "l : Array (\\Sigma V.E B.E) n", "V : PosetQModule", "n : Nat", "a : \\Sigma V.E B.E", "lr : IsReduced {V} {B} (a :: l)"], "Expected type": "((a.1, diff {B} a.2 (BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (reduce {V} {B} l)))) :: map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (a.1 V.+ s.1, a.2 B.* s.2)) (reduce {V} {B} l) ++ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)) !! 0 = (a :: l) !! 0", "Expression": "ext (idp,\n  <=-antisymmetric (diff_<= {B}) $ diff-univ {B} <=-refl $ BigJoin-ldistr {B} *> <=-antisymmetric (BigJoin-univ {B} (\\lam j => later $ =_<= $ aux {V} {B} lr j)) (later bottom-univ))", "Premises": ["| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\lemma diff-univ \\hlevels  {this : BooleanRing} {x y z : E} (_ : x <= y) (_ : x * z = zro) : x <= diff y z ", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\lemma BigJoin-univ \\hlevels  {this : BottomJoinSemilattice} {l : Array E} {x : E} (_ : \\Pi (j : Fin l.len) -> l.at j <= x) : BigJoin l <= x ", "\\lemma =_<= \\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ", "\\lemma BigJoin-ldistr \\hlevels  {this : BottomDistributiveLattice} {l : Array E} {x : E} :\n  x \u2227 BigJoin l = BigJoin (\\new Array E l.len (\\lam (j : Fin l.len) => x \u2227 l.at j)) ", "| <=-refl {x : E} : x <= x", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func BigJoin \\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l", "| E : \\Set", "\\lemma aux \\hlevels  {V : PosetQModule} {B : BooleanRing} {a : \\Sigma V.E B.E} {l : PFunc {V} {B}} (_ : IsReduced {V} {B} (a :: l))\n  (j : Fin (len {reduce {V} {B} l})) : a.2 B.\u2227 (at {reduce {V} {B} l} j).2 = B.zro ", "| \\infixl 7 * E E : E", "\\lemma diff_<= \\hlevels  {this : BooleanRing} {x y : E} : diff x y <= x ", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\func reduce \\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \n  | {V}, {B}, nil => nil\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "| bottom-univ {x : E} : bottom <= x", "\\func diff \\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y", "\\func \\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i "]}
{"Context": ["B : BooleanRing", "i : Fin l.len", "l : Array (\\Sigma V.E B.E) n", "V : PosetQModule", "n : Nat", "a : \\Sigma V.E B.E", "lr : IsReduced {V} {B} (a :: l)"], "Expected type": "((l !! i).1, diff {B} (l !! i).2 a.2) = (a :: l) !! suc i", "Expression": "ext (idp, <=-antisymmetric (diff_<= {B}) $ diff-univ {B} <=-refl $ lr fsuc/=0)", "Premises": ["| <=-refl {x : E} : x <= x", "| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\lemma diff_<= \\hlevels  {this : BooleanRing} {x y : E} : diff x y <= x ", "\\lemma diff-univ \\hlevels  {this : BooleanRing} {x y z : E} (_ : x <= y) (_ : x * z = zro) : x <= diff y z ", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func diff \\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y", "suc Nat", "\\func \\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma fsuc/=0 \\plevels  \\hlevels  {n : Nat} {x : Fin n} : fsuc {n} x /= 0 "]}
{"Context": ["B : BooleanRing", "i : Fin l.len", "l : Array (\\Sigma V.E B.E) n", "k : Fin (len {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)})", "V : PosetQModule", "n : Nat", "a : \\Sigma V.E B.E", "lr : IsReduced {V} {B} (a :: l)", "q : reduce {V} {B} l !! k = l !! i"], "Expected type": "(\\Sigma (j : Fin (suc l.len))\n  (at {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)} k = (a :: l) !! j)) || ((at {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)} k).2 = B.zro)", "Expression": "byLeft (rewrite q $ (suc i, ext (idp, <=-antisymmetric (diff_<= {B}) $ diff-univ {B} <=-refl $ lr fsuc/=0)))", "Premises": ["byLeft A", "| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\lemma diff_<= \\hlevels  {this : BooleanRing} {x y : E} : diff x y <= x ", "\\lemma diff-univ \\hlevels  {this : BooleanRing} {x y z : E} (_ : x <= y) (_ : x * z = zro) : x <= diff y z ", "\\func reduce \\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \n  | {V}, {B}, nil => nil\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B", "| len : Nat", "| <=-refl {x : E} : x <= x", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func diff \\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "suc Nat", "| E : \\Set", "\\func \\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ", "| zro : E", "\\lemma fsuc/=0 \\plevels  \\hlevels  {n : Nat} {x : Fin n} : fsuc {n} x /= 0 "]}
{"Context": ["V : PosetQModule", "B : BooleanRing", "n : Nat", "l : Array (\\Sigma V.E B.E) n", "a : \\Sigma V.E B.E", "lr : IsReduced {V} {B} (a :: l)"], "Expected type": "(a :: l) !! 0 = ((a.1, diff {B} a.2 (BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (reduce {V} {B} l)))) :: map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (a.1 V.+ s.1, a.2 B.* s.2)) (reduce {V} {B} l) ++ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)) !! 0", "Expression": "ext (idp, <=-antisymmetric\n  (diff-univ {B} <=-refl $ BigJoin-ldistr {B} *> <=-antisymmetric (BigJoin-univ {B} (\\lam j => later $ =_<= $ aux {V} {B} lr j)) (later bottom-univ))\n    (diff_<= {B}))", "Premises": ["| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "\\lemma diff-univ \\hlevels  {this : BooleanRing} {x y z : E} (_ : x <= y) (_ : x * z = zro) : x <= diff y z ", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\lemma BigJoin-univ \\hlevels  {this : BottomJoinSemilattice} {l : Array E} {x : E} (_ : \\Pi (j : Fin l.len) -> l.at j <= x) : BigJoin l <= x ", "\\lemma =_<= \\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ", "\\lemma BigJoin-ldistr \\hlevels  {this : BottomDistributiveLattice} {l : Array E} {x : E} :\n  x \u2227 BigJoin l = BigJoin (\\new Array E l.len (\\lam (j : Fin l.len) => x \u2227 l.at j)) ", "| <=-refl {x : E} : x <= x", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func BigJoin \\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l", "| E : \\Set", "\\lemma aux \\hlevels  {V : PosetQModule} {B : BooleanRing} {a : \\Sigma V.E B.E} {l : PFunc {V} {B}} (_ : IsReduced {V} {B} (a :: l))\n  (j : Fin (len {reduce {V} {B} l})) : a.2 B.\u2227 (at {reduce {V} {B} l} j).2 = B.zro ", "| \\infixl 7 * E E : E", "\\lemma diff_<= \\hlevels  {this : BooleanRing} {x y : E} : diff x y <= x ", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\func reduce \\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \n  | {V}, {B}, nil => nil\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "| bottom-univ {x : E} : bottom <= x", "\\func diff \\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y", "\\func \\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i "]}
{"Context": ["l : PFunc {V} {B}", "V : RieszSpace", "B : BooleanRing"], "Expected type": "map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})}\n  (\\lam (s : \\Sigma V.E (E {B})) => (abs {V} s.1 V.+ V.negative (V.negative s.1), s.2)) l ~ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (abs {V} s.1 V.+ s.1, s.2)) l", "Expression": "~-perm (eperm-= $ later $ exts (\\lam j => ext (pmap ((+) _) (negative-isInv {V}), idp)))", "Premises": ["\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func eperm-= {A1 : \\Type} {l1 l' : Array A1} (_ : l1 = l') : EPerm {A1} l1 l' \n  | {A}, {l}, {l'}, idp => eperm-refl {A} {l}", "\\lemma negative-isInv \\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ", "| negative E : E", "~-perm (EPerm {\\Sigma V.E B.E} l l')", "\\func abs \\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data \\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\Sigma V.E B.E)) : \\Prop \n  | ~-perm (EPerm {\\Sigma V.E B.E} l l')\n  | ~-sym (l' ~ l)\n  | ~-trans {m : Array (\\Sigma V.E B.E)} (l ~ m) (m ~ l')\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\n  | ~-+-left {l'' : Array (\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\n  | ~-+-right {l'' : Array (\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')", "| \\infixl 6 + E E : E", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : \\Set"]}
{"Context": ["p : \\Pi {C : Set (Set X.E)} ->\n  X.isCauchy C -> TruncP (\\Sigma (U : Set X.E) (C U) (N : I.E) (\\Pi {n : I.E} -> N I.<= n -> U (f n)))", "X : CoverSpace", "I : DirectedSet", "f : I.E -> X.E"], "Expected type": "CoverMap (RegPrecoverSpace (precover {I})) X {\n  | func => f\n}", "Expression": "regPrecoverSpace-extend-coverMap {?}", "Premises": ["\\func precover \\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\n  | isOpen => PrecoverSpace.isOpen\n  | isCauchy => \\lam (C : Set (Set (E {\\this}))) =>\n  \\Sigma (TruncP (\\Sigma (U : Set (E {\\this})) (C U) (N : I.E) (\\Pi {n : I.E} -> N I.<= n -> U n)))\n    (\\Pi (n : I.E) -> TruncP (\\Sigma (V : Set (E {\\this})) (C V) (V n)))\n} => \\new PrecoverSpace {\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func RegPrecoverSpace \\hlevels  (X : PrecoverSpace) : CoverSpace X.E => SJoin {CoverLattice X.E} (\\lam (A : E) => A <= \\new X {})", "\\lemma regPrecoverSpace-extend-coverMap \\hlevels  {X : PrecoverSpace} {Y : CoverSpace} (f : PrecoverMap X Y) : CoverMap (RegPrecoverSpace X) Y {\n  | func => f.func\n} "]}
{"Context": ["l : X.E", "fl : IsLimit {X} {I} f l", "X : CompleteCoverSpace", "f : I.E -> X.E", "I : DirectedSet"], "Expected type": "limit {I1} {X} f = defined {X.E} l", "Expression": "defined-ext {_} {{?}} {?} {?}", "Premises": ["\\func defined \\hlevels  {X : \\Set} (x : X) : Partial X {\n  | isDefined => \\Sigma\n  | value => \\lam (_ : isDefined {\\this}) => x\n} => \\new Partial", "| E : \\Set", "\\lemma defined-ext \\hlevels  {X : \\Set} {u : Partial X} {x : X} (d : u.isDefined) (_ : u.value d = x) : u = defined {X} x ", "\\func limit \\hlevels  {I : DirectedSet} {X : CompleteCoverSpace} (f : I.E -> X.E) : Partial X.E {\n  | isDefined => IsConvergent {I} {X} f\n  | value => \\lam (fc : isDefined {\\this}) => func {completion-lift {DirectedCoverSpace I} {X} fc} (infPoint {I})\n} => \\new Partial"]}
{"Context": ["B : Ob {\\this}", "this : Pullback ", "null : apex {\\this}", "m : Mono ", "S : Ob {\\this}"], "Expected type": "IsElement {S} {B} m (pbProj1 {\\this} a) = (\\Sigma)", "Expression": "sigma-prop-ext {?}", "Premises": ["\\data IsElement \\hlevels  {A B : Ob} (Mono {SetBicat} {A} {B}) B \n  | isContained (a : A) (m.f a = b)", "\\lemma sigma-prop-ext \\plevels  \\hlevels  {A : \\Prop} (_ : A) : A = (\\Sigma) ", "| pbProj1 : Hom {D} apex x"]}
{"Context": ["x : w", "s : IsElement {S} {B} m (p1 x) = (\\Sigma)", "S : Ob", "B : Ob", "p1 : w -> B", "m : Mono "], "Expected type": "IsElement {S} {B} m (p1 x)", "Expression": "sigma-prop-ext-inv s", "Premises": ["\\data IsElement \\hlevels  {A B : Ob} (Mono {SetBicat} {A} {B}) B \n  | isContained (a : A) (m.f a = b)", "\\lemma sigma-prop-ext-inv \\plevels  \\hlevels  {A : \\Prop} (_ : A = (\\Sigma)) : A "]}
{"Context": ["f : Hom {\\this} X Y", "this : Precat (ObOver ", "Y : Ob {\\this}", "C : Precat", "X : Ob {\\this}", "x : C.Ob"], "Expected type": "id {\\this} Y \u2218 f = f", "Expression": "ext id-left", "Premises": ["| id (X : Ob) : Hom X X", "| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : Ob {\\this}", "this : Precat (ObOver ", "C : Precat", "f : Hom {\\this} X Y", "X : Ob {\\this}", "x : C.Ob"], "Expected type": "f \u2218 id {\\this} X = f", "Expression": "ext id-right", "Premises": ["| id (X : Ob) : Hom X X", "| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h : Hom {\\this} Z W", "this : Precat (ObOver ", "C : Precat", "X : Ob {\\this}", "Y : Ob {\\this}", "Z : Ob {\\this}", "g : Hom {\\this} Y Z", "f : Hom {\\this} X Y", "x : C.Ob", "W : Ob {\\this}"], "Expected type": "h \u2218 g \u2218 f = h \u2218 (g \u2218 f)", "Expression": "ext o-assoc", "Premises": ["| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["C : Cat", "a : Ob {\\this}", "b : Ob {\\this}", "x : C.Ob"], "Expected type": "Equiv {a = b} {Iso {SlicePrecat {C} x} {a} {b}} (idtoiso {SlicePrecat {C} x} {a} {b})", "Expression": "makeUnivalence (\\lam (e : Iso) => (\n  \\have e' => Func-iso {forget x} e\n  \\in (ext (isotoid e', transport_Hom_iso-left e' _ (inv (f {e}).2)), simp_coe (transport_Hom_iso-right e' _ id-right))))", "Premises": ["| Hom Ob Ob : \\Set", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f", "\\lemma transport_Hom_iso-left \\plevels obj >= hom \\hlevels  {this : Cat} (e : Iso) {z : Ob} (g : Hom e.dom z) {f1 : Hom e.cod z} (_ : g = e.f >> f1) :\n  transport {Ob} (\\lam (_x : Ob) => Hom _x z) {e.dom} {e.cod} (isotoid {e.dom} {e.cod} (\\new e {})) g = f1 ", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func idtoiso \\plevels obj >= hom \\hlevels  {this1 : Precat} {a1 b : Ob} (_ : a1 = b) : Iso {a1} {b} \n  | {this}, {a}, {b}, idp => idIso {a}", "| f : Hom {C} dom cod", "\\lemma makeUnivalence \\plevels obj >= hom \\hlevels  {C : Precat}\n  (_ : \\Pi (e : Iso {C}) -> \\Sigma (p : e.dom = e.cod) (transport {C.Ob} (C.Hom e.dom) {e.dom} {e.cod} p (C.id e.dom) = e.f))\n  {a b : C.Ob} : Equiv {a = b} {Iso {C} {a} {b}} (idtoiso {C} {a} {b}) ", "\\func isotoid \\plevels obj >= hom \\hlevels  {this : Cat} {a b : Ob} (e : Iso {a} {b}) : a = b => ret {univalence {a} {b}} e", "\\lemma forget \\plevels obj >= hom \\hlevels  {C1 : Precat} (x : C.Ob) : FaithfulFunctor (SlicePrecat {C1} x) C1 (\\lam (p0 : Ob {C {\\this}}) => p0.1) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (p0 : Hom {C {\\this}} X Y) => p0.1\n} ", "\\func Func-iso \\plevels obj >= hom \\hlevels  {this1 : Functor} (e : Iso {C}) : Iso {D} {F e.dom} {F e.cod} (Func {e.dom} {e.cod} e.f) {\n  | hinv => Func {e.cod} {e.dom} e.hinv\n} => \\new Iso {\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| id (X : Ob) : Hom X X", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\lemma transport_Hom_iso-right \\plevels obj >= hom \\hlevels  {this : Cat} (e : Iso) {z : Ob} (g : Hom z e.dom) {f1 : Hom z e.cod} (_ : g >> e.f = f1) :\n  transport {Ob} (Hom z) {e.dom} {e.cod} (isotoid {e.dom} {e.cod} (\\new e {})) g = f1 ", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)"]}
{"Context": ["null : Iso ", "null : Iso ", "arg : func {f} = func {f}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> x <= y -> (@) arg i x <= (@) arg i y) (func-<= {f}) (func-<= {f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod"]}
{"Context": ["i : I", "null : Iso ", "null : Iso ", "arg : func {f} = func {f}"], "Expected type": "PosetHom (FinOrder 0) (FinOrder 0) {\n  | func => arg @ i\n  | func-<= => {?hidden}\n}", "Expression": "\\new PosetHom {\n  | func => arg @ i\n  | func-<= => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (func-<= {f}) (func-<= {f})) i {x}\n}", "Premises": ["| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f : Hom {C} dom cod"]}
{"Context": ["arg : func {hinv} = func {hinv}", "null : Iso ", "null : Iso "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> x <= y -> (@) arg i x <= (@) arg i y) (func-<= {hinv}) (func-<= {hinv})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-<= {x y : E {Dom}} (x <= y) : func x <= func y", "| \\infix 4 <= E E : \\Prop", "| hinv : Hom {C} cod dom", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["h2 : hinv = hinv", "null : Iso ", "null : Iso ", "h1 : f = f"], "Expected type": "Path (\\lam (i : I) => h2 @ i \u2218 h1 @ i = id 0) hinv_f hinv_f", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| hinv_f : hinv \u2218 f = id {C} dom", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h2 : hinv = hinv", "null : Iso ", "null : Iso ", "h1 : f = f"], "Expected type": "Path (\\lam (i : I) => h1 @ i \u2218 h2 @ i = id 0) f_hinv f_hinv", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f_hinv : f \u2218 hinv = id {C} cod"]}
{"Context": ["h2 : hinv = hinv", "null : Iso ", "null : Iso ", "i : I", "h1 : f = f"], "Expected type": "Iso {SimplexPrecat} {0} {0} (h1 @ i) {\n  | hinv => h2 @ i\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "Expression": "\\new Iso {\n  | f => h1 @ i\n  | hinv => h2 @ i\n  | hinv_f => prop-dpi (\\lam i => ext_coe) (hinv_f {i}) (hinv_f {i}) @ i\n  | f_hinv => prop-dpi (\\lam i => ext_coe) (f_hinv {i}) (f_hinv {i}) @ i\n}", "Premises": ["| id (X : Ob) : Hom X X", "| hinv_f : hinv \u2218 f = id {C} dom", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f_hinv : f \u2218 hinv = id {C} cod"]}
{"Context": ["null : A {\\this}", "C : Precat", "this : Embedding ", "null : A {\\this}", "D : Cat"], "Expected type": "Retraction {a = a1} {f {\\this} a = f {\\this} a1} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {a} {a1}) {\n  | sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => \\new VPresheaf D C (p @ i))\n  | f_sec => idpe {F = F}\n}", "Expression": "\\new Retraction {\n  | sec => \\lam p => ext p\n  | f_sec => idpe\n}", "Premises": ["| F : Functor (op {C}) D", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| f A : B", "| B : \\Type", "| A : \\Type", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func idpe {A : \\Type} (a : A) : a = a => idp {A} {a}"]}
{"Context": ["C : Precat", "D : Cat"], "Expected type": "Embedding {VPresheaf D C} {Ob} (\\lam (P : A {\\this}) => P.F) {\n  | isEmb => \\lam (a : A {\\this}) (a1 : A {\\this}) =>\n  \\new Retraction {a = a1} {f {\\this} a = f {\\this} a1} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {a} {a1}) {\n    | sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => \\new VPresheaf D C (p @ i))\n    | f_sec => idpe {F = F}\n  }\n}", "Expression": "\\new Embedding {\n  | f => \\lam P => P\n  | isEmb => \\lam _ _ => \\new Retraction {\n    | sec => \\lam p => ext p\n    | f_sec => idpe\n  }\n}", "Premises": ["| F : Functor (op {C}) D", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| f A : B", "| B : \\Type", "| Ob : \\hType", "| A : \\Type", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func idpe {A : \\Type} (a : A) : a = a => idp {A} {a}"]}
{"Context": ["J_g_x<=g_sg : \\Sigma (J : \\Set) (g : J -> ObOver {restrict {L} a} x) (isBasicCover x {J} g) (\\Pi (j : J) -> s.S {(g j).1} (g j).2)", "x : Ob {C {\\this}}", "j : J", "arg : (\n  \\have _ => idp {L.E} {(p0.2 j).1.1}\n  \\in ((p0.2 j).1.1, (p0.2 j).1.2)) = (\n  \\have _ => idp {L.E} {(p0.2 j).1.1}\n  \\in ((p0.2 j).1.1, (p0.2 j).2 L.<=\u2218 x.2))", "L : Locale"], "Expected type": "Path (\\lam (i : I) => (arg @ i).1 L.<= x.1) (g j).2 (g j).2", "Expression": "prop-dpi (\\lam i => ext_coe) (g j).2 (((g j).1.1, (g j).2 L.<=\u2218 x.2), (g j).2).2", "Premises": ["| \\infix 4 <= E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["a : L.E", "J_g_x<=g_sg : \\Sigma (J : \\Set) (g : J -> ObOver {restrict {L} a} x) (isBasicCover x {J} g) (\\Pi (j : J) -> s.S {(g j).1} (g j).2)", "x : Ob {C {\\this}}", "p0 : \\Sigma (J : \\Set) (g : J -> ObOver {restrict {L} a} x) (isBasicCover x {J} g) (\\Pi (j : J) -> s.S {(g j).1} (g j).2)", "j : J", "s : Sieve ", "L : Locale"], "Expected type": "s.S {((g j).1.1, (g j).2 L.<=\u2218 x.2)} (g j).2", "Expression": "transport {ObOver {restrict {L} a} x} (\\lam p => s {p.1} p.2) {g j} {(_, _)} (ext (ext idp)) {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| \\infix 4 <= E E : \\Prop", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| S {y : Ob {C}} (Hom {C} y x) : \\Prop", "\\type ObOver \\plevels obj >= hom \\hlevels  {C : Precat} (x : C.Ob) : \\hType => \\Sigma (y : C.Ob) (C.Hom y x)", "\\func restrict \\hlevels  {this2 : Locale} (a : E) : Locale (\\Sigma (b : E) (b <= a)) {\n  | <= => \\lam (p : E {\\this}) (q : E {\\this}) => p.1 <= q.1\n  | meet => \\lam (p : E {\\this}) (q : E {\\this}) => (p.1 \u2227 q.1, meet-left {p.1} {q.1} <=\u2218 p.2)\n  | top => (a, <=-refl {a})\n  | Join => \\lam {J : \\Set} (g : J -> E {\\this}) =>\n    (Join {J} (\\lam (j : J) => (g j).1), Join-univ {J} {\\lam (j : J) => (g j).1} {a} (\\lam (j : J) => (g j).2))\n} => \\new Locale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n}", "| Ob : \\hType"]}
{"Context": ["a : L.E", "x : Ob {C {\\this}}", "h1 : (\\lam (j : \\Sigma (y : ObOver {L} x.1) (s.S {(y.1, y.2 L.<=\u2218 x.2)} y.2)) => c.coneMap (\n  \\have _ => idp {ObOver {L} x.1} {(j.1.1, j.1.2)}\n  \\in ((j.1.1, j.1.2),\n        transport {j.1.1 L.<= a} (\\lam (x : j.1.1 L.<= a) => s.S {(j.1.1, x)} j.1.2) {j.1.2 L.<=\u2218 x.2} {j.1.2 L.<=\u2218 x.2}\n          (prop-pi {j.1.1 L.<= a} {j.1.2 L.<=\u2218 x.2} {j.1.2 L.<=\u2218 x.2}) j.2))) = (\\lam (j : \\Sigma (y : ObOver {L} x.1) (s.S {(y.1, y.2 L.<=\u2218 x.2)} y.2)) => c.coneMap (\n  \\have _ => idp {ObOver {L} x.1} {(j.1.1, j.1.2)}\n  \\in ((j.1.1, j.1.2), j.2)))", "S : VSheaf ", "s : Sieve ", "this : QEquiv ", "z : Ob {D {\\this}}", "L : Locale", "c : A {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob} -> \\Pi (h : Hom j j') -> Func {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {ret {\\this} (f {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| ret B : A", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["a : L.E", "x : Ob {C {\\this}}", "s : Sieve ", "S : VSheaf ", "this : QEquiv ", "z : Ob {D {\\this}}", "c : B {\\this}", "h1 : (\\lam (j : \\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2)) => c.coneMap (\n  \\have _ => path (\\lam (i : I) => (\n          \\have arg => path (\\lam (i : I) => (\n                  \\have arg => idp {L.E} {j.1.1.1}\n                  \\in (arg @ i, prop-dpi (\\lam (i : I) => arg @ i L.<= a) (j.1.2 L.<=\u2218 x.2) j.1.1.2 @ i)))\n          \\in (arg @ i, prop-dpi (\\lam (i : I) => (arg @ i).1 L.<= x.1) j.1.2 j.1.2 @ i)))\n  \\in (\n        \\have _ => path (\\lam (i : I) => (\n                \\have arg => idp {L.E} {j.1.1.1}\n                \\in (arg @ i, prop-dpi (\\lam (i : I) => arg @ i L.<= a) (j.1.2 L.<=\u2218 x.2) j.1.1.2 @ i)))\n        \\in (\n              \\have _ => idp {L.E} {j.1.1.1}\n              \\in (j.1.1.1, j.1.2 L.<=\u2218 x.2), j.1.2),\n        transport {j.1.1.1 L.<= a} (\\lam (x : j.1.1.1 L.<= a) => s.S {(j.1.1.1, x)} j.1.2) {j.1.1.2} {j.1.2 L.<=\u2218 x.2}\n          (prop-pi {j.1.1.1 L.<= a} {j.1.1.2} {j.1.2 L.<=\u2218 x.2}) j.2))) = (\\lam (j : \\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2)) => c.coneMap (\n  \\have _ => path (\\lam (i : I) => (\n          \\have arg => path (\\lam (i : I) => (\n                  \\have arg => idp {L.E} {j.1.1.1}\n                  \\in (arg @ i, prop-dpi (\\lam (i : I) => arg @ i L.<= a) (j.1.2 L.<=\u2218 x.2) j.1.1.2 @ i)))\n          \\in (arg @ i, prop-dpi (\\lam (i : I) => (arg @ i).1 L.<= x.1) j.1.2 j.1.2 @ i)))\n  \\in (\n        \\have _ => path (\\lam (i : I) => (\n                \\have arg => idp {L.E} {j.1.1.1}\n                \\in (arg @ i, prop-dpi (\\lam (i : I) => arg @ i L.<= a) (j.1.2 L.<=\u2218 x.2) j.1.1.2 @ i)))\n        \\in (\n              \\have _ => idp {L.E} {j.1.1.1}\n              \\in (j.1.1.1, j.1.1.2), j.1.2), j.2)))", "L : Locale"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob} -> \\Pi (h : Hom j j') -> Func {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {\\this} (sec {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| sec B : A"]}
{"Context": ["h2 : Path (\\lam (i : I) => \\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)) Func (Func {S.F})", "L : Locale", "S : VSheaf ", "h1 : Functor.F {VPresheaf.F {direct_image_locale {L} {L} (id L) S}} = Functor.F {S.F}"], "Expected type": "Path (\\lam (i : I) => \\Pi {X : Ob} -> (@) h2 i {X} {X} (id X) = id {S.D} ((@) h1 i X))\n  (Func-id {F {direct_image_locale {L} {L} (id L) S}}) (Func-id {S.F})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| id (X : Ob) : Hom X X", "| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)", "| F : Functor (op {C}) D", "| D : Cat", "\\lemma direct_image_locale \\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\n  | C => L\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) ", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : Path (\\lam (i : I) => \\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)) Func (Func {S.F})", "L : Locale", "S : VSheaf ", "h1 : Functor.F {VPresheaf.F {direct_image_locale {L} {L} (id L) S}} = Functor.F {S.F}"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y Z : Ob} ->\n  \\Pi {g : Hom Y Z} -> \\Pi {f : Hom X Y} -> (@) h2 i {X} {Z} (g \u2218 f) = (@) h2 i {Y} {Z} g \u2218 (@) h2 i {X} {Y} f)\n  (Func-o {F {direct_image_locale {L} {L} (id L) S}}) (Func-o {S.F})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| id (X : Ob) : Hom X X", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f", "\\lemma direct_image_locale \\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\n  | C => L\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) ", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["L : Locale", "arg : (\n  \\have arg => (idp {L.E -> Ob {S.D}} {\\lam (X : L.E) => Functor.F {S.F} (func {id L} X)},\n          path (\\lam (i : I) {X : L.E} {Y : L.E} (h : Hom X Y) =>\n            pmap {Hom {C {S.F}} X Y} {Hom {S.D} (Functor.F {S.F} X) (Functor.F {S.F} Y)} (Func {S.F} {X} {Y}) {Func {X} {Y} h} {h}\n              (prop-pi {Y L.<= X} {Func {X} {Y} h} {h}) @ i))\n    \\in \n          \\let | h1 => arg.1\n               | _ => pathOver {\\lam (i : I) => \\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)} {Func} {Func {S.F}} arg.2\n          \\in \\new Functor (Precat.op {L}) S.D (Functor.F {VPresheaf.F {direct_image_locale {L} {L} (id L) S}}) {\n                | Func => Func\n                | Func-id => {?hidden}\n                | Func-o => {?hidden}\n              }) = (\n    \\have arg => (idp {L.E -> Ob {S.D}} {\\lam (X : L.E) => Functor.F {S.F} (func {id L} X)},\n            path (\\lam (i : I) {X : L.E} {Y : L.E} (h : Hom X Y) =>\n              pmap {Hom {C {S.F}} X Y} {Hom {S.D} (Functor.F {S.F} X) (Functor.F {S.F} Y)} (Func {S.F} {X} {Y}) {Func {X} {Y} h} {h}\n                (prop-pi {Y L.<= X} {Func {X} {Y} h} {h}) @ i))\n      \\in \n            \\let | h1 => arg.1\n                 | _ => pathOver {\\lam (i : I) => \\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)} {Func} {Func {S.F}} arg.2\n            \\in \\new Functor (Precat.op {L}) S.D (Functor.F {S.F}) {\n                  | Func => Func {S.F}\n                  | Func-id => {?hidden}\n                  | Func-o => {?hidden}\n                })", "S : VSheaf ", "i : I"], "Expected type": "VSheaf S.D L (arg @ i) {\n  | isSheaf => {?hidden}\n}", "Expression": "\\new VSheaf {\n  | F => arg @ i\n  | isSheaf => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (isSheaf {direct_image_locale {L} {L} (id L) S}) (isSheaf {\\new S {}})) i {x}\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n  (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\n  (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\n    (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\n  | coneMap => \\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\n  | coneCoh => {?hidden}\n}", "| S {y : Ob {C}} (Hom {C} y x) : \\Prop", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| F (Ob {C}) : Ob {D}", "\\lemma direct_image_locale \\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\n  | C => L\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) ", "| id (X : Ob) : Hom X X", "| D : Cat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["null : A {\\this}", "null : A {\\this}", "i : I", "p : B {\\this}", "D : Cat", "C : Site"], "Expected type": "VSheaf D C1 (VPresheaf.F {p @ i}) {\n  | isSheaf => {?hidden}\n}", "Expression": "\\new VSheaf {\n  | F => F {p @ i}\n  | isSheaf => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (isSheaf {a}) (isSheaf {a})) i {x}\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n  (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\n  (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\n    (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\n  | coneMap => \\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\n  | coneCoh => {?hidden}\n}", "| C : Precat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| S {y : Ob {C}} (Hom {C} y x) : \\Prop"]}
{"Context": ["null : A {\\this}", "null : A {\\this}", "D : Cat", "C : Site", "this : Embedding "], "Expected type": "Retraction {a = a1} {f {\\this} a = f {\\this} a1} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {a} {a1}) {\n  | sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => \\new VSheaf D C1 (VPresheaf.F {p @ i}) {\n    | isSheaf => {?hidden}\n  })\n  | f_sec => idpe {a = a1}\n}", "Expression": "\\new Retraction {\n  | sec => \\lam p => ext (VSheaf {\n    | VPresheaf => p\n  })\n  | f_sec => idpe\n}", "Premises": ["| F : Functor (op {C}) D", "| A : \\Type", "\\func idpe {A : \\Type} (a : A) : a = a => idp {A} {a}", "| isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n  (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\n  (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\n    (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\n  | coneMap => \\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\n  | coneCoh => {?hidden}\n}", "| C : Precat", "| B : \\Type", "| S {y : Ob {C}} (Hom {C} y x) : \\Prop", "| F (Ob {C}) : Ob {D}", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func map \\plevels obj >= hom \\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\n  | coneMap => \\lam (j : Ob {J {\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\n} => \\new Cone {\n  | coneCoh => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| f A : B"]}
{"Context": ["D : Cat", "C : Site"], "Expected type": "Embedding {VSheaf D C1} {Ob} (\\lam (P : A {\\this}) => P) {\n  | isEmb => \\lam (a : A {\\this}) (a1 : A {\\this}) =>\n  \\new Retraction {a = a1} {f {\\this} a = f {\\this} a1} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {a} {a1}) {\n    | sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => \\new VSheaf D C1 (VPresheaf.F {p @ i}) {\n      | isSheaf => {?hidden}\n    })\n    | f_sec => idpe {a = a1}\n  }\n}", "Expression": "\\new Embedding {\n  | f => \\lam P => P\n  | isEmb => \\lam _ _ => \\new Retraction {\n    | sec => \\lam p => ext (VSheaf {\n      | VPresheaf => p\n    })\n    | f_sec => idpe\n  }\n}", "Premises": ["| F : Functor (op {C}) D", "| A : \\Type", "\\func idpe {A : \\Type} (a : A) : a = a => idp {A} {a}", "| isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n  (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\n  (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\n    (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\n  | coneMap => \\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\n  | coneCoh => {?hidden}\n}", "| C : Precat", "| B : \\Type", "| S {y : Ob {C}} (Hom {C} y x) : \\Prop", "| F (Ob {C}) : Ob {D}", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func map \\plevels obj >= hom \\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\n  | coneMap => \\lam (j : Ob {J {\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\n} => \\new Cone {\n  | coneCoh => {?hidden}\n}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| f A : B"]}
{"Context": ["this : Limit ", "h1 : coneMap = c'.coneMap", "this : QEquiv ", "z : Ob {D {\\this}}", "c' : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob {J {\\this}}} -> \\Pi (h : Hom {J {\\this}} j j') -> Func {G {\\this}} {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {\\this} (sec {\\this} c')}) c'.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| J : Precat", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| sec B : A"]}
{"Context": ["F : Functor (op ", "C : SiteWithBasis", "g : J -> Ob", "x : C.Ob", "g : A {\\this}", "J : \\Set", "Z : Ob"], "Expected type": "MatchingFamily {C1} {SetCat} {F} x1 {J1} g1 Z {\n  | family => \\lam (j : J {\\this}) (z : z {\\this}) => family {g2 z} j\n  | isMatching => {?hidden}\n}", "Expression": "\\new MatchingFamily {\n  | family => \\lam j z => family {g z} j\n  | isMatching => \\lam j j' => ext (\\lam z => isMatching j j')\n}", "Premises": ["| isMatching (j j' : J) : Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\n  (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j) = Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\n  (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j')", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| family (j : J) : Functor.F {sheafOnSiteWithBasis.MatchingFamily.F} (g j).1", "| J : \\Set", "| g J : Ob", "| x : Ob {C}", "| C : SiteWithBasis", "| z : Ob {D}"]}
{"Context": ["h : Hom {J {\\this}} j j'", "F : VSheaf D (framePresSite P)", "j' : Ob {J {\\this}}", "P : FramePres", "j : Ob {J {\\this}}", "D : CompleteCat"], "Expected type": "extend-proj {P} {D} {F} j'.1.1 D.\u2218 Func {embed {P} j.1.1} {embed {P} j'.1.1} (\\lam {x : P.E} (p0 : (embed {P} j'.1.1).1 x) =>\n  cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1.1} {\\Sigma} {\\lam (_ : \\Sigma) => j'.1.1} p0 (\\lam (_ : \\Sigma) => h.1)) = Func {F.F} {j.1.1} {j'.1.1} h.1 D.\u2218 extend-proj {P} {D} {F} j.1.1", "Expression": "extend-proj-nat h.1 {?}", "Premises": ["\\func embed \\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\Sigma} (\\lam (_ : \\Sigma) => x)", "\\func extend \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} :\nFunctor (op {PresentedFrame P}) D (\\lam (b : Ob {C {\\this}}) => apex) {\n  | Func => \\lam {a : Ob {C {\\this}}} {b : Ob {C {\\this}}} (b<=a : Hom {C {\\this}} a b) => limMap {apex} (cone {P} {D} {F} {a} {b} b<=a)\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma extend-proj-nat \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {y z : P.E} (h : Cover1 {P} y z)\n  (h' : embed {P} y <= embed {P} z) :\n  extend-proj {P} {D} {F} y D.\u2218 Func {embed {P} z} {embed {P} y} h' = Func {F.F} {z} {y} h D.\u2218 extend-proj {P} {D} {F} z ", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| E : \\Set", "cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)", "\\func extend-proj \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (y : P.E) :\n  D.Hom (Functor.F (embed {P} y)) (Functor.F {F.F} y) \n=> coneMap {D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= embed {P} y)}\n  (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= embed {P} y)) => t.1)}} (limFunctor {P} {D} {F} (embed {P} y))}\n  (y, \\lam {x : P.E} (d : (embed {P} y).1 x) => d)"]}
{"Context": ["P : FramePres", "F : VSheaf D (framePresSite P)", "D : CompleteCat"], "Expected type": "Functor (op {PresentedFrame P}) D (\\lam (b : Ob {C {\\this}}) => apex) {\n  | Func => \\lam {a : Ob {C {\\this}}} {b : Ob {C {\\this}}} (b<=a : Hom {C {\\this}} a b) => limMap {apex} (cone {P} {D} {F} {a} {b} b<=a)\n}", "Expression": "extend {P} {D} {F}", "Premises": ["\\func extend \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} :\nFunctor (op {PresentedFrame P}) D (\\lam (b : Ob {C {\\this}}) => apex) {\n  | Func => \\lam {a : Ob {C {\\this}}} {b : Ob {C {\\this}}} (b<=a : Hom {C {\\this}} a b) => limMap {apex} (cone {P} {D} {F} {a} {b} b<=a)\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| apex : Ob {D}", "| C : Precat", "\\func lim \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\nLimit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\n  {D} (limFunctor {P} {D} {F} b) \n=> D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\n  (limFunctor {P} {D} {F} b)", "| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex", "\\func cone \\hlevels  {P : FramePres} {D : CompleteCat} {F1 : VSheaf D (framePresSite P)} {a b : E} (b<=a : b <= a) :\nCone {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\n  {D} (limFunctor {P} {D} {F1} b) apex {\n  | coneMap => \\lam (p0 : Ob {J {\\this}}) =>\n  coneMap {D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= a)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= a)) => t.1)}}\n    (limFunctor {P} {D} {F1} a)} (p0.1, p0.2 <=\u2218 b<=a)\n} => \\new Cone {\n  | coneCoh => {?hidden}\n}", "| Ob : \\hType"]}
{"Context": ["h' : embed {P} y <= embed {P} z", "P : FramePres", "z : P.E", "F : VSheaf D (framePresSite P)", "D : CompleteCat", "y : P.E"], "Expected type": "extend-proj {P} {D} {F} y D.\u2218 Func {embed {P} z} {embed {P} y} h' = coneMap {D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= embed {P} z)}\n  (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= embed {P} z)) => t.1)}} (limFunctor {P} {D} {F} (embed {P} z))} (y, h')", "Expression": "extend-proj-nat' {P} {D} {F} h'", "Premises": ["\\func embed \\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\Sigma} (\\lam (_ : \\Sigma) => x)", "\\func extend \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} :\nFunctor (op {PresentedFrame P}) D (\\lam (b : Ob {C {\\this}}) => apex) {\n  | Func => \\lam {a : Ob {C {\\this}}} {b : Ob {C {\\this}}} (b<=a : Hom {C {\\this}} a b) => limMap {apex} (cone {P} {D} {F} {a} {b} b<=a)\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "\\func framePresSite \\hlevels  (P : FramePres) : SiteWithBasis P.E {\n  | Hom => Cover1 {P}\n  | id => <=-refl\n  | o => \\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\n  | pullback => \\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\n    | pbProj1 => cover-proj1 {P} {apex {\\this}} {\\Sigma} {\\lam (_ : \\Sigma) => x {\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\Sigma} {\\lam (_ : \\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\n    | pbCoh => {?hidden}\n    | pbMap => \\lam {w : Ob {D {\\this}}} (p1 : Hom {D {\\this}} w (x {\\this})) (p2 : Hom {D {\\this}} w (y {\\this}))\n      (_ : f {\\this} \u2218 p1 = g {\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\n    | pbBeta1 => {?hidden}\n    | pbBeta2 => {?hidden}\n    | pbEta => {?hidden}\n  }\n  | isBasicCover => \\lam (x : Ob {\\this}) {J : \\Set} (g : J -> Ob) =>\n  TruncP (\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\n    (\\Pi (j : J) -> \\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\n} => \\new SiteWithBasis {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n  | basicCover-stable => {?hidden}\n}", "| \\infix 4 <= E E : \\Prop", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func limFunctor \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\nFunctor (Precat.op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})\n  D (\\lam (X : Ob {C {\\this}}) => Functor.F {F.F} (Functor.F X)) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (f : Hom {C {\\this}} X Y) => Func {F.F} {Functor.F X} {Functor.F Y} (Func {X} {Y} f)\n} => Comp {Precat.op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\n  {Precat.op {framePresSite P}} {D} F.F\n  (Functor.op {embedding {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})", "\\func subPrecat \\plevels obj >= hom \\hlevels  {C : Precat} {X : \\hType} (f : X -> C.Ob) : Precat X {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => C.Hom (f x) (f y)\n  | id => \\lam (x : Ob {\\this}) => C.id (f x)\n  | o => \\lam {X Y Z : Ob {\\this}} => (C.\u2218)\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "\\lemma extend-proj-nat' \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {y : P.E} {V : E} (h' : embed {P} y <= V) :\nextend-proj {P} {D} {F} y D.\u2218 Func {V} {embed {P} y} h' = coneMap {D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= V)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= V)) => t.1)}}\n  (limFunctor {P} {D} {F} V)} (y, h') ", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "| limit {J : Precat} (G : Functor J \\this) : Limit {J} G", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| E : \\Set", "\\func lim \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\nLimit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\n  {D} (limFunctor {P} {D} {F} b) \n=> D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= b)} (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\n  (limFunctor {P} {D} {F} b)", "\\func extend-proj \\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (y : P.E) :\n  D.Hom (Functor.F (embed {P} y)) (Functor.F {F.F} y) \n=> coneMap {D.limit {op {subPrecat {framePresSite P} {\\Sigma (x : P.E) (embed {P} x <= embed {P} y)}\n  (\\lam (t : \\Sigma (x : P.E) (embed {P} x <= embed {P} y)) => t.1)}} (limFunctor {P} {D} {F} (embed {P} y))}\n  (y, \\lam {x : P.E} (d : (embed {P} y).1 x) => d)"]}
{"Context": ["h1 : coneMap = c.coneMap", "C : Site", "a : Ob {C {\\this}}", "y_p : \\Sigma (y : Functor.F {F.F} a) (e.trans a y = limMap {G.isSheaf {a} {s} a<s} {\\Sigma} c' ())", "s : Sieve ", "F : Presheaf C", "c : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob} -> \\Pi (h : Hom j j') -> Func {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j') coneCoh c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "\\func cone \\plevels obj >= hom \\hlevels  {this2 : Presieve} :\nCone {Precat.op {subPrecat {SlicePrecat {C} x} {\\Sigma (y : ObOver {C} x) (S {y.1} y.2)} (\\lam (p : \\Sigma (y : ObOver {C} x) (S {y.1} y.2)) => p.1)}}\n  {Precat.op {C}} (Functor.op {diagram}) x {\n  | coneMap => \\lam (p0 : Ob {J {\\this}}) => p0.1.2\n} => \\new Cone {\n  | coneCoh => {?hidden}\n}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : Limit ", "D : CompleteCat", "j : Ob {J {\\this}}", "j' : Ob {J {\\this}}", "C : Precat", "h1 : (\\lam (X : C.Ob) =>\n  Func {G {D.limit {J} (functor-at-point {C} {D1} {J} {G1} X)}} {j} {j'} h \u2218 coneMap {D.limit {J} (functor-at-point {C} {D1} {J} {G1} X)} j) = (\\lam (X : C.Ob) => coneMap {D.limit {J} (functor-at-point {C} {D1} {J} {G1} X)} j')", "h : Hom {J {\\this}} j j'"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} -> \\Pi (f : Hom X Y) ->\n  (@) h1 i Y D.\u2218 Func {VPresheaf.F {apex {\\this}}} {X} {Y} f = Func {VPresheaf.F {Functor.F {G {\\this}} j'}} {X} {Y} f D.\u2218 (@) h1 i X)\n  (natural {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (natural {coneMap {\\this} j'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "| D : Precat", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["this : Limit ", "D : CompleteCat", "z-cone : Cone ", "C : Precat", "null : Ob {J {\\this}}", "z : Ob {D {\\this}}", "h1 : (\\lam (X : C.Ob) => coneMap o D.\u2218 limMap {Functor.F {z.F} X} (cone-at-point {C} {D} {J} {G} X z z-cone)) = trans {z-cone.coneMap o}"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} -> \\Pi (f : Hom X Y) ->\n  (@) h1 i Y D.\u2218 Func {z.F} {X} {Y} f = Func {VPresheaf.F {Functor.F {G {\\this}} o}} {X} {Y} f D.\u2218 (@) h1 i X)\n  (natural {coneMap {\\this} o \u2218 limMap {\\this} {z} z-cone}) (natural {z-cone.coneMap o})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "| D : Precat", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex"]}
{"Context": ["this : Limit ", "D : CompleteCat", "z : Ob {D {\\this}}", "h1 : f.trans = g.trans", "C : Precat", "g : Hom {D {\\this}} z (apex {\\this})", "f : Hom {D {\\this}} z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} ->\n  \\Pi (f : Hom X Y) -> (@) h1 i Y D.\u2218 Func {z.F} {X} {Y} f = Func {VPresheaf.F {apex {\\this}}} {X} {Y} f D.\u2218 (@) h1 i X)\n  f.natural g.natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Limit ", "D : CompleteCat", "z : Ob {D {\\this}}", "h1 : f.trans = g.trans", "arg : \\Pi (X : C.Ob) -> f.trans X = g.trans X", "C : Precat", "g : Hom {D {\\this}} z (apex {\\this})", "i : I", "f : Hom {D {\\this}} z (apex {\\this})"], "Expected type": "NatTrans {op {C1}} {D} z.F (VPresheaf.F {apex {\\this}}) {\n  | trans => \\lam (X : Ob {C {\\this}}) => arg X @ i\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam X => arg X @ i\n  | natural => \\lam {X} => (@) (prop-dpi (\\lam i => ext_coe) (natural {f}) (natural {g})) i {X}\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| apex : Ob {D}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["c : C.Ob", "C : Precat", "this : VPresheaf SetCat C\n  (\\new Functor (op "], "Expected type": "Functor (op {VPresheaf.C {\\this}}) (VPresheaf.D {\\this}) (\\lam (x : Ob {Functor.C {\\this}}) => C.Hom x c) {\n  | Func => \\lam {X Y : Ob {Functor.C {\\this}}} (f : Hom {Functor.C {\\this}} X Y) (g : F {\\this} X) => g C.\u2218 f\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "Expression": "\\new Functor {\n  | F => \\lam x => Hom x c\n  | Func => \\lam f g => g \u2218 f\n  | Func-id => exts (\\lam _ => id-right)\n  | Func-o => exts (\\lam _ => inv o-assoc)\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f", "| Ob : \\hType", "| C : Precat", "| D : Cat", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| C : Precat", "| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)", "| D : Precat"]}
{"Context": ["c : C.Ob", "C : Precat"], "Expected type": "VPresheaf SetCat C\n  (\\new Functor (op {VPresheaf.C {\\this}}) (VPresheaf.D {\\this}) (\\lam (x : Ob {Functor.C {\\this}}) => C.Hom x c) {\n    | Func => \\lam {X Y : Ob {Functor.C {\\this}}} (f : Hom {Functor.C {\\this}} X Y) (g : F {\\this} X) => g C.\u2218 f\n    | Func-id => {?hidden}\n    | Func-o => {?hidden}\n  })", "Expression": "\\new VPresheaf {\n  | F => \\new Functor {\n    | F => \\lam x => Hom x c\n    | Func => \\lam f g => g \u2218 f\n    | Func-id => exts (\\lam _ => id-right)\n    | Func-o => exts (\\lam _ => inv o-assoc)\n  }\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f", "| Ob : \\hType", "| C : Precat", "| D : Cat", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| C : Precat", "| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)", "| D : Precat"]}
{"Context": ["C : Precat", "this : Functor C (PresheafCat C) (hom-presheaf ", "X : Ob {C {\\this}}", "f : Hom {C {\\this}} X Y", "Y : Ob {C {\\this}}"], "Expected type": "NatTrans {op {C1}} {SetCat} (VPresheaf.F {Functor.F {\\this} X}) (VPresheaf.F {Functor.F {\\this} Y}) {\n  | trans => \\lam (o : Ob {C {\\this}}) => (C.\u2218) f\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam _ => \\lam g => f \u2218 g\n  | natural => \\lam _ => exts (\\lam _ => inv $ o-assoc)\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| C : Precat", "| Ob : \\hType", "| F : Functor C D", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)"]}
{"Context": ["C : Precat", "X : Ob {C {\\this}}", "this : Functor C (PresheafCat C) (hom-presheaf ", "h1 : (\\lam (X1 : C.Ob) => (C.\u2218) (C.id X)) = (\\lam (X1 : C.Ob) (h : C.Hom X1 X) => h)"], "Expected type": "Path (\\lam (i : I) => \\Pi {X1 Y : Ob} -> \\Pi (f : Hom X1 Y) ->\n  (@) h1 i Y \u2218 Func {VPresheaf.F {Functor.F {\\this} X}} {X1} {Y} f = Func {VPresheaf.F {Functor.F {\\this} X}} {X1} {Y} f \u2218 (@) h1 i X1)\n  (natural {Func {\\this} {X} {X} (id {C {\\this}} X)}) (natural {id {D {\\this}} (Functor.F {\\this} X)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| id (X : Ob) : Hom X X", "| C : Precat", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| D : Precat"]}
{"Context": ["C : Precat", "g : Hom {C {\\this}} Y Z", "Y : Ob {C {\\this}}", "this : Functor C (PresheafCat C) (hom-presheaf ", "Z : Ob {C {\\this}}", "f : Hom {C {\\this}} X Y", "h1 : (\\lam (X1 : C.Ob) => (C.\u2218) (g C.\u2218 f)) = (\\lam (X1 : C.Ob) (h : C.Hom X1 X) => g C.\u2218 (f C.\u2218 h))", "X : Ob {C {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {X1 Y : Ob} -> \\Pi (f : Hom X1 Y) ->\n  (@) h1 i Y \u2218 Func {VPresheaf.F {Functor.F {\\this} X}} {X1} {Y} f = Func {VPresheaf.F {Functor.F {\\this} Z}} {X1} {Y} f \u2218 (@) h1 i X1)\n  (natural {Func {\\this} {X} {Z} (g \u2218 f)}) (natural {Func {\\this} {Y} {Z} g \u2218 Func {\\this} {X} {Y} f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["p : B {\\this}", "C : Precat", "F : Ob", "A : C.Ob"], "Expected type": "NatTrans {op {C1}} {SetCat} (VPresheaf.F {Functor.F A}) F.F {\n  | trans => \\lam (o : Ob {C {\\this}}) (f : Functor.F {NatTrans.F {\\this}} o) => Func {F.F} {A} {o} f p\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam _ f => Func {F} f p\n  | natural => \\lam _ => exts (\\lam _ => unfold $ rewrite (Func-o {F}) idp)\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| C : Precat", "| Ob : \\hType", "| F : Functor C D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)"]}
{"Context": ["h1 : trans {ret {\\this} (nf.trans A (C.id A))} = nf.trans", "nf : A {\\this}", "C : Precat", "this : QEquiv ", "F : Ob", "A : C.Ob"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} ->\n  \\Pi (f : Hom X Y) -> (@) h1 i Y \u2218 Func {VPresheaf.F {Functor.F A}} {X} {Y} f = Func {F.F} {X} {Y} f \u2218 (@) h1 i X)\n  (natural {ret {\\this} (f {\\this} nf)}) nf.natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| ret B : A", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["this : Functor (Precategory-of-elements ", "P : Ob", "C : Precat", "X : Ob {C {\\this}}", "F : Ob"], "Expected type": "Func {\\this} {X} {X} (id {C {\\this}} X) = id {D {\\this}} (F {\\this} X)", "Expression": "exts idp", "Premises": ["| id (X : Ob) : Hom X X", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| C : Precat", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| D : Precat"]}
{"Context": ["this : Functor (Precategory-of-elements ", "Z : Ob {C {\\this}}", "P : Ob", "C : Precat", "X : Ob {C {\\this}}", "f : Hom {C {\\this}} X Y", "Y : Ob {C {\\this}}", "F : Ob", "g : Hom {C {\\this}} Y Z"], "Expected type": "Func {\\this} {X} {Z} (g \u2218 f) = Func {\\this} {Y} {Z} g \u2218 Func {\\this} {X} {Y} f", "Expression": "exts idp", "Premises": ["| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["C : Precat", "p0 : Ob {J {\\this}}", "P : Ob", "this : Limit "], "Expected type": "NatTrans {op {C1}} {SetCat} (VPresheaf.F {Functor.F {Cone.G {\\this}} p0}) (VPresheaf.F {apex {\\this}}) {\n  | trans => \\lam (o : Ob {C {\\this}}) (h : Functor.F {NatTrans.F {\\this}} o) => Func {P.F} {p0.1} {o} h p0.2\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam _ h => Func {P} h p\n  | natural => \\lam _ => exts (\\lam _ => unfold $ rewrite (Func-o {P}) idp)\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| apex : Ob {D}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| G : Functor C D", "| C : Precat", "| Ob : \\hType", "| F : Functor C D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| G : Functor J D"]}
{"Context": ["p1 : Ob {J {\\this}}", "C : Precat", "h1 : (\\lam (X : C.Ob) => (\\lam (h : Functor.F {VPresheaf.F {Functor.F p0}} X) => Func {P.F} {p0.1} {X} h p0.2) \u2218 trans {Func {p0} {p1} p2} X) = (\\lam (X : C.Ob) (h : C.Hom X p1.1) => Func {P.F} {p1.1} {X} h p1.2)", "this : Limit ", "p0 : Ob {J {\\this}}", "p2 : Hom {J {\\this}} p0 p1"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} -> \\Pi (f : Hom X Y) ->\n  (@) h1 i Y \u2218 Func {VPresheaf.F {Functor.F {G {\\this}} p1}} {X} {Y} f = Func {VPresheaf.F {apex {\\this}}} {X} {Y} f \u2218 (@) h1 i X)\n  (natural {Func {G {\\this}} {p0} {p1} p2 \u2218 coneMap {\\this} p0}) (natural {coneMap {\\this} p1})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["p1 : Ob {J {\\this}}", "C : Precat", "P : Ob", "this : Limit ", "p0 : Ob {J {\\this}}", "p2 : Hom {J {\\this}} p0 p1"], "Expected type": "Func {G {\\this}} {p0} {p1} p2 \u2218 coneMap {\\this} p0 = coneMap {\\this} p1", "Expression": "\n  \\let | (c, p) => p0\n       | (c', p') => p1\n       | (f, eq) => p2\n  \\in exts (\\lam _ => exts (\\lam _ => unfold $ rewrite eq (unfold $ rewrite (Func-o {P}) idp)))", "Premises": ["| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)", "| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| G : Functor J D", "| F (Ob {C}) : Ob {D}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)"]}
{"Context": ["g : Hom {D {\\this}} z (apex {\\this})", "z : Ob {D {\\this}}", "h1 : f.trans = g.trans", "C : Precat", "this : Limit ", "f : Hom {D {\\this}} z (apex {\\this})"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} ->\n  \\Pi (f : Hom X Y) -> (@) h1 i Y \u2218 Func {VPresheaf.F {apex {\\this}}} {X} {Y} f = Func {z.F} {X} {Y} f \u2218 (@) h1 i X)\n  f.natural g.natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| apex : Ob {D}", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["g : Hom {D {\\this}} z (apex {\\this})", "z : Ob {D {\\this}}", "arg : \\Pi (X : C.Ob) -> f.trans X = g.trans X", "h1 : f.trans = g.trans", "C : Precat", "this : Limit ", "f : Hom {D {\\this}} z (apex {\\this})", "i : I"], "Expected type": "NatTrans {op {C1}} {SetCat} (VPresheaf.F {apex {\\this}}) z.F {\n  | trans => \\lam (X : Ob {C {\\this}}) => arg X @ i\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam X => arg X @ i\n  | natural => \\lam {X} => (@) (prop-dpi (\\lam i => ext_coe) (natural {f}) (natural {g})) i {X}\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| apex : Ob {D}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| C : Precat", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["this : Iso ", "h1 : (\\lam (X : C.Ob) => hinv {image-of-rep-iso {C1} {E} {A} X} \u2218 f {image-of-rep-iso {C1} {E} {A} X}) = (\\lam (X : C.Ob) => id {C {image-of-rep-iso {C1} {E} {A} X}} (dom {image-of-rep-iso {C1} {E} {A} X}))", "E : CocompleteCat", "C : Precat"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : C.Ob} ->\n  \\Pi (f : C.Hom X Y) -> (@) h1 i Y E.\u2218 Func {dom {\\this}} {X} {Y} f = Func {dom {\\this}} {X} {Y} f E.\u2218 (@) h1 i X)\n  (natural {hinv {\\this} \u2218 f {\\this}}) (natural {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["this : Iso ", "E : CocompleteCat", "C : Precat", "h1 : (\\lam (X : C.Ob) => f {image-of-rep-iso {C1} {E} {A} X} \u2218 hinv {image-of-rep-iso {C1} {E} {A} X}) = (\\lam (X : C.Ob) => id {C {image-of-rep-iso {C1} {E} {A} X}} (cod {image-of-rep-iso {C1} {E} {A} X}))"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : C.Ob} ->\n  \\Pi (f : C.Hom X Y) -> (@) h1 i Y E.\u2218 Func {cod {\\this}} {X} {Y} f = Func {cod {\\this}} {X} {Y} f E.\u2218 (@) h1 i X)\n  (natural {f {\\this} \u2218 hinv {\\this}}) (natural {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["X : Ob {\\this}", "D : Precat", "h1 : (\\lam (X1 : C.Ob) => D.id (Y.F X1) D.\u2218 f.trans X1) = f.trans", "C : Precat", "f : Hom {\\this} X Y", "Y : Ob {\\this}", "this : Precat (Functor C1 D1) "], "Expected type": "Path (\\lam (i : I) => \\Pi {X1 Y1 : C.Ob} -> \\Pi (f : C.Hom X1 Y1) -> (@) h1 i Y1 D.\u2218 X.Func {X1} {Y1} f = Y.Func {X1} {Y1} f D.\u2218 (@) h1 i X1)\n  (natural {id {\\this} Y \u2218 f}) f.natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| id (X : Ob) : Hom X X", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["D : Precat", "h1 : (\\lam (X1 : C.Ob) => f.trans X1 D.\u2218 D.id (X.F X1)) = f.trans", "C : Precat", "X : Ob {\\this}", "Y : Ob {\\this}", "f : Hom {\\this} X Y", "this : Precat (Functor C1 D1) "], "Expected type": "Path (\\lam (i : I) => \\Pi {X1 Y1 : C.Ob} -> \\Pi (f : C.Hom X1 Y1) -> (@) h1 i Y1 D.\u2218 X.Func {X1} {Y1} f = Y.Func {X1} {Y1} f D.\u2218 (@) h1 i X1)\n  (natural {f \u2218 id {\\this} X}) f.natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| id (X : Ob) : Hom X X", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (X1 : C.Ob) => h.trans X1 D.\u2218 g.trans X1 D.\u2218 f.trans X1) = (\\lam (X1 : C.Ob) => h.trans X1 D.\u2218 (g.trans X1 D.\u2218 f.trans X1))", "g : Hom {\\this} Y Z", "h : Hom {\\this} Z W", "D : Precat", "W : Ob {\\this}", "C : Precat", "Y : Ob {\\this}", "f : Hom {\\this} X Y", "X : Ob {\\this}", "Z : Ob {\\this}", "this : Precat (Functor C1 D1) "], "Expected type": "Path (\\lam (i : I) => \\Pi {X1 Y : C.Ob} -> \\Pi (f : C.Hom X1 Y) -> (@) h1 i Y D.\u2218 X.Func {X1} {Y} f = W.Func {X1} {Y} f D.\u2218 (@) h1 i X1)\n  (natural {h \u2218 g \u2218 f}) (natural {h \u2218 (g \u2218 f)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["D : Cat", "C : Precat", "e : Iso ", "h1 : F {e.dom} = F {e.cod}", "l : Ob {e.C}", "h2 : Path (\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom ((@) h1 i X) ((@) h1 i Y)) l.Func (Func {e.cod})"], "Expected type": "Path (\\lam (i : I) => \\Pi {X : C.Ob} -> (@) h2 i {X} {X} (C.id X) = D.id ((@) h1 i X)) l.Func-id (Func-id {e.cod})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)", "| cod : Ob {C}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["D : Cat", "C : Precat", "e : Iso ", "h1 : F {e.dom} = F {e.cod}", "l : Ob {e.C}", "h2 : Path (\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom ((@) h1 i X) ((@) h1 i Y)) l.Func (Func {e.cod})"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y Z : C.Ob} ->\n  \\Pi {g : C.Hom Y Z} -> \\Pi {f : C.Hom X Y} -> (@) h2 i {X} {Z} (g C.\u2218 f) = (@) h2 i {Y} {Z} g D.\u2218 (@) h2 i {X} {Y} f)\n  l.Func-o (Func-o {e.cod})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["D : Cat", "f : Hom e.dom e.dom", "C : Precat", "e : Iso ", "null : NatTrans ", "h : transport {Functor C D} (\\lam (x : Functor C D) => \\Pi (X : C.Ob) -> D.Hom (F {e.dom} X) (x.F X)) {e.dom} {e.dom}\n  (idp {Functor C D} {e.dom}) f.trans = trans"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : C.Ob} -> \\Pi (f : C.Hom X Y) -> (@) h i Y D.\u2218 Func {e.dom} {X} {Y} f = Func {e.dom} {X} {Y} f D.\u2218 (@) h i X)\n  (natural {transport {Functor C D} (\\lam (G : Ob) => NatTrans {C} {D} e.dom G) {e.dom} {e.dom} (idp {Functor C D} {e.dom}) f})\n  natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| dom : Ob {C}", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : Ob {\\this}", "b : Ob {\\this}", "J : \\Type", "D : Cat"], "Expected type": "Equiv {a = b} {Iso {FamPrecat {J} D} {a} {b}} (idtoiso {FamPrecat {J} D} {a} {b})", "Expression": "makeUnivalence\n  (later (\\lam e => (ext (\\lam j => isotoid {D} (mapIso e j)), simp_coe (\\lam {j} => transport_iso (mapIso e j)))))", "Premises": ["\\lemma makeUnivalence \\plevels obj >= hom \\hlevels  {C : Precat}\n  (_ : \\Pi (e : Iso {C}) -> \\Sigma (p : e.dom = e.cod) (transport {C.Ob} (C.Hom e.dom) {e.dom} {e.cod} p (C.id e.dom) = e.f))\n  {a b : C.Ob} : Equiv {a = b} {Iso {C} {a} {b}} (idtoiso {C} {a} {b}) ", "\\func mapIso \\plevels obj >= hom {J : \\Type} {D : Precat} (e : Iso {FamPrecat {J} D}) (j : J) : Iso {D} {e.dom j} {e.cod j} (e.f {j}) {\n  | hinv => e.hinv {j}\n} => \\new Iso {\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "\\func isotoid \\plevels obj >= hom \\hlevels  {this : Cat} {a b : Ob} (e : Iso {a} {b}) : a = b => ret {univalence {a} {b}} e", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| id (X : Ob) : Hom X X", "\\func idtoiso \\plevels obj >= hom \\hlevels  {this1 : Precat} {a1 b : Ob} (_ : a1 = b) : Iso {a1} {b} \n  | {this}, {a}, {b}, idp => idIso {a}", "\\lemma transport_iso \\plevels obj >= hom \\hlevels  {this : Cat} (e : Iso) :\n  transport {Ob} (Hom e.dom) {e.dom} {e.cod} (isotoid {e.dom} {e.cod} (\\new e {})) (id e.dom) = e.f ", "\\func coe (A : I -> \\Type) (a : A left) (i : I) : A i "]}
{"Context": ["h2 : Path ((@) h1) zro zro", "h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "l : B {\\this}", "h1 : E {f {\\this} (sec {\\this} b)} = E", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : h1 @ i} -> (@) h3 i (h2 @ i) x = x) l.zro-left zro-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-left {x : E} : zro + x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : Path ((@) h1) zro zro", "h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "l : B {\\this}", "h1 : E {f {\\this} (sec {\\this} b)} = E", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : h1 @ i} -> (@) h3 i x (h2 @ i) = x) l.zro-right zro-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-right {x : E} : x + zro = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "l : B {\\this}", "h1 : E {f {\\this} (sec {\\this} b)} = E", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : h1 @ i} -> (@) h3 i ((@) h3 i x y) z = (@) h3 i x ((@) h3 i y z)) l.+-assoc +-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "l : B {\\this}", "h1 : E {f {\\this} (sec {\\this} b)} = E", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : h1 @ i} -> (@) h3 i x y = (@) h3 i y x) l.+-comm +-comm", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h4 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.*) (*)", "h1 : E {f {\\this} (sec {\\this} b)} = E", "l : B {\\this}", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : h1 @ i} -> (@) h4 i ((@) h4 i x y) z = (@) h4 i x ((@) h4 i y z)) l.*-assoc *-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| *-assoc {x y z : E} : x * y * z = x * (y * z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h4 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.*) (*)", "h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "h1 : E {f {\\this} (sec {\\this} b)} = E", "l : B {\\this}", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : h1 @ i} -> (@) h4 i x ((@) h3 i y z) = (@) h3 i ((@) h4 i x y) ((@) h4 i x z)) l.ldistr\n  ldistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ldistr {x y z : E} : x * (y + z) = x * y + x * z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h4 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.*) (*)", "h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "h1 : E {f {\\this} (sec {\\this} b)} = E", "l : B {\\this}", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : h1 @ i} -> (@) h4 i ((@) h3 i x y) z = (@) h3 i ((@) h4 i x z) ((@) h4 i y z)) l.rdistr\n  rdistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| rdistr {x y z : E} : (x + y) * z = x * z + y * z"]}
{"Context": ["h2 : Path ((@) h1) zro zro", "l : B {\\this}", "h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "h1 : E {f {\\this} (sec {\\this} b)} = E", "h5 : Path (\\lam (i : I) => h1 @ i -> h1 @ i) l.negative negative", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : h1 @ i} -> (@) h3 i ((@) h5 i x) x = h2 @ i) l.negative-left negative-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| negative-left {x : E} : negative x + x = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h6 : Path ((@) h1) ide ide", "h4 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.*) (*)", "l : B {\\this}", "h1 : E {f {\\this} (sec {\\this} b)} = E", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : h1 @ i} -> (@) h4 i (h6 @ i) x = x) l.ide-left ide-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-left {x : E} : ide * x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h6 : Path ((@) h1) ide ide", "h4 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.*) (*)", "l : B {\\this}", "h1 : E {f {\\this} (sec {\\this} b)} = E", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : h1 @ i} -> (@) h4 i x (h6 @ i) = x) l.ide-right ide-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-right {x : E} : x * ide = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : Path ((@) h1) zro zro", "h7 : Path (\\lam (i : I) => Nat -> h1 @ i) l.natCoef natCoef", "h1 : E {f {\\this} (sec {\\this} b)} = E", "l : B {\\this}", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => (@) h7 i 0 = h2 @ i) l.natCoefZero natCoefZero", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| natCoefZero : natCoef 0 = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h6 : Path ((@) h1) ide ide", "h7 : Path (\\lam (i : I) => Nat -> h1 @ i) l.natCoef natCoef", "h3 : Path (\\lam (i : I) => h1 @ i -> h1 @ i -> h1 @ i) (l.+) (+)", "h1 : E {f {\\this} (sec {\\this} b)} = E", "l : B {\\this}", "null : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi (n : Nat) -> (@) h7 i (suc n) = (@) h3 i ((@) h7 i n) (h6 @ i)) l.natCoefSuc natCoefSuc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "| natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (j : J.Ob) => inverse {F1} {X} {G.F j} (F.Func {X} {G.F j} (c.coneMap j))) = c.coneMap", "this : QEquiv ", "G : Functor J C", "C : Precat", "X : C.Ob", "J : Precat", "c : A {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> G.Func {j} {j'} h C.\u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {ret {\\this} (f {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| ret B : A", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : QEquiv ", "G : Functor J C", "c : B {\\this}", "C : Precat", "D : Precat", "h1 : (\\lam (j : J.Ob) => F.Func {X} {G.F j} (inverse {F1} {X} {G.F j} (c.coneMap j))) = c.coneMap", "F : FullyFaithfulFunctor C D", "X : C.Ob", "J : Precat"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> Func {j} {j'} h D.\u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {\\this} (sec {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| sec B : A", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : Hom {D} z apex", "z : Ob {D}", "this : Limit", "g : Hom {D} z apex", "h1 : (\\lam (j : Ob {J}) => coneMap j \u2218 f) = (\\lam (j : Ob {J}) => coneMap j \u2218 g)"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob {J}} -> \\Pi (h : Hom {J} j j') -> Func {G} {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {isLimit z} f1}) (coneCoh {f {isLimit z} g})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| J : Precat", "| F (Ob {C}) : Ob {D}", "| isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\new \\this {}) z)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D"]}
{"Context": ["f : Hom {D} z apex", "z : Ob {D}", "p : \\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g", "this : Limit", "g : Hom {D} z apex", "i : I", "h1 : (\\lam (j : Ob {J}) => coneMap j \u2218 f) = (\\lam (j : Ob {J}) => coneMap j \u2218 g)"], "Expected type": "Cone {J} {D} G z {\n  | coneMap => \\lam (j : Ob {J {\\this}}) => p j @ i\n  | coneCoh => {?hidden}\n}", "Expression": "\\new Cone {\n  | coneMap => \\lam j => p j @ i\n  | coneCoh => \\lam {j} => (@) (prop-dpi (\\lam i => ext_coe) (coneCoh {f {isLimit z} f1}) (coneCoh {f {isLimit z} g})) i {j}\n}", "Premises": ["| J : Precat", "| isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\new \\this {}) z)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| D : Precat", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| f A : B", "| G : Functor J D", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : QEquiv ", "h1 : (\\lam (j : Ob {J}) => coneMap j \u2218 limMap {z} c) = c.coneMap", "c : B {\\this}", "this : Limit", "z : Ob {D}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob {J}} -> \\Pi (h : Hom {J} j j') -> Func {G} {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {\\this} (sec {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| J : Precat", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| G : Functor J D", "| sec B : A"]}
{"Context": ["this : QEquiv ", "h1 : (\\lam (j : Ob {J}) => coneMap j \u2218 limMap {z} c) = c.coneMap", "i : I", "arg : \\Pi (j : Ob {J}) -> coneMap j \u2218 limMap {z} c = c.coneMap j", "c : B {\\this}", "this : Limit", "z : Ob {D}"], "Expected type": "Cone {J} {D} G z {\n  | coneMap => \\lam (j : Ob {J {\\this}}) => arg j @ i\n  | coneCoh => {?hidden}\n}", "Expression": "\\new Cone {\n  | coneMap => \\lam j => arg j @ i\n  | coneCoh => \\lam {j} => (@) (prop-dpi (\\lam i => ext_coe) (coneCoh {conePullback {J} {D} {G} (\\new this {}) z (limMap {z} c)}) (coneCoh {c})) i {j}\n}", "Premises": ["| J : Precat", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| D : Precat", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| G : Functor J D", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : Product", "Z : Ob {D}"], "Expected type": "QEquiv {Hom {D} Z apex} {\\Pi (p0 : J) -> Hom {D} Z (G p0)} (\\lam (h : Hom {D} Z apex) (p0 : J) => proj p0 \u2218 h) {\n  | ret => tupleMap {Z}\n  | ret_f => \\lam (h : A {\\this}) =>\n    tupleEq {Z} {ret {\\this} (\\lam (p0 : J) => proj p0 \u2218 h)} {h} (tupleBeta {Z} {\\lam (p0 : J) => proj p0 \u2218 h})\n  | f_sec => \\lam (f : B {\\this}) => path (\\lam (i : I) (p0 : J) => tupleBeta {Z} {f} {p0} @ i)\n}", "Expression": "\\new QEquiv {\n  | ret => tupleMap \n  | ret_f => \\lam h => tupleEq  (\\lam j => tupleBeta )\n  | f_sec => \\lam f => ext (\\lam j => tupleBeta )\n}", "Premises": ["| Hom Ob Ob : \\Set", "| ret B : A", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| J : \\Type", "| tupleBeta {Z : Ob {D}} {f : \\Pi (j : J) -> Hom {D} Z (G j)} {j : J} : proj j \u2218 tupleMap {Z} f = f j", "| A : \\Type", "| proj (j : J) : Hom {D} apex (G j)", "| tupleMap {Z : Ob {D}} (\\Pi (j : J) -> Hom {D} Z (G j)) : Hom {D} Z apex", "| apex : Ob {D}", "| D : Precat", "| G J : Ob {D}", "| B : \\Type", "| tupleEq {Z : Ob {D}} {h1 h2 : Hom {D} Z apex} (\\Pi (j : J) -> proj j \u2218 h1 = proj j \u2218 h2) : h1 = h2"]}
{"Context": ["e : D.Ob", "f : D.Hom x y", "x : D.Ob", "t : B {\\this}", "equal : f D.\u2218 eql = g D.\u2218 eql", "g : D.Hom x y", "D : Precat", "z : D.Ob", "p : \\Pi {z : D.Ob} -> \\Pi (h : D.Hom z x) -> f D.\u2218 h = g D.\u2218 h -> TruncP (\\Sigma (k : D.Hom z e) (eql D.\u2218 k = h))", "eql : D.Hom e x", "y : D.Ob"], "Expected type": "TruncP (\\Sigma (x1 : D.Hom z e) ((eql D.\u2218 x1,\n  inv {D.Hom z y} {f D.\u2218 eql D.\u2218 x1} {f D.\u2218 (eql D.\u2218 x1)} (D.o-assoc {z} {e} {x} {y} {f} {eql} {x1}) *> pmap {D.Hom e y} {D.Hom z y} (\\lam (_x : D.Hom e y) => _x D.\u2218 x1) {f D.\u2218 eql} {g D.\u2218 eql} equal *> D.o-assoc {z} {e} {x} {y} {g} {eql} {x1}) = t))", "Expression": "map {?} (\\lam q => (q.1, ext q.2))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "| Hom Ob Ob : \\Set", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["this : Equalizer", "this : QEquiv ", "h1 : (\\lam (j : Bool) => (\\case j \\with {\n  | false => c.coneMap false\n  | true => g \u2218 c.coneMap false\n})) = c.coneMap", "Z : Ob {D {\\this}}", "c : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob} -> \\Pi (h : Hom j j') -> Func {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {Map.f {\\this} (sec {\\this} c)}) c.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| f : Hom {D} X Y", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| sec B : A"]}
{"Context": ["z : Ob {D {\\this}}", "c : B {\\this}", "h1 : coneMap = c.coneMap", "this : QEquiv ", "this : LimitDiagram Shape Pullback.D (\\lam (p0 : V "], "Expected type": "Path (\\lam (i : I) => \\Pi {g g' : V {G {\\this}}} -> \\Pi (e : E {G {\\this}} g g') -> Func {\\this} {g} {g'} e \u2218 (@) h1 i g = (@) h1 i g')\n  (diagramCoh {f {\\this} (sec {\\this} c)}) c.diagramCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Func {x y : V {G}} (E {G} x y) : Hom {D} (F x) (F y)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| V : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| F (V {G}) : Ob {D}", "| G : Graph", "| diagramCoh {g g' : V {G}} (e : E {G} g g') : Func {g} {g'} e \u2218 coneMap g = coneMap g'", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| sec B : A", "| E V V : \\Set"]}
{"Context": ["a : Product ", "a' : Product ", "h3 : Path (\\lam (i : I) => \\Pi {Z : C.Ob} -> (\\Pi (j : Empty) -> C.Hom Z (absurd {C.Ob} j)) -> C.Hom Z (h1 @ i)) a.tupleMap\n  a'.tupleMap", "C : Cat", "h1 : a.apex = a'.apex", "h2 : Path (\\lam (i : I) => \\Pi (j : Empty) -> C.Hom (h1 @ i) (absurd {C.Ob} j)) a.proj a'.proj"], "Expected type": "Path (\\lam (i : I) => \\Pi {Z : C.Ob} ->\n  \\Pi {f : \\Pi (j : Empty) -> C.Hom Z (absurd {C.Ob} j)} -> \\Pi {j : Empty} -> (@) h2 i j C.\u2218 (@) h3 i {Z} f = f j)\n  a.tupleBeta a'.tupleBeta", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func absurd {A : \\Type} (_ : Empty) : A ", "| Hom Ob Ob : \\Set", "\\data Empty \\plevels  \\hlevels  ", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| tupleBeta {Z : Ob {D}} {f : \\Pi (j : J) -> Hom {D} Z (G j)} {j : J} : proj j \u2218 tupleMap {Z} f = f j", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : Product ", "a' : Product ", "C : Cat", "h1 : a.apex = a'.apex", "h2 : Path (\\lam (i : I) => \\Pi (j : Empty) -> C.Hom (h1 @ i) (absurd {C.Ob} j)) a.proj a'.proj"], "Expected type": "Path (\\lam (i : I) => \\Pi {Z : C.Ob} -> \\Pi {h3 h4 : C.Hom Z (h1 @ i)} -> (\\Pi (j : Empty) -> (@) h2 i j C.\u2218 h3 = (@) h2 i j C.\u2218 h4) -> h3 = h4)\n  a.tupleEq a'.tupleEq", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Hom Ob Ob : \\Set", "\\data Empty \\plevels  \\hlevels  ", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| tupleEq {Z : Ob {D}} {h1 h2 : Hom {D} Z apex} (\\Pi (j : J) -> proj j \u2218 h1 = proj j \u2218 h2) : h1 = h2", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["D : DCat", "y : Ob", "this : Iso ", "x : Ob", "p : A {\\this}"], "Expected type": "f {\\this} \u2218 hinv {\\this} = id {C {\\this}} (cod {\\this})", "Expression": "ext (f_hinv {p.1}, inv^-right {p.2})", "Premises": ["| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| inv^-right : transport {Hom {C {D}} (Map.cod {e}) (Map.cod {e})}\n  (\\lam (p0 : Hom {C {D}} (Map.cod {e}) (Map.cod {e})) => DHom {D} {Map.cod {e}} {Map.cod {e}} p0 DIso.cod DIso.cod)\n  {Map.f {e} \u2218 hinv {e}} {id {C {D}} (Map.cod {e})} (f_hinv {e}) (DIso.f \u2218^ inv^) = id^ {D} {Map.cod {e}} DIso.cod", "| f : DHom {D} {Map.dom {e}} {Map.cod {e}} (f {e}) DIso.dom DIso.cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| C : Precat", "| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| C : Precat", "| f_hinv : f \u2218 hinv = id {C} cod", "| f : Hom {C} dom cod"]}
{"Context": ["D : DCat", "y : Ob", "x : Ob", "p : A {\\this}"], "Expected type": "Iso {totalPrecat D} {x} {y} (Map.f {p.1}, DIso.f {p.2}) {\n  | hinv => (hinv {p.1}, inv^ {p.2})\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "Expression": "\\new Iso {\n  | f => (p.1, p.2)\n  | hinv => (hinv {p.1}, inv^ {p.2})\n  | hinv_f => ext (hinv_f {p.1}, inv^-left {p.2})\n  | f_hinv => ext (f_hinv {p.1}, inv^-right {p.2})\n}", "Premises": ["| hinv_f : hinv \u2218 f = id {C} dom", "\\func totalPrecat \\plevels obj >= hom \\hlevels  (D : DPrecat) : Precat (\\Sigma (a : Ob {D.C}) (D.DOb a)) {\n  | Hom => \\lam (p0 : Ob {\\this}) (p1 : Ob {\\this}) => \\Sigma (f : Hom {D.C} p0.1 p1.1) (D.DHom {p0.1} {p1.1} f p0.2 p1.2)\n  | id => \\lam (p0 : Ob {\\this}) => (id {D.C} p0.1, D.id^ {p0.1} p0.2)\n  | o => \\lam {X Y Z : Ob {\\this}} (p0 : Hom {\\this} Y Z) (p1 : Hom {\\this} X Y) => (p0.1 \u2218 p1.1, p0.2 D.\u2218^ p1.2)\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| inv^-right : transport {Hom {C {D}} (Map.cod {e}) (Map.cod {e})}\n  (\\lam (p0 : Hom {C {D}} (Map.cod {e}) (Map.cod {e})) => DHom {D} {Map.cod {e}} {Map.cod {e}} p0 DIso.cod DIso.cod)\n  {Map.f {e} \u2218 hinv {e}} {id {C {D}} (Map.cod {e})} (f_hinv {e}) (DIso.f \u2218^ inv^) = id^ {D} {Map.cod {e}} DIso.cod", "| inv^ : DHom {D} {Map.cod {e}} {Map.dom {e}} (hinv {e}) DIso.cod DIso.dom", "| f : DHom {D} {Map.dom {e}} {Map.cod {e}} (f {e}) DIso.dom DIso.cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| f : Hom {C} dom cod", "| f_hinv : f \u2218 hinv = id {C} cod", "| inv^-left : transport {Hom {C {D}} (Map.dom {e}) (Map.dom {e})}\n  (\\lam (p0 : Hom {C {D}} (Map.dom {e}) (Map.dom {e})) => DHom {D} {Map.dom {e}} {Map.dom {e}} p0 DIso.dom DIso.dom)\n  {hinv {e} \u2218 Map.f {e}} {id {C {D}} (Map.dom {e})} (hinv_f {e}) (inv^ \u2218^ DIso.f) = id^ {D} {Map.dom {e}} DIso.dom"]}
{"Context": ["x : \\Sigma (a : A) (f a = b0)", "f : A -> B", "A : \\Type", "b0 : B", "x' : \\Sigma (a : A) (f a = b0)", "B : \\Type", "S : \\Pi {b0 : B} -> \\Pi (_ _ : Fib {A} {B} f b0) -> \\Type"], "Expected type": "Retraction {x = x'} {S {b0} x x'} (\\lam (q : A {\\this}) =>\n  transport {\\Sigma (a : A1) (f a = b0)} (S {b0} x) {x} {x'} q (idp {A1} {x.1}, idp_*> {B1} {f x.1} {b0} x.2)) {\n  | sec => \\lam (s : B {\\this}) => ext {A1} {B1} {f} b0 x x' s.1 s.2\n  | f_sec => \\lam (s : B {\\this}) => (retraction {A1} {B1} {f} b0 x' x s.1 s.2).2\n}", "Expression": "\\new Retraction {\n  | f => \\lam q => transport (S x) q (idp, idp_*> x.2)\n  | sec => \\lam s => ext {A} {B} {f} b0 x x' s.1 s.2\n  | f_sec => \\lam s => (retraction {A} {B} {f} b0 x' x s.1 s.2).2\n}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func ext {A B : \\Type} {f : A -> B} (b0 : B) (x x' : Fib {A} {B} f b0) (p : x.1 = x'.1)\n  (q : pmap {A} {B} f {x.1} {x'.1} p *> x'.2 = x.2) : x = x' => (retraction {A} {B} {f} b0 x' x p q).1", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func retraction {A1 B1 : \\Type} {f1 : A1 -> B1} (b0 : B1) (x' x : Fib {A1} {B1} f1 b0) (p : x.1 = x'.1)\n  (q : pmap {A1} {B1} f1 {x.1} {x'.1} p *> x'.2 = x.2) : \\Sigma (t : x = x') (transport {\\Sigma (a : A1) (f1 a = b0)}\n  (\\lam (x'' : \\Sigma (a : A1) (f1 a = b0)) => \\Sigma (p : x.1 = x''.1) (pmap {A1} {B1} f1 {x.1} {x''.1} p *> x''.2 = x.2))\n  {x} {x'} t (idp {A1} {x.1}, idp_*> {B1} {f1 x.1} {b0} x.2) = (p, q)) \n  | {A}, {B}, {f}, b0, (x'1, idp), (x1, x2), idp, idp =>\n  (idp {\\Sigma (a : A) (f a = f x'1)} {(x'1, pmap {A} {B} f {x'1} {x'1} (idp {A} {x'1}) *> idp {B} {f x'1})},\n    idp {\\Sigma (p : x'1 = x'1)\n      (pmap {A} {B} f {x'1} {x'1} p *> idp {B} {f x'1} = pmap {A} {B} f {x'1} {x'1} (idp {A} {x'1}) *> idp {B} {f x'1})}\n      {transport {\\Sigma (a : A) (f a = f x'1)} (\\lam (x'' : \\Sigma (a : A) (f a = f x'1)) => \\Sigma (p : x'1 = x''.1)\n        (pmap {A} {B} f {x'1} {x''.1} p *> x''.2 = pmap {A} {B} f {x'1} {x'1} (idp {A} {x'1}) *> idp {B} {f x'1}))\n        {(x'1, pmap {A} {B} f {x'1} {x'1} (idp {A} {x'1}) *> idp {B} {f x'1})} {(x'1, idp {B} {f x'1})}\n        (idp {\\Sigma (a : A) (f a = f x'1)} {(x'1, pmap {A} {B} f {x'1} {x'1} (idp {A} {x'1}) *> idp {B} {f x'1})})\n        (idp {A} {x'1}, idp_*> {B} {f x'1} {f x'1} (pmap {A} {B} f {x'1} {x'1} (idp {A} {x'1}) *> idp {B} {f x'1}))})", "| B : \\Type", "\\func idp_*> {A1 : \\Type} {a1 a' : A1} (p : a1 = a') : idp {A1} {a1} *> p = p \n  | {A}, {a}, {a'}, idp => idp {a = a} {idp {A} {a} *> idp {A} {a}}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| A : \\Type"]}
{"Context": ["t' : Truncated_-1+ n", "t : Truncated_-1+ n", "n : Nat"], "Expected type": "Retraction {t = t'} {t.A = t'.A} (pmap {Truncated_-1+ n} {\\Type} (\\lam (p0 : Truncated_-1+ n) => p0.A) {t} {t'}) {\n  | sec => ext {n} t t'\n  | f_sec => \\lam (b : B {\\this}) =>\n    idp {t.A = t'.A} {pmap {Truncated_-1+ n} {\\Type} (\\lam (p0 : Truncated_-1+ n) => p0.A) {t} {t'} (sec {\\this} b)}\n}", "Expression": "\\new Retraction {\n  | f => pmap (\\lam p0 => A {p0})\n  | sec => ext t t'\n  | f_sec => \\lam _ => idp\n}", "Premises": ["\\func ext {n : Nat} (t t' : Truncated_-1+ n) (p : t.A = t'.A) : t = t' => path (\\lam (i : I) => \\new Truncated_-1+ n (p @ i) {\n  | isTruncated => {?hidden}\n})", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| A : \\Type", "| B : \\Type", "| sec B : A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : \\Pi (g : A -> C) -> \\Pi (b : B) -> Contr (\\Sigma (c : C) (\\Pi (a : A) -> f a = b -> g a = c))", "A : \\hType", "f : A -> B", "g : A -> C", "C : \\hType", "B : \\hType"], "Expected type": "Contr (\\Sigma (a : B -> C) (-o {A} {B} {C} f a = g))", "Expression": "rewrite (QEquiv-to-= (ext-equiv f g)) {?}", "Premises": ["\\func -o {A B C : \\Type} (f : A -> B) : \\Pi (g : B -> C) -> \\Pi (x : A) -> C => \\lam (g : B -> C) (x : A) => g (f x)", "\\func QEquiv-to-= {A B : \\Type} (e : QEquiv {A} {B}) : A = B => path (iso {A} {B} e.f e.ret e.ret_f e.f_sec)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func ext-equiv \\hlevels  {A1 B1 C : \\hType} (f : A1 -> B1) (g : A1 -> C) :\nQEquiv {ext {A1} {B1} {C} f g} {\\Pi (b : B1) -> \\Sigma (c : C) (\\Pi (a : A1) -> f a = b -> g a = c)}\n  (\\lam (p : A {\\this}) (b : B1) => (p.1 b, \\lam (a : A1) (fa=b : f a = b) =>\n    inv {C} {-o {A1} {B1} {C} f p.1 a} {g a} (path (\\lam (p0 : I) => (@) p.2 p0 a)) *> pmap {B1} {C} p.1 {f a} {b} fa=b)) {\n  | ret => \\lam (K : B {\\this}) => (\\lam (p0 : B1) => (K p0).1,\n    path (\\lam (i : I) (a : A1) => inv {C} {g a} {(K (f a)).1} ((K (f a)).2 a (idp {B1} {f a})) @ i))\n  | ret_f => \\lam (b : A {\\this}) => path (\\lam (j : I) => (b.1,\n    path (\\lam (i : I) (a : A1) => inv_inv {C} {-o {A1} {B1} {C} f b.1 a} {g a} (path (\\lam (p0 : I) => (@) b.2 p0 a)) @ j @ i)))\n  | f_sec => \\lam (K : B {\\this}) => (\n    \\have p => \\lam (b : B1) (a : A1) => Jl {B1} {f a} (\\lam (b' : B1) (q' : f a = b') =>\n            inv {C} {(K (f a)).1} {g a} (inv {C} {g a} {(K (f a)).1} ((K (f a)).2 a (idp {B1} {f a}))) *> pmap {B1} {C} (\\lam (p0 : B1) => (K p0).1) {f a} {b'} q' = (K b').2 a q')\n            (inv_inv {C} {g a} {(K (f a)).1} ((K (f a)).2 a (idp {B1} {f a}))) {b}\n    \\in path (\\lam (i : I) (b : B1) => ((K b).1, \\lam (p0 : A1) (p1 : f p0 = b) => p b p0 p1 @ i)))\n} => \\new QEquiv"]}
{"Context": ["l2 : Localization ", "l1 : Localization ", "U : Universe", "p : iso {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) (lift {l2} {l1.S'} l1.inL)\n  (remove_inL {l1} {l1.S'} (lift {l2} {l1.S'} l1.inL o lift {l1} {l2.S'} l2.inL) (id {Local.S {l1.S'}}) (\\lam (x : l1.S) =>\n    (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (lift {l1} {l2.S'} l2.inL (l1.inL x))) {lift {l2} {l1.S'} l1.inL (l2.inL x)}\n      (pmap {Local.S {l2.S'}} {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL) {lift {l1} {l2.S'} l2.inL (l1.inL x)} {l2.inL x}\n        (lift-prop {l1} {l2.S'} l2.inL x)) >== (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (l2.inL x)) {l1.inL x} (lift-prop {l2} {l1.S'} l1.inL x) >== qed {Local.S {l1.S'}} (l1.inL x)))\n  (remove_inL {l2} {l2.S'} (lift {l1} {l2.S'} l2.inL o lift {l2} {l1.S'} l1.inL) (id {Local.S {l2.S'}}) (\\lam (x : l2.S) =>\n    (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (lift {l2} {l1.S'} l1.inL (l2.inL x))) {lift {l1} {l2.S'} l2.inL (l1.inL x)}\n      (pmap {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) {lift {l2} {l1.S'} l1.inL (l2.inL x)} {l1.inL x}\n        (lift-prop {l2} {l1.S'} l1.inL x)) >== (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (l1.inL x)) {l2.inL x} (lift-prop {l1} {l2.S'} l2.inL x) >== qed {Local.S {l2.S'}} (l2.inL x)))\n  left = iso {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) (lift {l2} {l1.S'} l1.inL)\n  (remove_inL {l1} {l1.S'} (lift {l2} {l1.S'} l1.inL o lift {l1} {l2.S'} l2.inL) (id {Local.S {l1.S'}}) (\\lam (x : l1.S) =>\n    (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (lift {l1} {l2.S'} l2.inL (l1.inL x))) {lift {l2} {l1.S'} l1.inL (l2.inL x)}\n      (pmap {Local.S {l2.S'}} {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL) {lift {l1} {l2.S'} l2.inL (l1.inL x)} {l2.inL x}\n        (lift-prop {l1} {l2.S'} l2.inL x)) >== (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (l2.inL x)) {l1.inL x} (lift-prop {l2} {l1.S'} l1.inL x) >== qed {Local.S {l1.S'}} (l1.inL x)))\n  (remove_inL {l2} {l2.S'} (lift {l1} {l2.S'} l2.inL o lift {l2} {l1.S'} l1.inL) (id {Local.S {l2.S'}}) (\\lam (x : l2.S) =>\n    (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (lift {l2} {l1.S'} l1.inL (l2.inL x))) {lift {l1} {l2.S'} l2.inL (l1.inL x)}\n      (pmap {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) {lift {l2} {l1.S'} l1.inL (l2.inL x)} {l1.inL x}\n        (lift-prop {l2} {l1.S'} l1.inL x)) >== (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (l1.inL x)) {l2.inL x} (lift-prop {l1} {l2.S'} l2.inL x) >== qed {Local.S {l2.S'}} (l2.inL x)))\n  right"], "Expected type": "Path (\\lam (i : I) => U.isLocal (p @ i)) (local {l1.S'}) (local {l2.S'})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| S' : Local {U}", "| local : isLocal {U} S", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| isLocal \\hType : \\Prop"]}
{"Context": ["l2 : Localization ", "l1 : Localization ", "i : I", "U : Universe", "p : iso {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) (lift {l2} {l1.S'} l1.inL)\n  (remove_inL {l1} {l1.S'} (lift {l2} {l1.S'} l1.inL o lift {l1} {l2.S'} l2.inL) (id {Local.S {l1.S'}}) (\\lam (x : l1.S) =>\n    (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (lift {l1} {l2.S'} l2.inL (l1.inL x))) {lift {l2} {l1.S'} l1.inL (l2.inL x)}\n      (pmap {Local.S {l2.S'}} {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL) {lift {l1} {l2.S'} l2.inL (l1.inL x)} {l2.inL x}\n        (lift-prop {l1} {l2.S'} l2.inL x)) >== (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (l2.inL x)) {l1.inL x} (lift-prop {l2} {l1.S'} l1.inL x) >== qed {Local.S {l1.S'}} (l1.inL x)))\n  (remove_inL {l2} {l2.S'} (lift {l1} {l2.S'} l2.inL o lift {l2} {l1.S'} l1.inL) (id {Local.S {l2.S'}}) (\\lam (x : l2.S) =>\n    (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (lift {l2} {l1.S'} l1.inL (l2.inL x))) {lift {l1} {l2.S'} l2.inL (l1.inL x)}\n      (pmap {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) {lift {l2} {l1.S'} l1.inL (l2.inL x)} {l1.inL x}\n        (lift-prop {l2} {l1.S'} l1.inL x)) >== (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (l1.inL x)) {l2.inL x} (lift-prop {l1} {l2.S'} l2.inL x) >== qed {Local.S {l2.S'}} (l2.inL x)))\n  left = iso {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) (lift {l2} {l1.S'} l1.inL)\n  (remove_inL {l1} {l1.S'} (lift {l2} {l1.S'} l1.inL o lift {l1} {l2.S'} l2.inL) (id {Local.S {l1.S'}}) (\\lam (x : l1.S) =>\n    (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (lift {l1} {l2.S'} l2.inL (l1.inL x))) {lift {l2} {l1.S'} l1.inL (l2.inL x)}\n      (pmap {Local.S {l2.S'}} {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL) {lift {l1} {l2.S'} l2.inL (l1.inL x)} {l2.inL x}\n        (lift-prop {l1} {l2.S'} l2.inL x)) >== (==<) {Local.S {l1.S'}} (lift {l2} {l1.S'} l1.inL (l2.inL x)) {l1.inL x} (lift-prop {l2} {l1.S'} l1.inL x) >== qed {Local.S {l1.S'}} (l1.inL x)))\n  (remove_inL {l2} {l2.S'} (lift {l1} {l2.S'} l2.inL o lift {l2} {l1.S'} l1.inL) (id {Local.S {l2.S'}}) (\\lam (x : l2.S) =>\n    (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (lift {l2} {l1.S'} l1.inL (l2.inL x))) {lift {l1} {l2.S'} l2.inL (l1.inL x)}\n      (pmap {Local.S {l1.S'}} {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL) {lift {l2} {l1.S'} l1.inL (l2.inL x)} {l1.inL x}\n        (lift-prop {l2} {l1.S'} l1.inL x)) >== (==<) {Local.S {l2.S'}} (lift {l1} {l2.S'} l2.inL (l1.inL x)) {l2.inL x} (lift-prop {l1} {l2.S'} l2.inL x) >== qed {Local.S {l2.S'}} (l2.inL x)))\n  right"], "Expected type": "Local {U} (p @ i) {\n  | local => {?hidden}\n}", "Expression": "\\new Local {\n  | S => p @ i\n  | local => prop-dpi (\\lam i => ext_coe) (local {l1.S'}) (local {l2.S'}) @ i\n}", "Premises": ["| S' : Local {U}", "| local : isLocal {U} S", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["l2 : Localization ", "l1 : Localization ", "U : Universe", "X : \\hType", "h2 : Path (\\lam (i : I) => X -> S {h1 @ i}) l1.inL l2.inL", "h1 : l1.S' = l2.S'"], "Expected type": "Path (\\lam (i : I) => \\Pi (Z : Local {U}) -> Equiv {S {h1 @ i} -> Z.S} {X -> Z.S} (-o {X} {S {h1 @ i}} {Z.S} (h2 @ i)))\n  l1.local-univ l2.local-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func -o {A B C : \\Type} (f : A -> B) : \\Pi (g : B -> C) -> \\Pi (x : A) -> C => \\lam (g : B -> C) (x : A) => g (f x)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| local-univ (Z : Local {U}) : Equiv {Local.S {S'} -> Z.S} {Localization.S -> Z.S} (-o {Localization.S} {Local.S {S'}} {Z.S} inL)", "| S : \\hType"]}
{"Context": ["l2 : Localization ", "l1 : Localization ", "U : Universe", "X : \\hType", "h2 : Path (\\lam (i : I) => X -> S {h1 @ i}) l1.inL l2.inL", "h1 : l1.S' = l2.S'", "i : I"], "Expected type": "Localization {U} X (h1 @ i) {\n  | inL => h2 @ i\n  | local-univ => {?hidden}\n}", "Expression": "\\new Localization {\n  | S' => h1 @ i\n  | inL => h2 @ i\n  | local-univ => prop-dpi (\\lam i => ext_coe) (local-univ {l1}) (local-univ {l2}) @ i\n}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| local-univ (Z : Local {U}) : Equiv {Local.S {S'} -> Z.S} {Localization.S -> Z.S} (-o {Localization.S} {Local.S {S'}} {Z.S} inL)", "| S : \\hType"]}
{"Context": ["context : List env.Sort", "s : env.Sort", "env : FSignature", "mc : MetaContext env.Sort", "m : mc.metaname s", "arguments : DArray "], "Expected type": "metavar {env} {context} {s} {mc} m\n  (\\new DArray {arity {mc} {s} m} (\\lam (index : Fin (arity {mc} {s} m)) => Term env context (mc.m-domain {s} m !! index) mc)\n    (\\lam (i : Fin (arity {mc} {s} m)) =>\n      apply {env} {mc.m-domain {s} m !! i} {context} {mc} (arguments.at i) {context} (plain-identity {env} {context} {mc}))) = metavar {env} {context} {s} {mc} m arguments", "Expression": "mext {?}", "Premises": ["| m-domain {s : Sort} (metaname s) : List Sort", "\\func apply \\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\n  metavar {env} {new-context} {s} {mc} m (\\new DArray {MetaContext.arity {mc} {s} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\n    (\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\n  func {env} {new-context} {s} {mc} f (\\new DArray {FSignature.arity {env} {s} f}\n    (\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\n    (\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\data Term \\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \n  | var (index : Index {env.Sort} context) (termSort = context !! index)\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\n    (\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "metavar (m : mc.metaname termSort) (DArray {arity {mc} {termSort} m}\n  (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))", "\\func arity \\hlevels  {this : MetaContext} {s : Sort} (m : metaname s) : Nat => length {Sort} (m-domain {s} m)", "\\func mext \\hlevels  {env : FSignature} {context : List env.Sort} {termSort : env.Sort} {mc : MetaContext env.Sort} {m : mc.metaname termSort}\n  {args args' : DArray {arity {mc} {termSort} m}\n    (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)}\n  (eq : \\Pi (index : Fin (arity {mc} {termSort} m)) -> args.at index = args'.at index) :\n  metavar {env} {context} {termSort} {mc} m args = metavar {env} {context} {termSort} {mc} m args' \n=> pmap {DArray {arity {mc} {termSort} m}\n  (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)}\n  {Term env context termSort mc} (metavar {env} {context} {termSort} {mc} m) {args} {args'}\n  (path (\\lam (i : I) => \\new DArray {arity {mc} {termSort} m}\n    (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)\n    (\\lam (j : Fin (arity {mc} {termSort} m)) => eq j @ i)))", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func plain-identity \\hlevels  {env : FSignature} {context : List env.Sort} {mc : MetaContext env.Sort} : Substitution {env} context context mc \n  => \\lam (i : Index {env.Sort} context) => var {env} {context} {context !! i} {mc} i (idp {env.Sort} {context !! i})"]}
{"Context": ["s : env.Sort", "f : env.symbol s", "ms : MetaContext env.Sort", "sublist : SubList {env.Sort} context-a context-b", "context-b : List env.Sort", "env : FSignature", "context-a : List env.Sort", "index : Fin (arity {env} {s} f)"], "Expected type": "append-context-right\n  {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {f !!domain index} = substitution {env} {context-a ++ f !!domain index} {context-b ++ f !!domain index}\n  (extend-right-both {env.Sort} {context-a} {context-b} sublist {f !!domain index}) {ms}", "Expression": "append-context-right-after-subst _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func substitution \\hlevels  {env : FSignature} {narrow-context wide-context : List env.Sort}\n  (sublist : SubList {env.Sort} narrow-context wide-context) {ms : MetaContext env.Sort} :\n  Substitution {env} narrow-context wide-context ms \n=> \\lam (i : Index {env.Sort} narrow-context) => weakening {env} {narrow-context !! i} {narrow-context} {wide-context} {ms}\n  (var {env} {narrow-context} {narrow-context !! i} {ms} i (idp {env.Sort} {narrow-context !! i})) sublist", "| Sort : \\Set", "\\func append-context-right \\hlevels  {env3 : FSignature} {old-context2 new-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\n  (_ : Substitution {env3} old-context2 new-context3 mc3) {additional-context3 : List env.Sort}\n  (index2 : Index {env.Sort} (old-context2 ++ additional-context3)) :\n  Term env3 (new-context3 ++ additional-context3) ((old-context2 ++ additional-context3) !! index2) mc3 \n  | {env}, {nil}, {new-context}, {mc}, subst, {additional-context}, index =>\n  weakening {env} {(nil {env.Sort} ++ additional-context) !! index} {additional-context} {new-context ++ additional-context} {mc}\n    (var {env} {additional-context} {(nil {env.Sort} ++ additional-context) !! index} {mc} index\n      (idp {env.Sort} {(nil {env.Sort} ++ additional-context) !! index}))\n    (id+left {env.Sort} {additional-context} {new-context})\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, zero =>\n  weakening {env} {((a :: old-context) ++ additional-context) !! 0} {new-context} {new-context ++ additional-context} {mc} (subst 0)\n    (id+right {env.Sort} {new-context} {additional-context})\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, suc index => append-context-right\n    {env} {old-context} {new-context} {mc} (\\lam (i : Index {env.Sort} old-context) => subst (suc i)) {additional-context}\n      index", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func append-context-right-after-subst \\hlevels  {env : FSignature} {context-a context-b context-c : List env.Sort} {ms : MetaContext env.Sort}\n  (sublist : SubList {env.Sort} context-a context-b) : append-context-right\n  {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c} = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n  (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms} \n=> path (\\lam (i : I) (index : Index {env.Sort} (context-a ++ context-c)) => partial-fin-induction\n  {env.Sort} {context-a} {context-c} (\\lam (fin : Index {env.Sort} (context-a ++ context-c)) => append-context-right\n    {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c} fin = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n    (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms} fin)\n    (\\lam (fin : Index {env.Sort} context-a) => transportInv\n      {Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms}\n        (\\lam (x : Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms) =>\n        x = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n          (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n          (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n        {append-context-right\n        {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c}\n          (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n        {weakening {env} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-b}\n          {context-b ++ context-c} {ms}\n          (transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context-b p0 ms) {context-a !! fin}\n            {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (substitution {env} {context-a} {context-b} sublist {ms} fin)) (id+right {env.Sort} {context-b} {context-c})}\n        (on-begin {env} {context-a} {context-b} {ms} {context-c} (substitution {env} {context-a} {context-b} sublist {ms}) fin)\n        (transportInv\n        {Term env context-b ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms}\n          (\\lam (x : Term env context-b ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms) =>\n          weakening {env} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-b}\n            {context-b ++ context-c} {ms} x (id+right {env.Sort} {context-b} {context-c}) = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n            (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n          {transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context-b p0 ms) {context-a !! fin}\n            {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (var {env} {context-b} {context-a !! fin} {ms} (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n          {var {env} {context-b} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {ms}\n            (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n            (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context-b !! shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n                (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n              (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n          (transport-var-over-sort\n          {env} {context-b} {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            {ms}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n            (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))\n          (var-extensionality\n          {env} {context-b ++ context-c} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {ms}\n            {shift-index {env.Sort} {context-b} {context-b ++ context-c} (id+right {env.Sort} {context-b} {context-c})\n              (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n            {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n            {proof {env.Sort} {context-b} {context-b ++ context-c}\n              {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (id+right {env.Sort} {context-b} {context-c}) (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context-b !! shift-index {env.Sort} {context-a} {context-b} sublist fin)\n                {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n                (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n                  (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n                (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n            {proof {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-left {env.Sort} {context-a} {context-c} fin)\n              (idp {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin})}\n            (transportInv\n              {Fin (length {env.Sort} (context-b ++ context-c))} (\\lam (x : Fin (length {env.Sort} (context-b ++ context-c))) =>\n              x = shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n                (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n                (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n                {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                  (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                  (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                (over-right-single {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin))\n                (transportInv {Fin (length {env.Sort} (context-b ++ context-c))}\n                  ((=) (expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)))\n                  {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n                    (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n                    (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n                  {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                    (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                    (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                  (right-both-after-expand-left {env.Sort} {context-a} {context-b} {context-c} sublist fin)\n                  (transportInv {Fin (length {env.Sort} (context-b ++ context-c))}\n                    ((=) (expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)))\n                    {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                      (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                      (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                    {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                    (over-right-single {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin))\n                    (idp {Fin (length {env.Sort} (context-b ++ context-c))}\n                      {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)})))))))\n    (\\lam (fin : Index {env.Sort} context-c) => transportInv\n      {Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin) ms}\n        (\\lam (x : Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin) ms) =>\n        x = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n          (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n          (expand-fin-right {env.Sort} {context-a} {context-c} fin))\n        {append-context-right\n        {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c}\n          (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n        {weakening {env} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {context-c}\n          {context-b ++ context-c} {ms}\n          (var {env} {context-c} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {ms} fin\n            (expand-fin-right.correct {env.Sort} {context-a} {context-c} fin)) (id+left {env.Sort} {context-c} {context-b})}\n        (on-end {env} {context-a} {context-b} {ms} {context-c} (substitution {env} {context-a} {context-b} sublist {ms}) fin)\n        (var-extensionality\n        {env} {context-b ++ context-c} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {ms}\n          {shift-index {env.Sort} {context-c} {context-b ++ context-c} (id+left {env.Sort} {context-c} {context-b}) fin}\n          {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n            (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n          {proof {env.Sort} {context-c} {context-b ++ context-c}\n            {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin}\n            (id+left {env.Sort} {context-c} {context-b}) fin (expand-fin-right.correct {env.Sort} {context-a} {context-c} fin)}\n          {proof {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n            {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n            (expand-fin-right {env.Sort} {context-a} {context-c} fin)\n            (idp {env.Sort} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin})}\n          (inv {Fin (length {env.Sort} (context-b ++ context-c))}\n            {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n            {shift-index {env.Sort} {context-c} {context-b ++ context-c} (id+left {env.Sort} {context-c} {context-b}) fin}\n            (right-both-after-expand-right {env.Sort} {context-a} {context-b} sublist {context-c} fin)))) index @ i)", "\\func \\infix 7 !!domain \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \n  => (domain {s} m !! index).1", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["s : env.Sort", "f : env.symbol s", "sublist : SubList {env.Sort} context-b context-c", "ms : MetaContext env.Sort", "env : FSignature", "index : Fin (arity {env} {s} f)", "context-b : List env.Sort", "context-c : List env.Sort"], "Expected type": "append-context-right\n  {env} {context-b} {context-c} {ms} (substitution {env} {context-b} {context-c} sublist {ms}) {f !!domain index} = substitution {env} {context-b ++ f !!domain index} {context-c ++ f !!domain index}\n  (extend-right-both {env.Sort} {context-b} {context-c} sublist {f !!domain index}) {ms}", "Expression": "append-context-right-after-subst _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func substitution \\hlevels  {env : FSignature} {narrow-context wide-context : List env.Sort}\n  (sublist : SubList {env.Sort} narrow-context wide-context) {ms : MetaContext env.Sort} :\n  Substitution {env} narrow-context wide-context ms \n=> \\lam (i : Index {env.Sort} narrow-context) => weakening {env} {narrow-context !! i} {narrow-context} {wide-context} {ms}\n  (var {env} {narrow-context} {narrow-context !! i} {ms} i (idp {env.Sort} {narrow-context !! i})) sublist", "| Sort : \\Set", "\\func append-context-right \\hlevels  {env3 : FSignature} {old-context2 new-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\n  (_ : Substitution {env3} old-context2 new-context3 mc3) {additional-context3 : List env.Sort}\n  (index2 : Index {env.Sort} (old-context2 ++ additional-context3)) :\n  Term env3 (new-context3 ++ additional-context3) ((old-context2 ++ additional-context3) !! index2) mc3 \n  | {env}, {nil}, {new-context}, {mc}, subst, {additional-context}, index =>\n  weakening {env} {(nil {env.Sort} ++ additional-context) !! index} {additional-context} {new-context ++ additional-context} {mc}\n    (var {env} {additional-context} {(nil {env.Sort} ++ additional-context) !! index} {mc} index\n      (idp {env.Sort} {(nil {env.Sort} ++ additional-context) !! index}))\n    (id+left {env.Sort} {additional-context} {new-context})\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, zero =>\n  weakening {env} {((a :: old-context) ++ additional-context) !! 0} {new-context} {new-context ++ additional-context} {mc} (subst 0)\n    (id+right {env.Sort} {new-context} {additional-context})\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, suc index => append-context-right\n    {env} {old-context} {new-context} {mc} (\\lam (i : Index {env.Sort} old-context) => subst (suc i)) {additional-context}\n      index", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func append-context-right-after-subst \\hlevels  {env : FSignature} {context-a context-b context-c : List env.Sort} {ms : MetaContext env.Sort}\n  (sublist : SubList {env.Sort} context-a context-b) : append-context-right\n  {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c} = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n  (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms} \n=> path (\\lam (i : I) (index : Index {env.Sort} (context-a ++ context-c)) => partial-fin-induction\n  {env.Sort} {context-a} {context-c} (\\lam (fin : Index {env.Sort} (context-a ++ context-c)) => append-context-right\n    {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c} fin = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n    (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms} fin)\n    (\\lam (fin : Index {env.Sort} context-a) => transportInv\n      {Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms}\n        (\\lam (x : Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms) =>\n        x = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n          (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n          (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n        {append-context-right\n        {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c}\n          (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n        {weakening {env} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-b}\n          {context-b ++ context-c} {ms}\n          (transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context-b p0 ms) {context-a !! fin}\n            {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (substitution {env} {context-a} {context-b} sublist {ms} fin)) (id+right {env.Sort} {context-b} {context-c})}\n        (on-begin {env} {context-a} {context-b} {ms} {context-c} (substitution {env} {context-a} {context-b} sublist {ms}) fin)\n        (transportInv\n        {Term env context-b ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms}\n          (\\lam (x : Term env context-b ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms) =>\n          weakening {env} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-b}\n            {context-b ++ context-c} {ms} x (id+right {env.Sort} {context-b} {context-c}) = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n            (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n          {transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context-b p0 ms) {context-a !! fin}\n            {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (var {env} {context-b} {context-a !! fin} {ms} (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n          {var {env} {context-b} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {ms}\n            (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n            (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context-b !! shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n                (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n              (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n          (transport-var-over-sort\n          {env} {context-b} {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            {ms}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n            (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))\n          (var-extensionality\n          {env} {context-b ++ context-c} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {ms}\n            {shift-index {env.Sort} {context-b} {context-b ++ context-c} (id+right {env.Sort} {context-b} {context-c})\n              (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n            {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n            {proof {env.Sort} {context-b} {context-b ++ context-c}\n              {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (id+right {env.Sort} {context-b} {context-c}) (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context-b !! shift-index {env.Sort} {context-a} {context-b} sublist fin)\n                {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n                (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n                  (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n                (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n            {proof {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-left {env.Sort} {context-a} {context-c} fin)\n              (idp {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin})}\n            (transportInv\n              {Fin (length {env.Sort} (context-b ++ context-c))} (\\lam (x : Fin (length {env.Sort} (context-b ++ context-c))) =>\n              x = shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n                (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n                (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n                {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                  (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                  (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                (over-right-single {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin))\n                (transportInv {Fin (length {env.Sort} (context-b ++ context-c))}\n                  ((=) (expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)))\n                  {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n                    (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n                    (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n                  {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                    (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                    (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                  (right-both-after-expand-left {env.Sort} {context-a} {context-b} {context-c} sublist fin)\n                  (transportInv {Fin (length {env.Sort} (context-b ++ context-c))}\n                    ((=) (expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)))\n                    {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                      (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                      (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                    {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                    (over-right-single {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin))\n                    (idp {Fin (length {env.Sort} (context-b ++ context-c))}\n                      {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)})))))))\n    (\\lam (fin : Index {env.Sort} context-c) => transportInv\n      {Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin) ms}\n        (\\lam (x : Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin) ms) =>\n        x = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n          (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n          (expand-fin-right {env.Sort} {context-a} {context-c} fin))\n        {append-context-right\n        {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c}\n          (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n        {weakening {env} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {context-c}\n          {context-b ++ context-c} {ms}\n          (var {env} {context-c} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {ms} fin\n            (expand-fin-right.correct {env.Sort} {context-a} {context-c} fin)) (id+left {env.Sort} {context-c} {context-b})}\n        (on-end {env} {context-a} {context-b} {ms} {context-c} (substitution {env} {context-a} {context-b} sublist {ms}) fin)\n        (var-extensionality\n        {env} {context-b ++ context-c} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {ms}\n          {shift-index {env.Sort} {context-c} {context-b ++ context-c} (id+left {env.Sort} {context-c} {context-b}) fin}\n          {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n            (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n          {proof {env.Sort} {context-c} {context-b ++ context-c}\n            {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin}\n            (id+left {env.Sort} {context-c} {context-b}) fin (expand-fin-right.correct {env.Sort} {context-a} {context-c} fin)}\n          {proof {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n            {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n            (expand-fin-right {env.Sort} {context-a} {context-c} fin)\n            (idp {env.Sort} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin})}\n          (inv {Fin (length {env.Sort} (context-b ++ context-c))}\n            {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n            {shift-index {env.Sort} {context-c} {context-b ++ context-c} (id+left {env.Sort} {context-c} {context-b}) fin}\n            (right-both-after-expand-right {env.Sort} {context-a} {context-b} sublist {context-c} fin)))) index @ i)", "\\func \\infix 7 !!domain \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \n  => (domain {s} m !! index).1", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["context-c : List env.Sort", "context-b : List env.Sort", "env : FSignature", "sublist : SubList {env.Sort} context-b context-c", "ms : MetaContext env.Sort", "context-add : List env.Sort"], "Expected type": "append-context-right\n  {env} {context-b} {context-c} {ms} (substitution {env} {context-b} {context-c} sublist {ms}) {context-add} = substitution {env} {context-b ++ context-add} {context-c ++ context-add}\n  (extend-right-both {env.Sort} {context-b} {context-c} sublist {context-add}) {ms}", "Expression": "append-context-right-after-subst _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func substitution \\hlevels  {env : FSignature} {narrow-context wide-context : List env.Sort}\n  (sublist : SubList {env.Sort} narrow-context wide-context) {ms : MetaContext env.Sort} :\n  Substitution {env} narrow-context wide-context ms \n=> \\lam (i : Index {env.Sort} narrow-context) => weakening {env} {narrow-context !! i} {narrow-context} {wide-context} {ms}\n  (var {env} {narrow-context} {narrow-context !! i} {ms} i (idp {env.Sort} {narrow-context !! i})) sublist", "| Sort : \\Set", "\\func append-context-right \\hlevels  {env3 : FSignature} {old-context2 new-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\n  (_ : Substitution {env3} old-context2 new-context3 mc3) {additional-context3 : List env.Sort}\n  (index2 : Index {env.Sort} (old-context2 ++ additional-context3)) :\n  Term env3 (new-context3 ++ additional-context3) ((old-context2 ++ additional-context3) !! index2) mc3 \n  | {env}, {nil}, {new-context}, {mc}, subst, {additional-context}, index =>\n  weakening {env} {(nil {env.Sort} ++ additional-context) !! index} {additional-context} {new-context ++ additional-context} {mc}\n    (var {env} {additional-context} {(nil {env.Sort} ++ additional-context) !! index} {mc} index\n      (idp {env.Sort} {(nil {env.Sort} ++ additional-context) !! index}))\n    (id+left {env.Sort} {additional-context} {new-context})\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, zero =>\n  weakening {env} {((a :: old-context) ++ additional-context) !! 0} {new-context} {new-context ++ additional-context} {mc} (subst 0)\n    (id+right {env.Sort} {new-context} {additional-context})\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, suc index => append-context-right\n    {env} {old-context} {new-context} {mc} (\\lam (i : Index {env.Sort} old-context) => subst (suc i)) {additional-context}\n      index", "\\func append-context-right-after-subst \\hlevels  {env : FSignature} {context-a context-b context-c : List env.Sort} {ms : MetaContext env.Sort}\n  (sublist : SubList {env.Sort} context-a context-b) : append-context-right\n  {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c} = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n  (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms} \n=> path (\\lam (i : I) (index : Index {env.Sort} (context-a ++ context-c)) => partial-fin-induction\n  {env.Sort} {context-a} {context-c} (\\lam (fin : Index {env.Sort} (context-a ++ context-c)) => append-context-right\n    {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c} fin = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n    (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms} fin)\n    (\\lam (fin : Index {env.Sort} context-a) => transportInv\n      {Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms}\n        (\\lam (x : Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms) =>\n        x = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n          (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n          (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n        {append-context-right\n        {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c}\n          (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n        {weakening {env} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-b}\n          {context-b ++ context-c} {ms}\n          (transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context-b p0 ms) {context-a !! fin}\n            {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (substitution {env} {context-a} {context-b} sublist {ms} fin)) (id+right {env.Sort} {context-b} {context-c})}\n        (on-begin {env} {context-a} {context-b} {ms} {context-c} (substitution {env} {context-a} {context-b} sublist {ms}) fin)\n        (transportInv\n        {Term env context-b ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms}\n          (\\lam (x : Term env context-b ((context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin) ms) =>\n          weakening {env} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-b}\n            {context-b ++ context-c} {ms} x (id+right {env.Sort} {context-b} {context-c}) = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n            (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n          {transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context-b p0 ms) {context-a !! fin}\n            {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (var {env} {context-b} {context-a !! fin} {ms} (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n          {var {env} {context-b} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {ms}\n            (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n            (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context-b !! shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n                (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n              (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n          (transport-var-over-sort\n          {env} {context-b} {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n            {ms}\n            (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n              (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n            (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n            (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))\n          (var-extensionality\n          {env} {context-b ++ context-c} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {ms}\n            {shift-index {env.Sort} {context-b} {context-b ++ context-c} (id+right {env.Sort} {context-b} {context-c})\n              (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n            {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n            {proof {env.Sort} {context-b} {context-b ++ context-c}\n              {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (id+right {env.Sort} {context-b} {context-c}) (shift-index {env.Sort} {context-a} {context-b} sublist fin)\n              (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context-b !! shift-index {env.Sort} {context-a} {context-b} sublist fin)\n                {context-a !! fin} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n                (inv {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin} {context-a !! fin}\n                  (expand-fin-left.correct {env.Sort} {context-a} {context-c} fin))\n                (proof {env.Sort} {context-a} {context-b} {context-a !! fin} sublist fin (idp {env.Sort} {context-a !! fin})))}\n            {proof {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-left {env.Sort} {context-a} {context-c} fin)\n              (idp {env.Sort} {(context-a ++ context-c) !! expand-fin-left {env.Sort} {context-a} {context-c} fin})}\n            (transportInv\n              {Fin (length {env.Sort} (context-b ++ context-c))} (\\lam (x : Fin (length {env.Sort} (context-b ++ context-c))) =>\n              x = shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n                (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n                (expand-fin-left {env.Sort} {context-a} {context-c} fin))\n                {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                  (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                  (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                (over-right-single {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin))\n                (transportInv {Fin (length {env.Sort} (context-b ++ context-c))}\n                  ((=) (expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)))\n                  {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n                    (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n                    (expand-fin-left {env.Sort} {context-a} {context-c} fin)}\n                  {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                    (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                    (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                  (right-both-after-expand-left {env.Sort} {context-a} {context-b} {context-c} sublist fin)\n                  (transportInv {Fin (length {env.Sort} (context-b ++ context-c))}\n                    ((=) (expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)))\n                    {shift-index {env.Sort} {context-b} {context-b ++ context-c}\n                      (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n                      (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                    {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)}\n                    (over-right-single {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin))\n                    (idp {Fin (length {env.Sort} (context-b ++ context-c))}\n                      {expand-fin-left {env.Sort} {context-b} {context-c} (shift-index {env.Sort} {context-a} {context-b} sublist fin)})))))))\n    (\\lam (fin : Index {env.Sort} context-c) => transportInv\n      {Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin) ms}\n        (\\lam (x : Term env (context-b ++ context-c) ((context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin) ms) =>\n        x = substitution {env} {context-a ++ context-c} {context-b ++ context-c}\n          (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c}) {ms}\n          (expand-fin-right {env.Sort} {context-a} {context-c} fin))\n        {append-context-right\n        {env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-c}\n          (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n        {weakening {env} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {context-c}\n          {context-b ++ context-c} {ms}\n          (var {env} {context-c} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {ms} fin\n            (expand-fin-right.correct {env.Sort} {context-a} {context-c} fin)) (id+left {env.Sort} {context-c} {context-b})}\n        (on-end {env} {context-a} {context-b} {ms} {context-c} (substitution {env} {context-a} {context-b} sublist {ms}) fin)\n        (var-extensionality\n        {env} {context-b ++ context-c} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin} {ms}\n          {shift-index {env.Sort} {context-c} {context-b ++ context-c} (id+left {env.Sort} {context-c} {context-b}) fin}\n          {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n            (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n          {proof {env.Sort} {context-c} {context-b ++ context-c}\n            {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin}\n            (id+left {env.Sort} {context-c} {context-b}) fin (expand-fin-right.correct {env.Sort} {context-a} {context-c} fin)}\n          {proof {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n            {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin}\n            (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n            (expand-fin-right {env.Sort} {context-a} {context-c} fin)\n            (idp {env.Sort} {(context-a ++ context-c) !! expand-fin-right {env.Sort} {context-a} {context-c} fin})}\n          (inv {Fin (length {env.Sort} (context-b ++ context-c))}\n            {shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n              (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n              (expand-fin-right {env.Sort} {context-a} {context-c} fin)}\n            {shift-index {env.Sort} {context-c} {context-b ++ context-c} (id+left {env.Sort} {context-c} {context-b}) fin}\n            (right-both-after-expand-right {env.Sort} {context-a} {context-b} sublist {context-c} fin)))) index @ i)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["context-c : List env.Sort", "env : FSignature", "fin : Index {env.Sort} context-add", "context-add : List env.Sort"], "Expected type": "shift-index {env.Sort} {context-add} {context-c ++ context-add} (id+left {env.Sort} {context-add} {context-c}) fin = expand-fin-right {env.Sort} {context-c} {context-add} fin", "Expression": "over-left-single {_} {context-c} {context-add} fin", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func id+left {A : \\Type} {i l : List A} : SubList {A} i (l ++ i) => extend-left-single {A} {i} {i} (identity {A} {i}) {l}", "| Sort : \\Set", "\\lemma over-left-single \\hlevels  {A : \\Set} {a b : List A} (ind : Index {A} b) :\n  shift-index {A} {b} {a ++ b} (id+left {A} {b} {a}) ind = expand-fin-right {A} {a} {b} ind ", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["context-b : List env.Sort", "env : FSignature", "fin : Index {env.Sort} context-add", "context-add : List env.Sort"], "Expected type": "shift-index {env.Sort} {context-add} {context-b ++ context-add} (id+left {env.Sort} {context-add} {context-b}) fin = expand-fin-right {env.Sort} {context-b} {context-add} fin", "Expression": "over-left-single {_} {context-b} {context-add} fin", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func id+left {A : \\Type} {i l : List A} : SubList {A} i (l ++ i) => extend-left-single {A} {i} {i} (identity {A} {i}) {l}", "| Sort : \\Set", "\\lemma over-left-single \\hlevels  {A : \\Set} {a b : List A} (ind : Index {A} b) :\n  shift-index {A} {b} {a ++ b} (id+left {A} {b} {a}) ind = expand-fin-right {A} {a} {b} ind ", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["context-c : List env.Sort", "context-b : List env.Sort", "env : FSignature", "fin : Index {env.Sort} context-add", "sublist : SubList {env.Sort} context-b context-c", "context-add : List env.Sort"], "Expected type": "shift-index {env.Sort} {context-b ++ context-add} {context-c ++ context-add}\n  (extend-right-both {env.Sort} {context-b} {context-c} sublist {context-add})\n  (shift-index {env.Sort} {context-add} {context-b ++ context-add} (id+left {env.Sort} {context-add} {context-b}) fin) = expand-fin-right {env.Sort} {context-c} {context-add} fin", "Expression": "rewrite (over-left-single {_} {context-b} {context-add} fin) {?}", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func id+left {A : \\Type} {i l : List A} : SubList {A} i (l ++ i) => extend-left-single {A} {i} {i} (identity {A} {i}) {l}", "| Sort : \\Set", "\\lemma over-left-single \\hlevels  {A : \\Set} {a b : List A} (ind : Index {A} b) :\n  shift-index {A} {b} {a ++ b} (id+left {A} {b} {a}) ind = expand-fin-right {A} {a} {b} ind ", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["context-c : List env.Sort", "context-b : List env.Sort", "env : FSignature", "fin : Index {env.Sort} context-add", "sublist : SubList {env.Sort} context-b context-c", "context-add : List env.Sort"], "Expected type": "shift-index {env.Sort} {context-b ++ context-add} {context-c ++ context-add}\n  (extend-right-both {env.Sort} {context-b} {context-c} sublist {context-add})\n  (shift-index {env.Sort} {context-add} {context-b ++ context-add} (id+left {env.Sort} {context-add} {context-b}) fin) = shift-index {env.Sort} {context-add} {context-c ++ context-add} (id+left {env.Sort} {context-add} {context-c}) fin", "Expression": "rewrite (over-left-single {_} {context-c} {context-add} fin) {?}", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func id+left {A : \\Type} {i l : List A} : SubList {A} i (l ++ i) => extend-left-single {A} {i} {i} (identity {A} {i}) {l}", "| Sort : \\Set", "\\lemma over-left-single \\hlevels  {A : \\Set} {a b : List A} (ind : Index {A} b) :\n  shift-index {A} {b} {a ++ b} (id+left {A} {b} {a}) ind = expand-fin-right {A} {a} {b} ind ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["context-b : List env.Sort", "env : FSignature", "context-add : List env.Sort", "i : Index {env.Sort} context-b"], "Expected type": "(shift-index {env.Sort} {context-b} {context-b ++ context-add} (id+right {env.Sort} {context-b} {context-add}) i,\n  proof {env.Sort} {context-b} {context-b ++ context-add} {context-b !! i} (id+right {env.Sort} {context-b} {context-add}) i\n    (idp {env.Sort} {context-b !! i})) = (expand-fin-left {env.Sort} {context-b} {context-add} i, (right-extension {env.Sort} {context-b} {context-add} i).1)", "Expression": "(right-extension i).2", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func expand-fin-left {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \n  | {A}, {a :: l}, {b}, zero => 0\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\lemma right-extension \\hlevels  {A : \\Set} {a b : List A} (ind : Index {A} a) :\n\\Sigma (eq : a !! ind = (a ++ b) !! expand-fin-left {A} {a} {b} ind) ((shift-index {A} {a} {a ++ b} (id+right {A} {a} {b}) ind,\n  proof {A} {a} {a ++ b} {a !! ind} (id+right {A} {a} {b}) ind (idp {A} {a !! ind})) = (expand-fin-left {A} {a} {b} ind, eq)) ", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func id+right {A : \\Type} {i r : List A} : SubList {A} i (i ++ r) => extend-right-single {A} {i} {i} (identity {A} {i}) {r}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["context : List env.Sort", "mc : MetaContext env.Sort", "env : FSignature", "index : Index {env.Sort} context"], "Expected type": "var {env} {context} {context !! index} {mc}\n  (shift-index {env.Sort} {context} {context} (identity {env.Sort} {context}) index)\n  (proof {env.Sort} {context} {context} {context !! index} (identity {env.Sort} {context}) index\n    (idp {env.Sort} {context !! index})) = var {env} {context} {context !! index} {mc} index (idp {env.Sort} {context !! index})", "Expression": "var-extensionality {?}", "Premises": ["\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "var (index : Index {env.Sort} context) (termSort = context !! index)", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func var-extensionality \\hlevels  {env1 : FSignature} {context1 : List env.Sort} {s1 : env.Sort} {ms1 : MetaContext env.Sort}\n  {i3 i2 : Index {env.Sort} context1} {p3 : s1 = context1 !! i3} {p4 : s1 = context1 !! i2} (_ : i3 = i2) :\n  var {env1} {context1} {s1} {ms1} i3 p3 = var {env1} {context1} {s1} {ms1} i2 p4 \n  | {env}, {context}, {s}, {ms}, {i1}, {i2}, {p1}, {p2}, idp =>\n  pmap {s = context !! i1} {Term env context s ms} (var {env} {context} {s} {ms} i1) {p1} {p2}\n    (prop-pi {s = context !! i1} {p1} {p2})"]}
{"Context": ["env : FSignature", "mc : MetaContext env.Sort", "context : List env.Sort", "s : env.Sort", "m : mc.metaname s", "arguments : DArray "], "Expected type": "metavar {env} {context} {s} {mc} m\n  (\\new DArray {arity {mc} {s} m} (\\lam (index : Fin (arity {mc} {s} m)) => Term env context (mc.m-domain {s} m !! index) mc)\n    (\\lam (i1 : Fin (arity {mc} {s} m)) =>\n      weakening {env} {mc.m-domain {s} m !! i1} {context} {context} {mc} (arguments.at i1) (identity {env.Sort} {context}))) = metavar {env} {context} {s} {mc} m arguments", "Expression": "mext {?}", "Premises": ["| m-domain {s : Sort} (metaname s) : List Sort", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\data Term \\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \n  | var (index : Index {env.Sort} context) (termSort = context !! index)\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\n    (\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "metavar (m : mc.metaname termSort) (DArray {arity {mc} {termSort} m}\n  (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))", "\\func weakening \\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\n  Term env3 wide-context3 s'3 mc3 \n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\n  metavar {env} {wide-context} {s'} {mc} m (\\new DArray {MetaContext.arity {mc} {s'} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\n    (\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\n  func {env} {wide-context} {s'} {mc} f (\\new DArray {FSignature.arity {env} {s'} f}\n    (\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\n    (\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))", "\\func arity \\hlevels  {this : MetaContext} {s : Sort} (m : metaname s) : Nat => length {Sort} (m-domain {s} m)", "\\func mext \\hlevels  {env : FSignature} {context : List env.Sort} {termSort : env.Sort} {mc : MetaContext env.Sort} {m : mc.metaname termSort}\n  {args args' : DArray {arity {mc} {termSort} m}\n    (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)}\n  (eq : \\Pi (index : Fin (arity {mc} {termSort} m)) -> args.at index = args'.at index) :\n  metavar {env} {context} {termSort} {mc} m args = metavar {env} {context} {termSort} {mc} m args' \n=> pmap {DArray {arity {mc} {termSort} m}\n  (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)}\n  {Term env context termSort mc} (metavar {env} {context} {termSort} {mc} m) {args} {args'}\n  (path (\\lam (i : I) => \\new DArray {arity {mc} {termSort} m}\n    (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)\n    (\\lam (j : Fin (arity {mc} {termSort} m)) => eq j @ i)))", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})"]}
{"Context": ["s : env.Sort", "arguments : DArray ", "index : Fin (arity {env} {s} f)", "context : List env.Sort", "mc : MetaContext env.Sort", "env : FSignature", "f : env.symbol s"], "Expected type": "weakening {env} {f !!sort index} {context ++ f !!domain index} {context ++ f !!domain index} {mc} (arguments !! index)\n  (extend-right-both {env.Sort} {context} {context} (identity {env.Sort} {context}) {f !!domain index}) = arguments !! index", "Expression": "rewrite identity-invariant-over-right-extension {?}", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func weakening \\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\n  Term env3 wide-context3 s'3 mc3 \n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\n  metavar {env} {wide-context} {s'} {mc} m (\\new DArray {MetaContext.arity {mc} {s'} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\n    (\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\n  func {env} {wide-context} {s'} {mc} f (\\new DArray {FSignature.arity {env} {s'} f}\n    (\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\n    (\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 7 !!domain \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \n  => (domain {s} m !! index).1", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})", "| Sort : \\Set", "\\func \\infix 7 !!sort \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \n  => (domain {s} m !! index).2", "\\func identity-invariant-over-right-extension {A2 : \\Type} {a2 b2 : List A2} : extend-right-both {A2} {a2} {a2} (identity {A2} {a2}) {b2} = identity {A2} {a2 ++ b2} \n  | {A}, {nil}, {b} =>\n    idp {SubList {A} (nil {A} ++ b) (nil {A} ++ b)} {extend-right-both {A} {nil {A}} {nil {A}} (identity {A} {nil {A}}) {b}}\n  | {A}, {a :: a1}, {b} => pmap {SubList {A} (a1 ++ b) (a1 ++ b)} {SubList {A} (a :: a1 ++ b) (a :: a1 ++ b)}\n    (sublist-match {A} {a} {a1 ++ b} {a} {a1 ++ b} (idp {A} {a})) {extend-right-both {A} {a1} {a1} (identity {A} {a1}) {b}}\n    {identity {A} {a1 ++ b}} (identity-invariant-over-right-extension {A} {a1} {b})", "\\func \\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i "]}
{"Context": ["mc : MetaContext env.Sort", "eq : s = context !! i", "i : Index {env.Sort} context", "env : FSignature", "context : List env.Sort", "s : env.Sort"], "Expected type": "var {env} {context} {s} {mc} i eq = var {env} {context} {s} {mc} i\n  (transport {env.Sort} (\\lam (p0 : env.Sort) => p0 = context !! i) {s} {s} (idp {env.Sort} {s}) eq)", "Expression": "var-extensionality idp", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "var (index : Index {env.Sort} context) (termSort = context !! index)", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func var-extensionality \\hlevels  {env1 : FSignature} {context1 : List env.Sort} {s1 : env.Sort} {ms1 : MetaContext env.Sort}\n  {i3 i2 : Index {env.Sort} context1} {p3 : s1 = context1 !! i3} {p4 : s1 = context1 !! i2} (_ : i3 = i2) :\n  var {env1} {context1} {s1} {ms1} i3 p3 = var {env1} {context1} {s1} {ms1} i2 p4 \n  | {env}, {context}, {s}, {ms}, {i1}, {i2}, {p1}, {p2}, idp =>\n  pmap {s = context !! i1} {Term env context s ms} (var {env} {context} {s} {ms} i1) {p1} {p2}\n    (prop-pi {s = context !! i1} {p1} {p2})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["env : FSignature", "context-res : List env.Sort", "context-b : List env.Sort", "i1 : Index {env.Sort} context-add", "context-add : List env.Sort"], "Expected type": "(context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1 = ((context-res ++ context-b) ++ context-add) !! shift-index {env.Sort} {context-add} {(context-res ++ context-b) ++ context-add}\n  (extend-left-single {env.Sort} {context-add} {context-add} (identity {env.Sort} {context-add}) {context-res ++ context-b})\n  i1", "Expression": "proof (extend-left-single identity) i1 {?}", "Premises": ["\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})"]}
{"Context": ["env : FSignature", "context-b : List env.Sort", "context-add : List env.Sort", "index1 : Index {env.Sort} (nil {env.Sort} ++ context-b ++ context-add)", "context-res : List env.Sort"], "Expected type": "(context-b ++ context-add) !! index1 = (context-res ++ context-b ++ context-add) !! shift-index {env.Sort} {context-b ++ context-add} {context-res ++ context-b ++ context-add} (extend-left-single\n  {env.Sort} {context-b ++ context-add} {context-b ++ context-add} (identity {env.Sort} {context-b ++ context-add})\n    {context-res}) index1", "Expression": "proof (extend-left-single identity) index1 idp", "Premises": ["\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["env : FSignature", "s : env.Sort", "context : List env.Sort"], "Expected type": "MetaContext env.Sort {\n  | metaname => \\lam (s1 : MetaContext.Sort {\\this}) => s1 = s\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (_ : metaname {\\this} s) => context\n}", "Expression": "SingularMetaContext s context", "Premises": ["| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\func SingularMetaContext \\hlevels  {env : FSignature} (point : env.Sort) (context : List env.Sort) : MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => s = point\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (_ : metaname {\\this} s) => context\n} => \\new MetaContext", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["n : Nat", "env : FSignature", "sigs : Fin n -> MetaContext env.Sort"], "Expected type": "MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => \\Sigma (i : Fin n) (metaname {sigs i} s)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {sigs m.1} {s} m.2\n}", "Expression": "ModularMetaContext sigs", "Premises": ["| m-domain {s : Sort} (metaname s) : List Sort", "| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\func ModularMetaContext \\hlevels  {env : FSignature} {n : Nat} (meta-contexts : Fin n -> MetaContext env.Sort) : MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => \\Sigma (i : Fin n) (metaname {meta-contexts i} s)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {meta-contexts m.1} {s} m.2\n} => \\new MetaContext", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)"]}
{"Context": ["b : List A", "a : A", "A : \\Set", "a1 : List A"], "Expected type": "(shift-index {A} {a :: a1} {(a :: a1) ++ b} (id+right {A} {a :: a1} {b}) 0,\n  proof {A} {a :: a1} {(a :: a1) ++ b} {(a :: a1) !! 0} (id+right {A} {a :: a1} {b}) 0 (idp {A} {(a :: a1) !! 0})) = (expand-fin-left {A} {a :: a1} {b} 0, idp {A} {(a :: a1) !! 0})", "Expression": "ext idp", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func expand-fin-left {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \n  | {A}, {a :: l}, {b}, zero => 0\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\infixr 5 :: A (List A)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func id+right {A : \\Type} {i r : List A} : SubList {A} i (i ++ r) => extend-right-single {A} {i} {i} (identity {A} {i}) {r}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["b : List A", "a : A", "A : \\Set", "a1 : List A"], "Expected type": "\\Sigma (eq : (a :: a1) !! 0 = ((a :: a1) ++ b) !! expand-fin-left {A} {a :: a1} {b} 0)\n  ((shift-index {A} {a :: a1} {(a :: a1) ++ b} (id+right {A} {a :: a1} {b}) 0,\n    proof {A} {a :: a1} {(a :: a1) ++ b} {(a :: a1) !! 0} (id+right {A} {a :: a1} {b}) 0 (idp {A} {(a :: a1) !! 0})) = (expand-fin-left {A} {a :: a1} {b} 0, eq))", "Expression": "(idp, ext idp)", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func expand-fin-left {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \n  | {A}, {a :: l}, {b}, zero => 0\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\infixr 5 :: A (List A)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func id+right {A : \\Type} {i r : List A} : SubList {A} i (i ++ r) => extend-right-single {A} {i} {i} (identity {A} {i}) {r}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a1 : List A", "b : List A", "ind : Fin (length {A} a1)", "A : \\Set"], "Expected type": "\\Sigma (eq : a1 !! ind = (a1 ++ b) !! expand-fin-left {A} {a1} {b} ind)\n  ((shift-index {A} {a1} {a1 ++ b} (id+right {A} {a1} {b}) ind,\n    proof {A} {a1} {a1 ++ b} {a1 !! ind} (id+right {A} {a1} {b}) ind (idp {A} {a1 !! ind})) = (expand-fin-left {A} {a1} {b} ind, eq))", "Expression": "right-extension {_} {a1} {b} ind", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func expand-fin-left {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \n  | {A}, {a :: l}, {b}, zero => 0\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\lemma right-extension \\hlevels  {A : \\Set} {a b : List A} (ind : Index {A} a) :\n\\Sigma (eq : a !! ind = (a ++ b) !! expand-fin-left {A} {a} {b} ind) ((shift-index {A} {a} {a ++ b} (id+right {A} {a} {b}) ind,\n  proof {A} {a} {a ++ b} {a !! ind} (id+right {A} {a} {b}) ind (idp {A} {a !! ind})) = (expand-fin-left {A} {a} {b} ind, eq)) ", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func id+right {A : \\Type} {i r : List A} : SubList {A} i (i ++ r) => extend-right-single {A} {i} {i} (identity {A} {i}) {r}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a1 : List A", "a : A", "b : List A", "ind : Fin (length {A} a1)", "sig : \\Sigma (eq : a1 !! ind = (a1 ++ b) !! expand-fin-left {A} {a1} {b} ind)\n  ((shift-index {A} {a1} {a1 ++ b} (id+right {A} {a1} {b}) ind,\n    proof {A} {a1} {a1 ++ b} {a1 !! ind} (id+right {A} {a1} {b}) ind (idp {A} {a1 !! ind})) = (expand-fin-left {A} {a1} {b} ind, eq))", "A : \\Set"], "Expected type": "(shift-index {A} {a :: a1} {(a :: a1) ++ b} (id+right {A} {a :: a1} {b}) (suc ind),\n  proof {A} {a :: a1} {(a :: a1) ++ b} {(a :: a1) !! suc ind} (id+right {A} {a :: a1} {b}) (suc ind)\n    (idp {A} {(a :: a1) !! suc ind})) = (expand-fin-left {A} {a :: a1} {b} (suc ind), sig.1)", "Expression": "ext (pmap fsuc (pmap (\\lam p0 => p0.1) sig.2))", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\infixr 5 :: A (List A)", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func id+right {A : \\Type} {i r : List A} : SubList {A} i (i ++ r) => extend-right-single {A} {i} {i} (identity {A} {i}) {r}", "\\func fsuc \\plevels  \\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func expand-fin-left {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \n  | {A}, {a :: l}, {b}, zero => 0\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat"]}
{"Context": ["a1 : List A", "a : A", "b : List A", "ind : Fin (length {A} a1)", "sig : \\Sigma (eq : a1 !! ind = (a1 ++ b) !! expand-fin-left {A} {a1} {b} ind)\n  ((shift-index {A} {a1} {a1 ++ b} (id+right {A} {a1} {b}) ind,\n    proof {A} {a1} {a1 ++ b} {a1 !! ind} (id+right {A} {a1} {b}) ind (idp {A} {a1 !! ind})) = (expand-fin-left {A} {a1} {b} ind, eq))", "A : \\Set"], "Expected type": "\\Sigma (eq : (a :: a1) !! suc ind = ((a :: a1) ++ b) !! expand-fin-left {A} {a :: a1} {b} (suc ind))\n  ((shift-index {A} {a :: a1} {(a :: a1) ++ b} (id+right {A} {a :: a1} {b}) (suc ind),\n    proof {A} {a :: a1} {(a :: a1) ++ b} {(a :: a1) !! suc ind} (id+right {A} {a :: a1} {b}) (suc ind)\n      (idp {A} {(a :: a1) !! suc ind})) = (expand-fin-left {A} {a :: a1} {b} (suc ind), eq))", "Expression": "(sig.1, ext (pmap fsuc (pmap (\\lam p0 => p0.1) sig.2)))", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\infixr 5 :: A (List A)", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func id+right {A : \\Type} {i r : List A} : SubList {A} i (i ++ r) => extend-right-single {A} {i} {i} (identity {A} {i}) {r}", "\\func fsuc \\plevels  \\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func expand-fin-left {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \n  | {A}, {a :: l}, {b}, zero => 0\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat"]}
{"Context": ["A : \\Set", "b : List A", "point-eq : point = b !! ind", "point : A", "a : List A", "ind : Index {A} b"], "Expected type": "point = (a ++ b) !! shift-index {A} {b} {a ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a}) ind", "Expression": "proof (extend-left-single identity) ind point-eq", "Premises": ["\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["ind : Index {A} b", "A : \\Set", "b : List A"], "Expected type": "(shift-index {A} {b} {nil {A} ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {nil {A}}) ind,\n  proof {A} {b} {nil {A} ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {nil {A}}) ind (idp {A} {b !! ind})) = (expand-fin-right {A} {nil {A}} {b} ind, idp {A} {b !! ind})", "Expression": "ext (over-identity ind)", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "nil", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\lemma over-identity \\hlevels  {A : \\Set} {a : List A} (ind : Index {A} a) : shift-index {A} {a} {a} (identity {A} {a}) ind = ind "]}
{"Context": ["ind : Index {A} b", "A : \\Set", "b : List A"], "Expected type": "\\Sigma (eq2 : b !! ind = (nil {A} ++ b) !! expand-fin-right {A} {nil {A}} {b} ind)\n  ((shift-index {A} {b} {nil {A} ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {nil {A}}) ind,\n    proof {A} {b} {nil {A} ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {nil {A}}) ind (idp {A} {b !! ind})) = (expand-fin-right {A} {nil {A}} {b} ind, eq2))", "Expression": "(idp, ext (over-identity ind))", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "nil", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\lemma over-identity \\hlevels  {A : \\Set} {a : List A} (ind : Index {A} a) : shift-index {A} {a} {a} (identity {A} {a}) ind = ind "]}
{"Context": ["ind : Index {A} b", "a1 : List A", "b : List A", "A : \\Set"], "Expected type": "\\Sigma (eq2 : b !! ind = (a1 ++ b) !! expand-fin-right {A} {a1} {b} ind)\n  ((shift-index {A} {b} {a1 ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a1}) ind,\n    proof {A} {b} {a1 ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {a1}) ind (idp {A} {b !! ind})) = (expand-fin-right {A} {a1} {b} ind, eq2))", "Expression": "left-extension-generic {_} {a1} {b} ind {idp}", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\lemma left-extension-generic \\hlevels  {A : \\Set} {a b : List A} {point : A} (ind : Index {A} b) {point-eq : point = b !! ind} :\n\\Sigma (eq2 : point = (a ++ b) !! expand-fin-right {A} {a} {b} ind)\n  ((shift-index {A} {b} {a ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a}) ind,\n    proof {A} {b} {a ++ b} {point} (extend-left-single {A} {b} {b} (identity {A} {b}) {a}) ind point-eq) = (expand-fin-right {A} {a} {b} ind, eq2)) ", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["ind : Index {A} b", "a : A", "a1 : List A", "sig : \\Sigma (eq2 : b !! ind = (a1 ++ b) !! expand-fin-right {A} {a1} {b} ind)\n  ((shift-index {A} {b} {a1 ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a1}) ind,\n    proof {A} {b} {a1 ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {a1}) ind (idp {A} {b !! ind})) = (expand-fin-right {A} {a1} {b} ind, eq2))", "b : List A", "A : \\Set"], "Expected type": "(shift-index {A} {b} {(a :: a1) ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a :: a1}) ind,\n  proof {A} {b} {(a :: a1) ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {a :: a1}) ind\n    (idp {A} {b !! ind})) = (expand-fin-right {A} {a :: a1} {b} ind, sig.1)", "Expression": "ext (later (rewrite over-skip (pmap fsuc (pmap (\\lam p0 => p0.1) sig.2))))", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\infixr 5 :: A (List A)", "\\lemma over-skip \\hlevels  {A : \\Set} {a b : List A} {point' : A} (sublist : SubList {A} a b) (ind : Index {A} a) :\n  shift-index {A} {a} {point' :: b} (sublist-skip {A} {a} {point'} {b} sublist) ind = suc (shift-index {A} {a} {b} sublist ind) ", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func fsuc \\plevels  \\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat"]}
{"Context": ["ind : Index {A} b", "a : A", "a1 : List A", "sig : \\Sigma (eq2 : b !! ind = (a1 ++ b) !! expand-fin-right {A} {a1} {b} ind)\n  ((shift-index {A} {b} {a1 ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a1}) ind,\n    proof {A} {b} {a1 ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {a1}) ind (idp {A} {b !! ind})) = (expand-fin-right {A} {a1} {b} ind, eq2))", "b : List A", "A : \\Set"], "Expected type": "\\Sigma (eq2 : b !! ind = ((a :: a1) ++ b) !! expand-fin-right {A} {a :: a1} {b} ind)\n  ((shift-index {A} {b} {(a :: a1) ++ b} (extend-left-single {A} {b} {b} (identity {A} {b}) {a :: a1}) ind,\n    proof {A} {b} {(a :: a1) ++ b} {b !! ind} (extend-left-single {A} {b} {b} (identity {A} {b}) {a :: a1}) ind\n      (idp {A} {b !! ind})) = (expand-fin-right {A} {a :: a1} {b} ind, eq2))", "Expression": "(sig.1, ext (later (rewrite over-skip (pmap fsuc (pmap (\\lam p0 => p0.1) sig.2)))))", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "\\infixr 5 :: A (List A)", "\\lemma over-skip \\hlevels  {A : \\Set} {a b : List A} {point' : A} (sublist : SubList {A} a b) (ind : Index {A} a) :\n  shift-index {A} {a} {point' :: b} (sublist-skip {A} {a} {point'} {b} sublist) ind = suc (shift-index {A} {a} {b} sublist ind) ", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func extend-left-single {A1 : \\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \n  | {A}, {l}, {r}, sublist, {nil} => sublist\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})", "\\func fsuc \\plevels  \\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x", "\\func expand-fin-right {A1 : \\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \n  | {A}, {nil}, {b}, i => i\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat"]}
{"Context": ["env : FSignature", "n : Nat", "meta-contexts : Fin n -> MetaContext env.Sort"], "Expected type": "MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => \\Sigma (i : Fin n) (metaname {meta-contexts i} s)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {meta-contexts m.1} {s} m.2\n}", "Expression": "\\new MetaContext {\n  | Sort => Sort\n  | metaname => \\lam s => \\Sigma (i : Fin n) (metaname {meta-contexts i} s)\n  | m-domain => \\lam m => m-domain {meta-contexts m.1} m.2\n}", "Premises": ["| m-domain {s : Sort} (metaname s) : List Sort", "| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)"]}
{"Context": ["point : env.Sort", "env : FSignature", "context : List env.Sort"], "Expected type": "MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => s = point\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (_ : metaname {\\this} s) => context\n}", "Expression": "\\new MetaContext {\n  | Sort => Sort\n  | metaname => \\lam s => s = point\n  | m-domain => \\lam eq => context\n}", "Premises": ["| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["env : FSignature"], "Expected type": "MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n}", "Expression": "\\new MetaContext {\n  | Sort => Sort\n  | metaname => \\lam m => Empty\n  | m-domain => \\lam e => contradiction\n}", "Premises": ["| Sort : \\Set", "| Sort : \\Set", "\\data Empty \\plevels  \\hlevels  ", "| metaname Sort : \\Set"]}
{"Context": [], "Expected type": "RewriteRule {LC-FSignature} lc-term {\n  | rr-mc => BetaRedexContext\n  | rr-l => BetaRedex\n  | rr-r => BetaResult\n  | rr-l-func-root => {?hidden}\n}", "Expression": "\\new RewriteRule {\n  | env => _\n  | s => lc-term\n  | rr-mc => BetaRedexContext\n  | rr-l => BetaRedex\n  | rr-r => BetaResult\n  | rr-l-func-root => T-has-functional-root {LC-FSignature}\n}", "Premises": ["lc-term", "\\func BetaRedex \\plevels  \\hlevels  : Term LC-FSignature (nil {SingularSort}) lc-term BetaRedexContext \n=> func {LC-FSignature} {nil {SingularSort}} {lc-term} {BetaRedexContext} application\n  (\\new DArray {FSignature.arity {LC-FSignature} {lc-term} application}\n    (\\lam (index : Fin (FSignature.arity {LC-FSignature} {lc-term} application)) =>\n      Term LC-FSignature (nil {SingularSort} ++ application !!domain index) (application !!sort index) BetaRedexContext)\n    (\\lam (i : Fin (FSignature.arity {LC-FSignature} {lc-term} application)) => (\\case i \\with {\n      | zero => func {LC-FSignature} {nil {SingularSort} ++ application !!domain 0} {application !!sort 0} {BetaRedexContext} abstraction\n        (\\new DArray {FSignature.arity {LC-FSignature} {application !!sort 0} abstraction}\n          (\\lam (index : Fin (FSignature.arity {LC-FSignature} {application !!sort 0} abstraction)) =>\n          Term LC-FSignature ((nil {SingularSort} ++ application !!domain 0) ++ abstraction !!domain index) (abstraction !!sort index)\n            BetaRedexContext)\n          (\\lam (p0 : Fin (FSignature.arity {LC-FSignature} {application !!sort 0} abstraction)) => (\\case p0 \\with {\n            | zero => metavar {LC-FSignature} {(nil {SingularSort} ++ application !!domain 0) ++ abstraction !!domain 0} {abstraction !!sort 0}\n              {BetaRedexContext} metavar-a (\\new DArray {MetaContext.arity {BetaRedexContext} {abstraction !!sort 0} metavar-a}\n                (\\lam (index : Fin (MetaContext.arity {BetaRedexContext} {abstraction !!sort 0} metavar-a)) =>\n                Term LC-FSignature ((nil {SingularSort} ++ application !!domain 0) ++ abstraction !!domain 0)\n                  (m-domain {BetaRedexContext} {abstraction !!sort 0} metavar-a !! index) BetaRedexContext)\n                (\\lam (p0 : Fin (MetaContext.arity {BetaRedexContext} {abstraction !!sort 0} metavar-a)) => (\\case p0 \\with {\n                  | zero => var {LC-FSignature} {(nil {SingularSort} ++ application !!domain 0) ++ abstraction !!domain 0}\n                    {m-domain {BetaRedexContext} {abstraction !!sort 0} metavar-a !! 0} {BetaRedexContext} 0\n                    (idp {SingularSort} {m-domain {BetaRedexContext} {abstraction !!sort 0} metavar-a !! 0})\n                })))\n          })))\n      | suc zero => metavar {LC-FSignature} {nil {SingularSort} ++ application !!domain 1} {application !!sort 1} {BetaRedexContext} metavar-b\n        (\\new DArray {MetaContext.arity {BetaRedexContext} {application !!sort 1} metavar-b}\n          (\\lam (index : Fin (MetaContext.arity {BetaRedexContext} {application !!sort 1} metavar-b)) =>\n          Term LC-FSignature (nil {SingularSort} ++ application !!domain 1)\n            (m-domain {BetaRedexContext} {application !!sort 1} metavar-b !! index) BetaRedexContext)\n          (\\lam (e : Fin (MetaContext.arity {BetaRedexContext} {application !!sort 1} metavar-b)) => (\\case e \\with {})))\n    })))", "\\func BetaResult \\plevels  \\hlevels  : Term LC-FSignature (nil {SingularSort}) lc-term BetaRedexContext \n=> metavar {LC-FSignature} {nil {SingularSort}} {lc-term} {BetaRedexContext} metavar-a\n  (\\new DArray {arity {BetaRedexContext} {lc-term} metavar-a} (\\lam (index : Fin (arity {BetaRedexContext} {lc-term} metavar-a)) =>\n    Term LC-FSignature (nil {SingularSort}) (m-domain {BetaRedexContext} {lc-term} metavar-a !! index) BetaRedexContext)\n    (\\lam (p0 : Fin (arity {BetaRedexContext} {lc-term} metavar-a)) => (\\case p0 \\with {\n      | zero => metavar {LC-FSignature} {nil {SingularSort}} {m-domain {BetaRedexContext} {lc-term} metavar-a !! 0} {BetaRedexContext} metavar-b\n        (\\new DArray {arity {BetaRedexContext} {m-domain {BetaRedexContext} {lc-term} metavar-a !! 0} metavar-b}\n          (\\lam (index : Fin (arity {BetaRedexContext} {m-domain {BetaRedexContext} {lc-term} metavar-a !! 0} metavar-b)) =>\n          Term LC-FSignature (nil {SingularSort})\n            (m-domain {BetaRedexContext} {m-domain {BetaRedexContext} {lc-term} metavar-a !! 0} metavar-b !! index) BetaRedexContext)\n          (\\lam (e : Fin (arity {BetaRedexContext} {m-domain {BetaRedexContext} {lc-term} metavar-a !! 0} metavar-b)) =>\n            (\\case e \\with {})))\n    })))", "T-has-functional-root", "\\func BetaRedexContext \\hlevels  : MetaContext SingularSort {\n  | metaname => \\lam (_ : Sort {\\this}) => MetaVariables\n  | m-domain => \\lam {s : Sort {\\this}} (var : metaname {\\this} s) => (\\case var \\with {\n    | metavar-a => lc-term :: nil {SingularSort}\n    | metavar-b => nil {SingularSort}\n  })\n} => \\new MetaContext", "| rr-mc : MetaContext (Sort {env})", "func (f : env.symbol termSort) (DArray {arity {env} {termSort} f}\n  (\\lam (index : Fin (arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))"]}
{"Context": [], "Expected type": "MetaContext FSignature.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n}", "Expression": "EmptyMetaContext {LC-FSignature}", "Premises": ["| Sort : \\Set", "| Sort : \\Set", "\\data Empty \\plevels  \\hlevels  ", "| metaname Sort : \\Set", "\\func EmptyMetaContext \\hlevels  {env : FSignature} : MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n} => \\new MetaContext"]}
{"Context": [], "Expected type": "SimpleHigherOrderTermRewritingSystem LC-FSignature (EmptyMetaContext {LC-FSignature}) LC-rules", "Expression": "\\new SimpleHigherOrderTermRewritingSystem {\n  | env => LC-FSignature\n  | set-of-rules => LC-rules\n  | meta-context => EmptyMetaContext {LC-FSignature}\n}", "Premises": ["\\func LC-rules \\hlevels  : RuleRegistry LC-FSignature {\n  | rule-J => \\lam (p0 : Sort {env {\\this}}) => (\\case p0 \\with {\n    | lc-term => \\Sigma\n  })\n  | rule-container => \\lam {p0 : Sort {env {\\this}}} (p1 : rule-J {\\this} p0) => (\\case p0, p1 \\with {\n    | lc-term, () => beta-reduction\n  })\n} => \\new RuleRegistry", "\\func EmptyMetaContext \\hlevels  {env : FSignature} : MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n} => \\new MetaContext"]}
{"Context": ["context-producer : Fin (arity {env {tc}} {s} f) -> MetaContext (Sort {tc.envs f.1})", "s : tc.Sort'", "tc : TheoremContext", "f : symbol s"], "Expected type": "MetaContext FSignature.Sort {\n  | metaname => \\lam (s1 : MetaContext.Sort {\\this}) => \\Sigma (i : Fin (arity {env {tc}} {s} f)) (metaname {context-producer i} s1)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {context-producer m.1} {s} m.2\n}", "Expression": "ModularMetaContext context-producer", "Premises": ["| m-domain {s : Sort} (metaname s) : List Sort", "| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\func arity \\hlevels  {this : FSignature} {s : Sort} (f : symbol s) : Nat => length {\\Sigma (List Sort) Sort} (domain {s} f)", "\\func ModularMetaContext \\hlevels  {env : FSignature} {n : Nat} (meta-contexts : Fin n -> MetaContext env.Sort) : MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => \\Sigma (i : Fin n) (metaname {meta-contexts i} s)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {meta-contexts m.1} {s} m.2\n} => \\new MetaContext", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)"]}
{"Context": ["color : E {tc.Color}", "subst : MetaSubstitution (env {tc}) (nil {tc.Sort'}) inner-mc mc", "context : List tc.Sort'", "A~>B : TopLevelColoredReduction {tc} color {mc} {context} {s} (apply {env {tc}} {context} {nil {tc.Sort'}} {s} {inner-mc} {mc}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {inner-mc} {color}\n    (metavar {tc.envs color} {context} {s} {inner-mc} m arguments)) (sublist-nil-free {tc.Sort'} {context}) subst) B", "m : inner-mc.metaname s", "s : tc.Sort'", "mc : MetaContext tc.Sort'", "inner-mc : MetaContext tc.Sort'", "B : Term (env {tc}) context s mc", "tc : TheoremContext", "arguments : DArray "], "Expected type": "HasColoredRoot {tc} color {context} {s} {mc} (apply {env {tc}} {context} {nil {tc.Sort'}} {s} {inner-mc} {mc}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {inner-mc} {color}\n    (metavar {tc.envs color} {context} {s} {inner-mc} m arguments)) (sublist-nil-free {tc.Sort'} {context}) subst)", "Expression": "extract-root-coloring A~>B", "Premises": ["| Sort' : \\Set", "| Color : DecSet", "nil", "| envs (E {Color}) : FSignature {\n  | Sort => Sort'\n}", "metavar (m : mc.metaname termSort) (DArray {arity {mc} {termSort} m}\n  (\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))", "\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)", "\\func inject-term \\hlevels  {J3 Sort4 : \\Set} (S3 : J3 -> FSignature {\n  | Sort => Sort4\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\new DArray {MetaContext.arity {mc} {s} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\n    (\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\n    (\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\n      (\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\n      (\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))", "| E : \\Set", "\\func sublist-nil-free {A2 : \\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})", "\\func apply \\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\n  (_ : SubList {env.Sort} core-context2 context3)\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\n    var {env} {context} {s} {new-metacontext} index p\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\n      (\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\n          sublist subst))\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\n  func {env} {context} {s} {new-metacontext} f (\\new DArray {FSignature.arity {env} {s} f}\n    (\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\n    (\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))"]}
{"Context": ["color : E {tc.Color}", "index : Index {Sort {tc.envs color}} context", "s : tc.Sort'", "tc : TheoremContext", "context : List tc.Sort'", "mc : MetaContext tc.Sort'", "subst : MetaSubstitution (env {tc}) (nil {tc.Sort'}) inner-mc mc", "B : Term (env {tc}) context s mc", "A~>B : TopLevelColoredReduction {tc} color {mc} {context} {s} (apply {env {tc}} {context} {nil {tc.Sort'}} {s} {inner-mc} {mc}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {inner-mc} {color} (var {tc.envs color} {context} {s} {inner-mc} index p))\n  (sublist-nil-free {tc.Sort'} {context}) subst) B", "p : s = context !! index", "inner-mc : MetaContext tc.Sort'"], "Expected type": "HasColoredRoot {tc} color {context} {s} {mc} (apply {env {tc}} {context} {nil {tc.Sort'}} {s} {inner-mc} {mc}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {inner-mc} {color} (var {tc.envs color} {context} {s} {inner-mc} index p))\n  (sublist-nil-free {tc.Sort'} {context}) subst)", "Expression": "extract-root-coloring A~>B", "Premises": ["| Sort' : \\Set", "var (index : Index {env.Sort} context) (termSort = context !! index)", "| Color : DecSet", "nil", "| envs (E {Color}) : FSignature {\n  | Sort => Sort'\n}", "\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)", "\\func inject-term \\hlevels  {J3 Sort4 : \\Set} (S3 : J3 -> FSignature {\n  | Sort => Sort4\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\new DArray {MetaContext.arity {mc} {s} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\n    (\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\n    (\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\n      (\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\n      (\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))", "| E : \\Set", "\\func sublist-nil-free {A2 : \\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})", "\\func apply \\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\n  (_ : SubList {env.Sort} core-context2 context3)\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\n    var {env} {context} {s} {new-metacontext} index p\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\n      (\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\n          sublist subst))\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\n  func {env} {context} {s} {new-metacontext} f (\\new DArray {FSignature.arity {env} {s} f}\n    (\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\n    (\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))"]}
{"Context": ["producer : Fin n -> MetaContext tc.Sort'", "tc : TheoremContext", "n : Nat"], "Expected type": "MetaContext FSignature.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => \\Sigma (i : Fin n) (metaname {producer i} s)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {producer m.1} {s} m.2\n}", "Expression": "ModularMetaContext producer", "Premises": ["| m-domain {s : Sort} (metaname s) : List Sort", "| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\func ModularMetaContext \\hlevels  {env : FSignature} {n : Nat} (meta-contexts : Fin n -> MetaContext env.Sort) : MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => \\Sigma (i : Fin n) (metaname {meta-contexts i} s)\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (m : metaname {\\this} s) => m-domain {meta-contexts m.1} {s} m.2\n} => \\new MetaContext", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)"]}
{"Context": ["mc : MetaContext tc.Sort'", "global-color : E {tc.Color}", "rd : TopLevelColoredReduction {tc} global-color {mc} {context} {s} A inter", "context : List tc.Sort'", "tc : TheoremContext", "inter : Term (env {tc}) context s mc", "A : Term (env {tc}) context s mc", "s : tc.Sort'"], "Expected type": "HasColoredRoot {tc} global-color {context} {s} {mc} A", "Expression": "extract-root-coloring rd", "Premises": ["\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)"]}
{"Context": ["tc : TheoremContext", "left-color : E {tc.Color}", "mediator : \\Pi (index : Index {\\Sigma (List Sort) Sort} (domain {s} f)) ->\n  Term (env {tc}) (context ++ f !!domain index) (f !!sort index) (EmptyMetaContext {env {tc}})", "s : tc.Sort'", "context : List tc.Sort'", "rd : TopLevelColoredReduction {tc} left-color {EmptyMetaContext {env {tc}}} {context} {s}\n  (func {env {tc}} {context} {s} {EmptyMetaContext {env {tc}}} f\n    (\\new DArray {arity {env {tc}} {s} f} (\\lam (index : Index {\\Sigma (List Sort) Sort} (domain {s} f)) =>\n      Term (env {tc}) (context ++ f !!domain index) (f !!sort index) (EmptyMetaContext {env {tc}})) mediator)) z", "f : symbol s", "z : Term (env {tc}) context s (EmptyMetaContext {env {tc}})"], "Expected type": "HasColoredRoot {tc} left-color {context} {s} {EmptyMetaContext {env {tc}}}\n  (func {env {tc}} {context} {s} {EmptyMetaContext {env {tc}}} f\n    (\\new DArray {arity {env {tc}} {s} f} (\\lam (index : Index {\\Sigma (List Sort) Sort} (domain {s} f)) =>\n      Term (env {tc}) (context ++ f !!domain index) (f !!sort index) (EmptyMetaContext {env {tc}})) mediator))", "Expression": "extract-root-coloring rd", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func Index {A : \\Type} (list : List A) : \\Type => Fin (length {A} list)", "\\func \\infix 7 !!domain \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \n  => (domain {s} m !! index).1", "| Sort : \\Set", "\\func \\infix 7 !!sort \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \n  => (domain {s} m !! index).2", "func (f : env.symbol termSort) (DArray {arity {env} {termSort} f}\n  (\\lam (index : Fin (arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "\\data Term \\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \n  | var (index : Index {env.Sort} context) (termSort = context !! index)\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\n    (\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\func arity \\hlevels  {this : FSignature} {s : Sort} (f : symbol s) : Nat => length {\\Sigma (List Sort) Sort} (domain {s} f)", "\\func EmptyMetaContext \\hlevels  {env : FSignature} : MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n} => \\new MetaContext", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)", "| domain {s : Sort} (symbol s) : List (\\Sigma (List Sort) Sort)", "\\data List \\Type \n  | nil\n  | \\infixr 5 :: A (List A)"]}
{"Context": ["tc : TheoremContext", "right-color : E {tc.Color}", "s : tc.Sort'", "context : List tc.Sort'", "z : Term (env {tc}) context s (EmptyMetaContext {env {tc}})", "f : symbol s", "mediator' : \\Pi (index : Index {\\Sigma (List Sort) Sort} (domain {s} f)) ->\n  Term (env {tc}) (context ++ f !!domain index) (f !!sort index) (EmptyMetaContext {env {tc}})", "rd' : TopLevelColoredReduction {tc} right-color {EmptyMetaContext {env {tc}}} {context} {s}\n  (func {env {tc}} {context} {s} {EmptyMetaContext {env {tc}}} f\n    (\\new DArray {arity {env {tc}} {s} f} (\\lam (index : Index {\\Sigma (List Sort) Sort} (domain {s} f)) =>\n      Term (env {tc}) (context ++ f !!domain index) (f !!sort index) (EmptyMetaContext {env {tc}})) mediator')) z"], "Expected type": "HasColoredRoot {tc} right-color {context} {s} {EmptyMetaContext {env {tc}}}\n  (func {env {tc}} {context} {s} {EmptyMetaContext {env {tc}}} f\n    (\\new DArray {arity {env {tc}} {s} f} (\\lam (index : Index {\\Sigma (List Sort) Sort} (domain {s} f)) =>\n      Term (env {tc}) (context ++ f !!domain index) (f !!sort index) (EmptyMetaContext {env {tc}})) mediator'))", "Expression": "extract-root-coloring rd'", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func Index {A : \\Type} (list : List A) : \\Type => Fin (length {A} list)", "\\func \\infix 7 !!domain \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \n  => (domain {s} m !! index).1", "| Sort : \\Set", "\\func \\infix 7 !!sort \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \n  => (domain {s} m !! index).2", "func (f : env.symbol termSort) (DArray {arity {env} {termSort} f}\n  (\\lam (index : Fin (arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "\\data Term \\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \n  | var (index : Index {env.Sort} context) (termSort = context !! index)\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\n    (\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\func arity \\hlevels  {this : FSignature} {s : Sort} (f : symbol s) : Nat => length {\\Sigma (List Sort) Sort} (domain {s} f)", "\\func EmptyMetaContext \\hlevels  {env : FSignature} : MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n} => \\new MetaContext", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)", "| domain {s : Sort} (symbol s) : List (\\Sigma (List Sort) Sort)", "\\data List \\Type \n  | nil\n  | \\infixr 5 :: A (List A)"]}
{"Context": ["context : List tc.Sort'", "color1 : E {tc.Color}", "tc : TheoremContext", "s : tc.Sort'", "z : Term (env {tc}) context s (EmptyMetaContext {env {tc}})", "A : PureTerm (env {tc}) context s", "rd : TopLevelColoredReduction {tc} color1 {EmptyMetaContext {env {tc}}} {context} {s} A z"], "Expected type": "HasColoredRoot {tc} color1 {context} {s} {EmptyMetaContext {env {tc}}} A", "Expression": "extract-root-coloring rd", "Premises": ["\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\func EmptyMetaContext \\hlevels  {env : FSignature} : MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n} => \\new MetaContext", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)"]}
{"Context": ["z : Term (env {tc}) context s (EmptyMetaContext {env {tc}})", "context : List tc.Sort'", "rd2 : TopLevelColoredReduction {tc} color2 {EmptyMetaContext {env {tc}}} {context} {s} A z", "tc : TheoremContext", "s : tc.Sort'", "A : PureTerm (env {tc}) context s", "color2 : E {tc.Color}"], "Expected type": "HasColoredRoot {tc} color2 {context} {s} {EmptyMetaContext {env {tc}}} A", "Expression": "extract-root-coloring rd2", "Premises": ["\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\func EmptyMetaContext \\hlevels  {env : FSignature} : MetaContext env.Sort {\n  | metaname => \\lam (_ : MetaContext.Sort {\\this}) => Empty\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (e : metaname {\\this} s) => (\\case e \\with {})\n} => \\new MetaContext", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)"]}
{"Context": ["f : symbol {tc.envs gc} s", "s : tc.Sort'", "tc : TheoremContext", "z : Term (env {tc}) context s mc", "gc : E {tc.Color}", "mediator : \\Pi (index : Index {\\Sigma (List Sort) Sort} (domain {s} (gc, f))) ->\n  Term (env {tc}) (context ++ (gc, f) !!domain index) ((gc, f) !!sort index) mc", "color : E {tc.Color}", "mc : MetaContext tc.Sort'", "context : List tc.Sort'", "rd : TopLevelColoredReduction {tc} color {mc} {context} {s} (func {env {tc}} {context} {s} {mc} (gc, f)\n  (\\new DArray {arity {env {tc}} {s} (gc, f)} (\\lam (index : Index {\\Sigma (List Sort) Sort} (domain {s} (gc, f))) =>\n    Term (env {tc}) (context ++ (gc, f) !!domain index) ((gc, f) !!sort index) mc) mediator)) z"], "Expected type": "HasColoredRoot {tc} color {context} {s} {mc} (func {env {tc}} {context} {s} {mc} (gc, f)\n  (\\new DArray {arity {env {tc}} {s} (gc, f)} (\\lam (index : Index {\\Sigma (List Sort) Sort} (domain {s} (gc, f))) =>\n    Term (env {tc}) (context ++ (gc, f) !!domain index) ((gc, f) !!sort index) mc) mediator))", "Expression": "extract-root-coloring rd", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "| Color : DecSet", "\\func Index {A : \\Type} (list : List A) : \\Type => Fin (length {A} list)", "\\func \\infix 7 !!domain \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \n  => (domain {s} m !! index).1", "| Sort : \\Set", "\\func \\infix 7 !!sort \\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \n  => (domain {s} m !! index).2", "func (f : env.symbol termSort) (DArray {arity {env} {termSort} f}\n  (\\lam (index : Fin (arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "\\data Term \\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \n  | var (index : Index {env.Sort} context) (termSort = context !! index)\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\n    (\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\n    (\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))", "\\lemma extract-root-coloring \\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\n  HasColoredRoot {tc} color {context} {s} {mc} A ", "\\func arity \\hlevels  {this : FSignature} {s : Sort} (f : symbol s) : Nat => length {\\Sigma (List Sort) Sort} (domain {s} f)", "\\data HasColoredRoot \\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\with\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)", "| domain {s : Sort} (symbol s) : List (\\Sigma (List Sort) Sort)", "\\data List \\Type \n  | nil\n  | \\infixr 5 :: A (List A)"]}
{"Context": ["context : List tc.Sort'", "tc : TheoremContext", "s : tc.Sort'"], "Expected type": "MetaContext FSignature.Sort {\n  | metaname => \\lam (s1 : MetaContext.Sort {\\this}) => s1 = s\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (_ : metaname {\\this} s) => context\n}", "Expression": "SingularMetaContext s context", "Premises": ["| Sort : \\Set", "| Sort : \\Set", "| metaname Sort : \\Set", "\\func SingularMetaContext \\hlevels  {env : FSignature} (point : env.Sort) (context : List env.Sort) : MetaContext env.Sort {\n  | metaname => \\lam (s : MetaContext.Sort {\\this}) => s = point\n  | m-domain => \\lam {s : MetaContext.Sort {\\this}} (_ : metaname {\\this} s) => context\n} => \\new MetaContext", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["tc : TheoremContext", "new-context : List tc.Sort'"], "Expected type": "identity {tc.Sort'} {new-context} = transport {List Sort} (SubList {Sort} new-context) {new-context ++ nil {tc.Sort'}} {new-context} (++_nil {tc.Sort'} {new-context})\n  (extend-right-single {Sort} {new-context} {new-context} (identity {Sort} {new-context}) {nil {tc.Sort'}})", "Expression": "identity-sublist-contractible {_} {new-context} _ _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "| Sort' : \\Set", "\\func ++_nil {A2 : \\Type} {l1 : List A2} : l1 ++ nil {A2} = l1 \n  | {A}, {nil} => idp {List A} {nil {A} ++ nil {A}}\n  | {A}, {a :: l} => pmap {List A} {List A} ((::) a) {l ++ nil {A}} {l} (++_nil {A} {l})", "\\func extend-right-single {A3 : \\Type} {l1 r : List A3} (_ : SubList {A3} l1 r) {add3 : List A3} : SubList {A3} l1 (r ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => sublist-nil-free {A} {nil {A} ++ add}\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {xs} {y} {ys ++ add} p (extend-right-single {A} {xs} {ys} sublist {add})\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l} {y} {ys ++ add} (extend-right-single {A} {l} {ys} sublist {add})", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Sort : \\Set", "\\func identity-sublist-contractible \\hlevels  {A5 : \\Set} {a4 : List A5} (sl4 sl'4 : SubList {A5} a4 a4) : sl4 = sl'4 \n  | {A}, {nil}, sublist-nil, sublist-nil => idp {SubList {A} (nil {A}) (nil {A})} {sublist-nil {A}}\n  | {A}, {y :: a}, sublist-match p sl, sublist-match p1 sl' => transportInv\n    {y = y} (\\lam (x : y = y) => sublist-match {A} {y} {a} {y} {a} x sl = sublist-match {A} {y} {a} {y} {a} p1 sl') {p} {p1}\n      (prop-isProp {y = y} p p1)\n      (pmap {SubList {A} a a} {SubList {A} (y :: a) (y :: a)} (sublist-match {A} {y} {a} {y} {a} p1) {sl} {sl'}\n        (identity-sublist-contractible {A} {a} sl sl'))\n  | {A}, {y :: a}, sublist-match p sl, sublist-skip sl' => \\case impossible-sublist {A} {y} {a} sl' \\with {}\n  | {A}, {y :: a}, sublist-skip sl, sublist-match p sl' => \\case impossible-sublist {A} {y} {a} sl \\with {}\n  | {A}, {y :: a}, sublist-skip sl, sublist-skip sl' => \\case impossible-sublist {A} {y} {a} sl' \\with {}", "nil", "\\data SubList {A : \\Type} (_ _ : List A) \\with\n  | {A}, nil, nil => sublist-nil\n  | {A}, x :: xs, y :: ys => sublist-match (x = y) (SubList {A} xs ys)\n  | {A}, l, y :: ys => sublist-skip (SubList {A} l ys)", "\\data List \\Type \n  | nil\n  | \\infixr 5 :: A (List A)"]}
{"Context": ["tc : TheoremContext", "context : List tc.Sort'"], "Expected type": "identity {tc.Sort'} {context} = transport {List Sort} (SubList {Sort} context) {context ++ nil {tc.Sort'}} {context} (++_nil {tc.Sort'} {context})\n  (extend-right-single {Sort} {context} {context} (identity {Sort} {context}) {nil {tc.Sort'}})", "Expression": "identity-sublist-contractible {_} {context} _ _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "| Sort' : \\Set", "\\func ++_nil {A2 : \\Type} {l1 : List A2} : l1 ++ nil {A2} = l1 \n  | {A}, {nil} => idp {List A} {nil {A} ++ nil {A}}\n  | {A}, {a :: l} => pmap {List A} {List A} ((::) a) {l ++ nil {A}} {l} (++_nil {A} {l})", "\\func extend-right-single {A3 : \\Type} {l1 r : List A3} (_ : SubList {A3} l1 r) {add3 : List A3} : SubList {A3} l1 (r ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => sublist-nil-free {A} {nil {A} ++ add}\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {xs} {y} {ys ++ add} p (extend-right-single {A} {xs} {ys} sublist {add})\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l} {y} {ys ++ add} (extend-right-single {A} {l} {ys} sublist {add})", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Sort : \\Set", "\\func identity-sublist-contractible \\hlevels  {A5 : \\Set} {a4 : List A5} (sl4 sl'4 : SubList {A5} a4 a4) : sl4 = sl'4 \n  | {A}, {nil}, sublist-nil, sublist-nil => idp {SubList {A} (nil {A}) (nil {A})} {sublist-nil {A}}\n  | {A}, {y :: a}, sublist-match p sl, sublist-match p1 sl' => transportInv\n    {y = y} (\\lam (x : y = y) => sublist-match {A} {y} {a} {y} {a} x sl = sublist-match {A} {y} {a} {y} {a} p1 sl') {p} {p1}\n      (prop-isProp {y = y} p p1)\n      (pmap {SubList {A} a a} {SubList {A} (y :: a) (y :: a)} (sublist-match {A} {y} {a} {y} {a} p1) {sl} {sl'}\n        (identity-sublist-contractible {A} {a} sl sl'))\n  | {A}, {y :: a}, sublist-match p sl, sublist-skip sl' => \\case impossible-sublist {A} {y} {a} sl' \\with {}\n  | {A}, {y :: a}, sublist-skip sl, sublist-match p sl' => \\case impossible-sublist {A} {y} {a} sl \\with {}\n  | {A}, {y :: a}, sublist-skip sl, sublist-skip sl' => \\case impossible-sublist {A} {y} {a} sl' \\with {}", "nil", "\\data SubList {A : \\Type} (_ _ : List A) \\with\n  | {A}, nil, nil => sublist-nil\n  | {A}, x :: xs, y :: ys => sublist-match (x = y) (SubList {A} xs ys)\n  | {A}, l, y :: ys => sublist-skip (SubList {A} l ys)", "\\data List \\Type \n  | nil\n  | \\infixr 5 :: A (List A)"]}
{"Context": ["context-a : List env.Sort", "env : FSignature", "eq : s = context-a !! index", "s : env.Sort", "index : Index {env.Sort} context-a", "context-c : List env.Sort"], "Expected type": "s = (context-a ++ context-c) !! shift-index {env.Sort} {context-a} {context-a ++ context-c}\n  (extend-right-single {env.Sort} {context-a} {context-a} (identity {env.Sort} {context-a}) {context-c}) index", "Expression": "proof (extend-right-single identity) index eq", "Premises": ["\\func proof \\hlevels  {A3 : \\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func shift-index \\hlevels  {A2 : \\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)", "| Sort : \\Set", "\\func \\infixl 9 !! {A1 : \\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \n  | {A}, a :: l, zero => a\n  | {A}, a :: l, suc i => l !! i", "\\func extend-right-single {A3 : \\Type} {l1 r : List A3} (_ : SubList {A3} l1 r) {add3 : List A3} : SubList {A3} l1 (r ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => sublist-nil-free {A} {nil {A} ++ add}\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {xs} {y} {ys ++ add} p (extend-right-single {A} {xs} {ys} sublist {add})\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l} {y} {ys ++ add} (extend-right-single {A} {l} {ys} sublist {add})", "\\func identity {A2 : \\Type} {list1 : List A2} : SubList {A2} list1 list1 \n  | {A}, {nil} => sublist-nil {A}\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})"]}
{"Context": ["B : A -> \\Type", "p0 : \\Sigma (a : A) (B a)", "pB : \\Pi (a : A) -> Contr (B a)", "pA : Contr A", "A : \\Type"], "Expected type": "Contr (\\Sigma (a : A) (B a)) p0 (\\lam (p : \\Sigma (a : A) (B a)) => path (\\lam (i : I) => (\n  \\have arg => (pA.contraction p.1,\n          isContr=>isProp {B p.1} (pB p.1) (transport {A} B {pA.center} {p.1} (pA.contraction p.1) (center {pB pA.center})) p.2)\n    \\in \n          \\let h1 => arg.1\n          \\in (h1 @ i, pathOver {\\lam (i : I) => B (h1 @ i)} {center {pB pA.center}} {p.2} arg.2 @ i))))", "Expression": "make p0 (\\lam p => ext (contraction {pA} p.1, isContr=>isProp (pB p.1) _ _))", "Premises": ["| center : A", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func isContr=>isProp {A : \\Type} (c : Contr A) : isProp A \n  => \\lam (a : A) (a' : A) => inv {A} {c.center} {a} (c.contraction a) *> c.contraction a'", "\\func pathOver {A : I -> \\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p", "\\func make {A : \\Type} (a : A) (p : \\Pi (a' : A) -> a = a') : Contr A a p => \\new Contr", "| contraction (a' : A) : center = a'", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : M.operation = N.operation", "E : Ob", "T : Theory", "M : Model T E", "N : Model T E", "h2 : M.relation = N.relation"], "Expected type": "Path (\\lam (i : I) => \\Pi (S : Sequent {T}) -> T.axioms S -> isSequentTrue {\\new Structure T E {\n  | operation => h1 @ i\n  | relation => h2 @ i\n}} S) M.isModel N.isModel", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Sequent {S : Signature} : \\1-Type \n  => \\Sigma (V : S.Sort -> \\Set) (FinSet (\\Sigma (s : S.Sort) (V s))) (Array (Formula {S} V)) (Formula {S} V)", "| isModel (S : Sequent {T}) (axioms {T} S) : isSequentTrue S", "| axioms Sequent : \\Prop", "\\func isSequentTrue {this : Structure} (S : Sequent {T}) : \\Prop \n  => \\Pi (rho : Env S.1) -> (\\Pi (j : Fin (len {S.3})) -> isFormulaTrue {S.1} rho (S.3 !! j)) -> isFormulaTrue {S.1} rho S.4", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : M.operation = N.operation", "E : Ob", "i : I", "T : Theory", "M : Model T E", "N : Model T E", "h2 : M.relation = N.relation"], "Expected type": "Model T1 E {\n  | operation => h1 @ i\n  | relation => h2 @ i\n  | isModel => {?hidden}\n}", "Expression": "\\new Model {\n  | operation => \\lam {r} => (@) h1 i {r}\n  | relation => h2 @ i\n  | isModel => prop-dpi (\\lam i => ext_coe) (isModel {M}) (isModel {N}) @ i\n}", "Premises": ["| T : Signature", "| isModel (S : Sequent {T}) (axioms {T} S) : isSequentTrue S", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["this : ColimitData", "h1 : (\\lam (j : Ob {J}) => (\n  \\have _ => \\lam {s : Sort {ModelCat.ColimitData.T}} (x : E {F {G} j} s) => idp {M.E s} {funcs {coneMap j} {s} x}\n  \\in \n        \\let | _ => M.E\n             | _ => Sort {ModelCat.ColimitData.T}\n             | _ => E {F {G} j}\n             | l => coneMap {f {\\this} (sec {\\this} C)} j\n        \\in \\new ModelHom {ModelCat.ColimitData.T} (F {G} j) M {\n              | funcs => l.funcs\n              | func-op => {?hidden}\n              | func-rel => {?hidden}\n            })) = (\\lam (j : Ob {J}) => (\n  \\have _ => \\lam {s : Sort {ModelCat.ColimitData.T}} (x : E {F {G} j} s) => idp {M.E s} {funcs {coneMap j} {s} x}\n  \\in \n        \\let | _ => M.E\n             | _ => Sort {ModelCat.ColimitData.T}\n             | _ => E {F {G} j}\n             | _ => coneMap {f {\\this} (sec {\\this} C)} j\n        \\in \\new ModelHom {ModelCat.ColimitData.T} (F {G} j) M {\n              | funcs => funcs {C.coneMap j}\n              | func-op => {?hidden}\n              | func-rel => {?hidden}\n            }))", "this : QEquiv ", "M : Model T", "C : B {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {j j' : Ob} -> \\Pi (h : Hom j j') -> Func {j} {j'} h \u2218 (@) h1 i j = (@) h1 i j')\n  (coneCoh {f {\\this} (sec {\\this} C)}) C.coneCoh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| sec B : A"]}
{"Context": ["ft : \\Pi (j : J.Ob) ->\n  isFormulaTrue {G.F j} {V} (\\lam {s : Sort {T {G.F j}}} (v : V s) => (rho {s} v).1 j) (equality {T1} {V} {s} t t')", "s : T.Sort", "J : Precat", "G : Functor J (ModelPrecat T)", "t : Term {T} V s", "T : Theory", "rho : Env {limitStructure T {J} G} V", "t' : Term {T} V s", "V : T.Sort -> \\Set"], "Expected type": "isFormulaTrue {limitStructure T {J} G} {V} rho (equality {T} {V} {s} t t')", "Expression": "exts (\\lam j => limitStructureInterp t *> ft j *> inv (limitStructureInterp t'))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| F (Ob {C}) : Ob {D}", "\\lemma limitStructureInterp {T1 : Theory} {J : Precat} {G : Functor J (ModelPrecat T1)} {V : T.Sort -> \\Set} {rho : Env {limitStructure T1 {J} G} V}\n  {s : T.Sort} (t : Term {T1} V s) {j : J.Ob} :\n  (interpret {limitStructure T1 {J} G} {V} rho {s} t).1 j = interpret {G.F j} {V} (\\lam {s : Sort {T {G.F j}}} (v : V s) => (rho {s} v).1 j) {s} t ", "\\func isFormulaTrue \\hlevels  {this2 : Structure} {V2 : Sort {T} -> \\Set} (_ : Env V2) (_ : Formula {T} V2) : \\Prop \n  | {this}, {V}, rho, equality {s} t t' => interpret {V} rho {s} t = interpret {V} rho {s} t'\n  | {this}, {V}, rho, predicate P d =>\n  relation P (\\new DArray {len {predDomain {T} P}} (\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))\n    (\\lam (j : Fin (len {predDomain {T} P})) => interpret {V} rho {at {predDomain {T} P} j} (d.at j)))", "equality {s : S.Sort} (Term {S} V s) (Term {S} V s)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func limitStructure (T : Theory) {J : Precat} (G : Functor J (ModelPrecat T)) :\nStructure T (\\lam (s : Sort {Structure.T {\\this}}) => \\Sigma (P : \\Pi (j : J.Ob) -> E {G.F j} s)\n  (\\Pi {j j' : J.Ob} -> \\Pi (h : J.Hom j j') -> funcs {G.Func {j} {j'} h} {s} (P j) = P j')) {\n  | operation => \\lam {r : Sort {Structure.T {\\this}}} (h : Symb {Structure.T {\\this}} r)\n    (d : DArray {len {domain {Structure.T {\\this}} {r} h}}\n      (\\lam (j : Fin (len {domain {Structure.T {\\this}} {r} h})) => E {\\this} (at {domain {Structure.T {\\this}} {r} h} j))) =>\n  (\\lam (j : J.Ob) => operation {G.F j} {r} h (\\new DArray {len {domain {Structure.T {G.F j}} {r} h}}\n    (\\lam (j1 : Fin (len {domain {Structure.T {G.F j}} {r} h})) => E {G.F j} (at {domain {Structure.T {G.F j}} {r} h} j1))\n    (\\lam (k : Fin (len {domain {Structure.T {G.F j}} {r} h})) => (d.at k).1 j)),\n    \\lam {j : J.Ob} {j' : J.Ob} (f : J.Hom j j') =>\n    func-op {G.Func {j} {j'} f} {r} h (\\new DArray {len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h}}\n      (\\lam (j1 : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) =>\n        E {Dom {G.Func {j} {j'} f}} (at {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h} j1))\n      (\\lam (k : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) => (d.at k).1 j)) *> path (\\lam (i : I) => operation {G.F j'} {r} h\n      (\\new DArray {len {T.domain {r} h}} (\\lam (j : Fin (len {T.domain {r} h})) => E {G.F j'} (T.domain {r} h !! j))\n        (\\lam (j1 : Fin (len {T.domain {r} h})) => (d.at j1).2 {j} {j'} f @ i))))\n  | relation => \\lam (P : PredSymb {Structure.T {\\this}}) (d : DArray {len {predDomain {Structure.T {\\this}} P}}\n    (\\lam (j : Fin (len {predDomain {Structure.T {\\this}} P})) => E {\\this} (at {predDomain {Structure.T {\\this}} P} j))) =>\n  \\Pi (j : J.Ob) -> relation {G.F j} P (\\new DArray {len {predDomain {Structure.T {G.F j}} P}}\n    (\\lam (j1 : Fin (len {predDomain {Structure.T {G.F j}} P})) => E {G.F j} (at {predDomain {Structure.T {G.F j}} P} j1))\n    (\\lam (k : Fin (len {predDomain {Structure.T {G.F j}} P})) => (d.at k).1 j))\n} => \\new Structure", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}"]}
{"Context": ["this : Theory", "s : Sort", "d : DArray ", "f : Symb s"], "Expected type": "TruncP (\\Sigma (a : Term (\\lam (_ : Sort) => Empty) s) (qinj {s} a = qapply {s} f d))", "Expression": "map {?} (\\lam g => (apply f (\\lam j => (g j).1),\n  path (qmerge _) *> pmap (\\lam x => qapply f (\\new DArray (\\lam j => QTerm  (domain  f j)) x)) (ext (\\lam j => (g j).2))))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "| Sort : \\Set", "qapply (f : Symb s) (DArray {len {domain {s} f}} (\\lam (j : Fin (len {domain {s} f})) => QTerm (at {domain {s} f} j)))", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| domain {s : Sort} (Symb s) : Array Sort", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "qinj (Term (\\lam (_ : Sort) => Empty) s)", "\\data Term \\hlevels  {S : TermSig} (S.Sort -> \\Set) S.Sort \n  | var (V s)\n  | apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))", "\\data QTerm {this : Theory} Sort : \\Set \n  | qinj (Term (\\lam (_ : Sort) => Empty) s)\n  | qapply (f : Symb s) (DArray {len {domain {s} f}} (\\lam (j : Fin (len {domain {s} f})) => QTerm (at {domain {s} f} j)))\n  | qquot {t t' : Term (\\lam (_ : Sort) => Empty) s} (isTheorem {\\lam (_ : Sort) => Empty} nil (equality {\\lam (_ : Sort) => Empty} {s} t t')) I\n  | qmerge {f : Symb s} (DArray {len {domain {s} f}} (\\lam (j : Fin (len {domain {s} f})) => Term (\\lam (_ : Sort) => Empty) (at {domain {s} f} j))) I", "\\data Empty \\plevels  \\hlevels  ", "| E : \\Set", "qmerge {f : Symb s} (DArray {len {domain {s} f}} (\\lam (j : Fin (len {domain {s} f})) => Term (\\lam (_ : Sort) => Empty) (at {domain {s} f} j))) I", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal ", "x : E {\\this}", "z : E {\\this}", "h1 : U {x AddMonoid.+ y ExUpperReal.+ z} = U {x ExUpperReal.+ (y AddMonoid.+ z)}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {x + y + z}) (U-closed {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal ", "x : E {\\this}", "z : E {\\this}", "h1 : U {x AddMonoid.+ y ExUpperReal.+ z} = U {x ExUpperReal.+ (y AddMonoid.+ z)}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q))) (U-rounded {x + y + z})\n  (U-rounded {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : U {x + y} = U {y + x}", "x : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal ", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {x + y}) (U-closed {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : U {x + y} = U {y + x}", "x : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal ", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q))) (U-rounded {x + y})\n  (U-rounded {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E {\\this}", "h1 : x.U = y.U", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') x.U-closed y.U-closed", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["x : E {\\this}", "h1 : x.U = y.U", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q))) x.U-rounded y.U-rounded", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["c : E {\\this}", "h1 : U {a ExUpperReal.+ b MeetSemilattice.\u2227 c} = U {ExUpperReal.meet (a AddMonoid.+ b) (a AddMonoid.+ c)}", "b : E {\\this}", "a : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal "], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {a + b \u2227 c})\n  (U-closed {(a + b) \u2227 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["c : E {\\this}", "h1 : U {a ExUpperReal.+ b MeetSemilattice.\u2227 c} = U {ExUpperReal.meet (a AddMonoid.+ b) (a AddMonoid.+ c)}", "b : E {\\this}", "a : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q))) (U-rounded {a + b \u2227 c})\n  (U-rounded {(a + b) \u2227 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["c : E {\\this}", "h1 : U {a ExUpperReal.+ (b JoinSemilattice.\u2228 c)} = U {ExUpperReal.join (a AddMonoid.+ b) (a AddMonoid.+ c)}", "b : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal ", "a : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {a + (b \u2228 c)})\n  (U-closed {a + b \u2228 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["c : E {\\this}", "h1 : U {a ExUpperReal.+ (b JoinSemilattice.\u2228 c)} = U {ExUpperReal.join (a AddMonoid.+ b) (a AddMonoid.+ c)}", "b : E {\\this}", "this : BiorderedLatticeAbMonoid ExUpperReal ", "a : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q))) (U-rounded {a + (b \u2228 c)})\n  (U-rounded {a + b \u2228 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : x.U = y.U", "x : UpperReal", "y : UpperReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) arg i q -> q < q' -> (@) arg i q') x.U-closed y.U-closed", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["arg : x.U = y.U", "x : UpperReal", "y : UpperReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) arg i q -> TruncP (\\Sigma (r : Rat) ((@) arg i r) (r < q))) x.U-rounded y.U-rounded", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : x.U = y.U", "x : UpperReal", "y : UpperReal"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) arg i r))) x.U-inh y.U-inh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| U-inh : TruncP (\\Sigma (r : Rat) (U r))", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : U {x UpperRealSemigroup.* y} = U {x ExUpperReal.* y}", "x : UpperReal", "y : UpperReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {x UpperRealSemigroup.* y})\n  (U-closed {x ExUpperReal.* y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\infixl 7 * \\hlevels  (x y : UpperReal) : UpperReal \n=> \\new UpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | U-inh => {?hidden}\n}", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\infixl 7 * \\plevels  \\hlevels  (x y : ExUpperReal) : ExUpperReal \n=> \\new ExUpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n}"]}
{"Context": ["h1 : U {x UpperRealSemigroup.* y} = U {x ExUpperReal.* y}", "x : UpperReal", "y : UpperReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q)))\n  (U-rounded {x UpperRealSemigroup.* y}) (U-rounded {x ExUpperReal.* y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\infixl 7 * \\hlevels  (x y : UpperReal) : UpperReal \n=> \\new UpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | U-inh => {?hidden}\n}", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\infixl 7 * \\plevels  \\hlevels  (x y : ExUpperReal) : ExUpperReal \n=> \\new ExUpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n}", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["V : Set Real", "v : Elem {Real} V", "f : Elem {Real} U -> Real", "fV : \\Pi (x : Elem {Real} U) -> V (f x)", "arg : f p.1 = v.1", "p : A"], "Expected type": "Path (\\lam (i : I) => V (arg @ i)) (f p.1, fV p.1).2 v.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["V : Set Real", "v : Elem {Real} V", "f : Elem {Real} U -> Real", "fV : \\Pi (x : Elem {Real} U) -> V (f x)", "U : Set Real", "p : A"], "Expected type": "TruncP (\\Sigma (x : Elem {Real} U) ((f x, fV x) = v))", "Expression": "inP (p.1, ext p.2)", "Premises": ["inP A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type Elem {X : \\Type} (U : Set X) : \\Type => \\Sigma (x : X) (\\property (U x))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["s : HasSup A", "t : HasSup A", "A : Set Real"], "Expected type": "s = t", "Expression": "ext (isUnique s.2 t.2)", "Premises": ["\\lemma isUnique {A : Set Real} {b b' : Real} (_ : IsSup A b) (_ : IsSup A b') : b = b' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "h1 : L {x AddMonoid.+ y LowerRealAbMonoid.+ z} = L {x LowerRealAbMonoid.+ (y AddMonoid.+ z)}", "x : E {\\this}", "z : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') (L-closed {x + y + z}) (L-closed {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "h1 : L {x AddMonoid.+ y LowerRealAbMonoid.+ z} = L {x LowerRealAbMonoid.+ (y AddMonoid.+ z)}", "x : E {\\this}", "z : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r))) (L-rounded {x + y + z})\n  (L-rounded {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "h1 : L {x AddMonoid.+ y LowerRealAbMonoid.+ z} = L {x LowerRealAbMonoid.+ (y AddMonoid.+ z)}", "x : E {\\this}", "z : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) (L-inh {x + y + z}) (L-inh {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "x : E {\\this}", "h1 : L {x + y} = L {y + x}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') (L-closed {x + y}) (L-closed {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "x : E {\\this}", "h1 : L {x + y} = L {y + x}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r))) (L-rounded {x + y})\n  (L-rounded {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "x : E {\\this}", "h1 : L {x + y} = L {y + x}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) (L-inh {x + y}) (L-inh {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "h1 : x.L = y.L", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') x.L-closed y.L-closed", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["y : E {\\this}", "h1 : x.L = y.L", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r))) x.L-rounded y.L-rounded", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "h1 : x.L = y.L", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) x.L-inh y.L-inh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : L {a LowerRealAbMonoid.+ b MeetSemilattice.\u2227 c} = L {LowerRealAbMonoid.meet (a AddMonoid.+ b) (a AddMonoid.+ c)}", "a : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "c : E {\\this}", "b : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') (L-closed {a + b \u2227 c})\n  (L-closed {(a + b) \u2227 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["h1 : L {a LowerRealAbMonoid.+ b MeetSemilattice.\u2227 c} = L {LowerRealAbMonoid.meet (a AddMonoid.+ b) (a AddMonoid.+ c)}", "a : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "c : E {\\this}", "b : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r))) (L-rounded {a + b \u2227 c})\n  (L-rounded {(a + b) \u2227 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : L {a LowerRealAbMonoid.+ b MeetSemilattice.\u2227 c} = L {LowerRealAbMonoid.meet (a AddMonoid.+ b) (a AddMonoid.+ c)}", "a : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "c : E {\\this}", "b : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) (L-inh {a + b \u2227 c}) (L-inh {(a + b) \u2227 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["c : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "a : E {\\this}", "b : E {\\this}", "h1 : L {a LowerRealAbMonoid.+ (b JoinSemilattice.\u2228 c)} = L {LowerRealAbMonoid.join (a AddMonoid.+ b) (a AddMonoid.+ c)}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') (L-closed {a + (b \u2228 c)})\n  (L-closed {a + b \u2228 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["c : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "a : E {\\this}", "b : E {\\this}", "h1 : L {a LowerRealAbMonoid.+ (b JoinSemilattice.\u2228 c)} = L {LowerRealAbMonoid.join (a AddMonoid.+ b) (a AddMonoid.+ c)}"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r))) (L-rounded {a + (b \u2228 c)})\n  (L-rounded {a + b \u2228 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["c : E {\\this}", "this : BiorderedLatticeAbMonoid LowerReal ", "a : E {\\this}", "b : E {\\this}", "h1 : L {a LowerRealAbMonoid.+ (b JoinSemilattice.\u2228 c)} = L {LowerRealAbMonoid.join (a AddMonoid.+ b) (a AddMonoid.+ c)}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) (L-inh {a + (b \u2228 c)}) (L-inh {a + b \u2228 (a + c)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h2 : x.U = y.U", "y : InfReal", "x : InfReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h2 i q -> q < q' -> (@) h2 i q') x.U-closed y.U-closed", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h2 : x.U = y.U", "y : InfReal", "x : InfReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h2 i q -> TruncP (\\Sigma (r : Rat) ((@) h2 i r) (r < q))) x.U-rounded y.U-rounded", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h2 : x.U = y.U", "y : InfReal", "h1 : x.L = y.L", "x : InfReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> (@) h2 i q -> Empty) x.LU-disjoint y.LU-disjoint", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\data Empty \\plevels  \\hlevels  ", "| LU-disjoint {q : Rat} (L q) (U q) : Empty", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h2 : x.U = y.U", "y : InfReal", "h1 : x.L = y.L", "x : InfReal"], "Expected type": "Path (\\lam (i : I) => \\Pi {q r : Rat} -> q < r -> (@) h1 i q || (@) h2 i r) x.LU-located y.LU-located", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| LU-located {q r : Rat} (q < r) : L q || U r", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["h2 : x.U = y.U", "y : InfReal", "h1 : x.L = y.L", "x : InfReal"], "Expected type": "Path (\\lam (i : I) => \\Pi (B : Rat) -> \\Pi {eps : Rat} -> eps > zro -> (@) h1 i B || (\\Sigma (a : Rat) ((@) h1 i a) ((@) h2 i (a + eps))))\n  x.LU-focus-bound y.LU-focus-bound", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 > E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "| LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\Sigma (a : Rat) (L a) (U (a + eps)))", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["b : E {\\this}", "c : E {\\this}", "this : LinearlyBiorderedAbMonoid InfReal ", "a : E {\\this}"], "Expected type": "a + b \u2227 c = (a + b) \u2227 (a + c)", "Expression": "real-lower-ext {?}", "Premises": ["\\infixl 6 + \\hlevels  (x y : InfReal) : InfReal => \\new InfReal (L {x LowerRealAbMonoid.+ y}) (U {x ExUpperReal.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n}", "\\lemma real-lower-ext \\plevels  \\hlevels  {x y : InfReal} (_ : x = y) : x = y ", "| \\infixl 6 + E E : E", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}"]}
{"Context": ["c : E {\\this}", "this : LinearlyBiorderedAbMonoid InfReal ", "a : E {\\this}", "b : E {\\this}"], "Expected type": "a + (b \u2228 c) = a + b \u2228 (a + c)", "Expression": "real-lower-ext {?}", "Premises": ["\\infixl 6 + \\hlevels  (x y : InfReal) : InfReal => \\new InfReal (L {x LowerRealAbMonoid.+ y}) (U {x ExUpperReal.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n}", "\\lemma real-lower-ext \\plevels  \\hlevels  {x y : InfReal} (_ : x = y) : x = y ", "| \\infixl 6 + E E : E", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}"]}
{"Context": ["x : Rat", "y : Rat"], "Expected type": "fromRat x InfRealAbMonoid.+ fromRat y = fromRat (x RatField.+ y)", "Expression": "real-ext {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| M : Monoid", "| R : Semiring", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "\\func fromRat \\hlevels  (x : Rat) : InfReal (\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\new InfReal {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n}", "\\infixl 6 + \\hlevels  (x y : InfReal) : InfReal => \\new InfReal (L {x LowerRealAbMonoid.+ y}) (U {x ExUpperReal.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n}", "\\lemma real-ext \\plevels  \\hlevels  {x y : InfReal} (_ : \\Pi {a : Rat} -> x.L a <-> y.L a) : x = y ", "\\func + (_ _ : Rat) : Rat \n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\n    makeRat (xNom + yNom) 1 (\\lam (p0 : 1 = 0) => (\\case p0 \\with {}))\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : U {x RealField.* y} = U {x ExUpperReal.* y}", "y : Real", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {x RealField.* y})\n  (U-closed {x ExUpperReal.* y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\infixl 7 * \\plevels  \\hlevels  (x y : ExUpperReal) : ExUpperReal \n=> \\new ExUpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n}", "\\infixl 7 * \\hlevels  (x y : Real) : Real => func {*-cover-def} (x, y)"]}
{"Context": ["h1 : U {x RealField.* y} = U {x ExUpperReal.* y}", "y : Real", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q)))\n  (U-rounded {x RealField.* y}) (U-rounded {x ExUpperReal.* y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\infixl 7 * \\plevels  \\hlevels  (x y : ExUpperReal) : ExUpperReal \n=> \\new ExUpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n}", "\\infixl 7 * \\hlevels  (x y : Real) : Real => func {*-cover-def} (x, y)", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E {\\this}", "M : Monoid", "this : Group (\\Sigma (x : E "], "Expected type": "inverse {\\this} x * x = ide {\\this}", "Expression": "ext (inv-left {x.2})", "Premises": ["| inv-left : inv * val = elem", "| inverse E : E", "| \\infixl 7 * E E : E", "| ide : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : Int) => func {intMap {FinRing {n}}} e = zro) = (\\lam (e : Int) => TruncP (\\Sigma (l : Array (\\Sigma Int (\\Sigma)))\n  (e = BigSum {IntEuclidean} (map {\\Sigma Int (\\Sigma)} {Int} (\\lam (p : \\Sigma Int (\\Sigma)) => p.1 * pos (suc n)) l))))", "n : Nat"], "Expected type": "Path (\\lam (i : I) => (@) h1 i zro) contains_zro contains_zro", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| contains_zro : contains (zro {S})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["h1 : (\\lam (e : Int) => func {intMap {FinRing {n}}} e = zro) = (\\lam (e : Int) => TruncP (\\Sigma (l : Array (\\Sigma Int (\\Sigma)))\n  (e = BigSum {IntEuclidean} (map {\\Sigma Int (\\Sigma)} {Int} (\\lam (p : \\Sigma Int (\\Sigma)) => p.1 * pos (suc n)) l))))", "n : Nat"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i x -> (@) h1 i y -> (@) h1 i (x + y)) contains_+ contains_+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)"]}
{"Context": ["h1 : (\\lam (e : Int) => func {intMap {FinRing {n}}} e = zro) = (\\lam (e : Int) => TruncP (\\Sigma (l : Array (\\Sigma Int (\\Sigma)))\n  (e = BigSum {IntEuclidean} (map {\\Sigma Int (\\Sigma)} {Int} (\\lam (p : \\Sigma Int (\\Sigma)) => p.1 * pos (suc n)) l))))", "n : Nat"], "Expected type": "Path (\\lam (i : I) => \\Pi {r a : E} -> (@) h1 i a -> (@) h1 i (r * a))\n  (ideal-left {KernelC {IntRing} {FinRing {n}} (intMap {FinRing {n}})})\n  (ideal-left {closure1 {IntEuclidean} (pos (suc n))})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "pos Nat", "\\func KernelC \\hlevels  {R : CRing} {S1 : Ring} (f : RingHom R S1) : Ideal R (\\lam (x : E {S}) => f.func x = zro {f.Cod}) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "\\func intMap \\hlevels  {R : Ring} : RingHom IntRing R {\n  | func => intCoef {R}\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| ideal-left {r a : E {S}} (contains a) : contains (r * a)", "\\func closure1 \\hlevels  {R : CRing} (a : R.E) : Ideal R (\\lam (e : E {S {\\this}}) => TruncP (\\Sigma (l : Array (\\Sigma R.E (\\Sigma)))\n  (e = BigSum {R} (map {\\Sigma R.E (\\Sigma)} {R.E} (\\lam (p : \\Sigma R.E (\\Sigma)) => p.1 R.* a) l)))) \n  => closure {R} {\\Sigma} (\\lam (_ : \\Sigma) => a)"]}
{"Context": ["n : Nat", "denom/=0 : 1 /= 0"], "Expected type": "makeRat (pos (suc n)) 1 denom/=0 = makeRat' (pos (suc n)) 1 denom/=0", "Expression": "ext {?} idp", "Premises": ["\\func makeRat \\plevels  \\hlevels  (_ : Int) (denom1 : Nat) (_ : denom1 /= 0) : Rat \n  | nom, suc 0, denom/=0 => fromInt nom\n  | nom, denom, denom/=0 => makeRat' nom denom denom/=0", "pos Nat", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func makeRat' \\plevels  \\hlevels  (_ : Int) (denom2 : Nat) (_ : denom2 /= 0) : Rat \n  | pos 0, denom, denom/=0 => rat (pos 0) 1 {?hidden} {?hidden}\n  | pos (suc n), denom, denom/=0 => \n    \\let! (a, b) => reduce {NatEuclidean} (suc n) denom\n    \\in rat (pos a) b {?hidden} {?hidden}\n  | neg (suc n), denom, denom/=0 => \n    \\let! (a, b) => reduce {NatEuclidean} (suc n) denom\n    \\in rat (neg a) b {?hidden} {?hidden}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat", "\\lemma ext \\plevels  \\hlevels  {x y : Rat} (_ : ratNom x = ratNom y) (_ : ratDenom x = ratDenom y) : x = y "]}
{"Context": ["n : Nat", "denom/=0 : 1 /= 0"], "Expected type": "makeRat (neg (suc n)) 1 denom/=0 = makeRat' (neg (suc n)) 1 denom/=0", "Expression": "ext {?} idp", "Premises": ["\\func makeRat \\plevels  \\hlevels  (_ : Int) (denom1 : Nat) (_ : denom1 /= 0) : Rat \n  | nom, suc 0, denom/=0 => fromInt nom\n  | nom, denom, denom/=0 => makeRat' nom denom denom/=0", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "neg Nat  {\n  | 0 => pos 0\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func makeRat' \\plevels  \\hlevels  (_ : Int) (denom2 : Nat) (_ : denom2 /= 0) : Rat \n  | pos 0, denom, denom/=0 => rat (pos 0) 1 {?hidden} {?hidden}\n  | pos (suc n), denom, denom/=0 => \n    \\let! (a, b) => reduce {NatEuclidean} (suc n) denom\n    \\in rat (pos a) b {?hidden} {?hidden}\n  | neg (suc n), denom, denom/=0 => \n    \\let! (a, b) => reduce {NatEuclidean} (suc n) denom\n    \\in rat (neg a) b {?hidden} {?hidden}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat", "\\lemma ext \\plevels  \\hlevels  {x y : Rat} (_ : ratNom x = ratNom y) (_ : ratDenom x = ratDenom y) : x = y "]}
{"Context": ["xNom : Int", "yNom : Int", "reduced1 : gcd {NatEuclidean} (iabs yNom) 1 = 1", "reduced : gcd {NatEuclidean} (iabs xNom) 1 = 1", "xDenom/=0 : 1 /= 0", "yDenom/=0 : 1 /= 0"], "Expected type": "rat xNom 1 {?hidden} {?hidden} + rat yNom 1 {?hidden} {?hidden} = rat xNom 1 {?hidden} {?hidden} +' rat yNom 1 {?hidden} {?hidden}", "Expression": "ext simplify idp", "Premises": ["\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func + (_ _ : Int) : Int \n  | pos n, pos m => pos (n + m)\n  | pos n, neg m => n - m\n  | neg n, pos m => m - n\n  | neg n, neg m => neg (n + m)", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\lemma ext \\plevels  \\hlevels  {x y : Rat} (_ : ratNom x = ratNom y) (_ : ratDenom x = ratDenom y) : x = y ", "\\func \\infixl 6 +' \\plevels  \\hlevels  (_ _ : Rat) : Rat \n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)", "\\func + (_ _ : Rat) : Rat \n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\n    makeRat (xNom + yNom) 1 (\\lam (p0 : 1 = 0) => (\\case p0 \\with {}))\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)"]}
{"Context": ["nom : Int", "p : ratNom (rat nom denom {?hidden} {?hidden}) = pos 0", "denom : Nat", "denom/=0 : denom /= 0", "reduced : gcd {NatEuclidean} (iabs nom) denom = 1"], "Expected type": "rat nom denom {?hidden} {?hidden} = rat (pos 0) 1 {?hidden} {?hidden}", "Expression": "ext p {?}", "Premises": ["pos Nat", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\lemma ext \\plevels  \\hlevels  {x y : Rat} (_ : ratNom x = ratNom y) (_ : ratDenom x = ratDenom y) : x = y "]}
{"Context": ["d=1 : d = 1", "null : Nat", "c : gcd {NatEuclidean} (iabs (neg (suc n))) d = 1", "d/=0 : d /= 0", "d : Nat"], "Expected type": "fromInt (\\case 0 \\with {\n  | 0 => neg (suc n div d)\n  | suc n1 => neg (suc n div d) - pos 1\n}) = rat (neg (suc n)) d {?hidden} {?hidden}", "Expression": "ext {?} {?}", "Premises": ["pos Nat", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "neg Nat  {\n  | 0 => pos 0\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\data Int \\plevels  \\hlevels  \n  | pos Nat\n  | neg Nat  {\n    | 0 => pos 0\n  }", "\\func \\infixl 8 div \\plevels  \\hlevels  (n m : Nat) : Nat => n div m", "suc Nat", "\\lemma ext \\plevels  \\hlevels  {x y : Rat} (_ : ratNom x = ratNom y) (_ : ratDenom x = ratDenom y) : x = y ", "\\func fromInt \\plevels  \\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}"]}
{"Context": ["h2 : x.U = y.U", "y : Real", "x : Real"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h2 i r))) x.U-inh y.U-inh", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| U-inh : TruncP (\\Sigma (r : Rat) (U r))", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : x.L = y.L", "h2 : x.U = y.U", "y : Real", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi (eps : Rat) -> eps > zro -> TruncP (\\Sigma (a : Rat) ((@) h1 i a) ((@) h2 i (a + eps)))) x.LU-focus\n  y.LU-focus", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| LU-focus (eps : Rat) (eps > zro) : TruncP (\\Sigma (a : Rat) (L a) (U (a + eps)))", "| \\infix 4 > E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') (L-closed {negative {\\this} x + x})\n  (L-closed {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r)))\n  (L-rounded {negative {\\this} x + x}) (L-rounded {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) (L-inh {negative {\\this} x + x}) (L-inh {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h2 i q -> q < q' -> (@) h2 i q') (U-closed {negative {\\this} x + x})\n  (U-closed {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h2 i q -> TruncP (\\Sigma (r : Rat) ((@) h2 i r) (r < q)))\n  (U-rounded {negative {\\this} x + x}) (U-rounded {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> (@) h2 i q -> Empty) (LU-disjoint {negative {\\this} x + x})\n  (LU-disjoint {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "\\data Empty \\plevels  \\hlevels  ", "| LU-disjoint {q : Rat} (L q) (U q) : Empty", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q r : Rat} -> q < r -> (@) h1 i q || (@) h2 i r) (LU-located {negative {\\this} x + x})\n  (LU-located {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| LU-located {q r : Rat} (q < r) : L q || U r", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 < E E : \\Prop", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi (B : Rat) -> \\Pi {eps : Rat} -> eps > zro -> (@) h1 i B || (\\Sigma (a : Rat) ((@) h1 i a) ((@) h2 i (a + eps))))\n  (LU-focus-bound {negative {\\this} x + x}) (LU-focus-bound {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 > E E : \\Prop", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "| LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\Sigma (a : Rat) (L a) (U (a + eps)))", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h2 i r))) (U-inh {negative {\\this} x + x}) (U-inh {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| U-inh : TruncP (\\Sigma (r : Rat) (U r))", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h2 : U {negative {\\this} x + x} = U {zro {\\this}}", "h1 : L {negative {\\this} x + x} = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi (eps : Rat) -> eps > zro -> TruncP (\\Sigma (a : Rat) ((@) h1 i a) ((@) h2 i (a + eps))))\n  (LU-focus {negative {\\this} x + x}) (LU-focus {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| LU-focus (eps : Rat) (eps > zro) : TruncP (\\Sigma (a : Rat) (L a) (U (a + eps)))", "| \\infix 4 > E E : \\Prop", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') x.L-closed (L-closed {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r))) x.L-rounded\n  (L-rounded {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) x.L-inh (L-inh {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h2 i q -> q < q' -> (@) h2 i q') x.U-closed (U-closed {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h2 i q -> TruncP (\\Sigma (r : Rat) ((@) h2 i r) (r < q))) x.U-rounded\n  (U-rounded {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> (@) h2 i q -> Empty) x.LU-disjoint (LU-disjoint {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\data Empty \\plevels  \\hlevels  ", "| LU-disjoint {q : Rat} (L q) (U q) : Empty", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi {q r : Rat} -> q < r -> (@) h1 i q || (@) h2 i r) x.LU-located (LU-located {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| LU-located {q r : Rat} (q < r) : L q || U r", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi (B : Rat) -> \\Pi {eps : Rat} -> eps > zro -> (@) h1 i B || (\\Sigma (a : Rat) ((@) h1 i a) ((@) h2 i (a + eps))))\n  x.LU-focus-bound (LU-focus-bound {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| \\infix 4 > E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "| LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\Sigma (a : Rat) (L a) (U (a + eps)))", "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B"]}
{"Context": ["x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h2 i r))) x.U-inh (U-inh {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| U-inh : TruncP (\\Sigma (r : Rat) (U r))", "\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : x.L = L {zro {\\this}}", "x : E {\\this}", "h2 : x.U = U {zro {\\this}}", "this : LinearlyOrderedAbGroup Real "], "Expected type": "Path (\\lam (i : I) => \\Pi (eps : Rat) -> eps > zro -> TruncP (\\Sigma (a : Rat) ((@) h1 i a) ((@) h2 i (a + eps)))) x.LU-focus\n  (LU-focus {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infixl 6 + E E : E", "| LU-focus (eps : Rat) (eps > zro) : TruncP (\\Sigma (a : Rat) (L a) (U (a + eps)))", "| \\infix 4 > E E : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : U {x RealAbGroup.+ y} = U {x ExUpperReal.+ y}", "y : Real", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q < q' -> (@) h1 i q') (U-closed {x RealAbGroup.+ y})\n  (U-closed {x ExUpperReal.+ y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\infixl 6 + \\plevels  \\hlevels  (x y : ExUpperReal) : ExUpperReal \n=> \\new ExUpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n}", "| \\infix 4 < E E : \\Prop", "\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "| U-closed {q q' : Rat} (U q) (q < q') : U q'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h1 : U {x RealAbGroup.+ y} = U {x ExUpperReal.+ y}", "y : Real", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q)))\n  (U-rounded {x RealAbGroup.+ y}) (U-rounded {x ExUpperReal.+ y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\infixl 6 + \\plevels  \\hlevels  (x y : ExUpperReal) : ExUpperReal \n=> \\new ExUpperReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n}", "| \\infix 4 < E E : \\Prop", "\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "| U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : Real", "h1 : L {x RealAbGroup.+ y} = L {x LowerRealAbMonoid.+ y}", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi {q q' : Rat} -> (@) h1 i q -> q' < q -> (@) h1 i q') (L-closed {x RealAbGroup.+ y})\n  (L-closed {x LowerRealAbMonoid.+ y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| L-closed {q q' : Rat} (L q) (q' < q) : L q'", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}"]}
{"Context": ["y : Real", "h1 : L {x RealAbGroup.+ y} = L {x LowerRealAbMonoid.+ y}", "x : Real"], "Expected type": "Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (q < r)))\n  (L-rounded {x RealAbGroup.+ y}) (L-rounded {x LowerRealAbMonoid.+ y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "| \\infix 4 < E E : \\Prop", "\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "| L-rounded {q : Rat} (L q) : TruncP (\\Sigma (r : Rat) (L r) (q < r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : Real", "h1 : L {x RealAbGroup.+ y} = L {x LowerRealAbMonoid.+ y}", "x : Real"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (r : Rat) ((@) h1 i r))) (L-inh {x RealAbGroup.+ y}) (L-inh {x LowerRealAbMonoid.+ y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "| L-inh : TruncP (\\Sigma (r : Rat) (L r))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : Rat", "y : Rat"], "Expected type": "fromRat x RealAbGroup.+ fromRat y = fromRat (x RatField.+ y)", "Expression": "real-lower-ext {?}", "Premises": ["\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "\\lemma real-lower-ext \\plevels  \\hlevels  {x y : Real} (_ : x = y) : x = y ", "\\func + (_ _ : Rat) : Rat \n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\n    makeRat (xNom + yNom) 1 (\\lam (p0 : 1 = 0) => (\\case p0 \\with {}))\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)", "\\func fromRat \\hlevels  (x : Rat) : Real (\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\new Real {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : Real", "x : Real"], "Expected type": "x RealAbGroup.+ y = x InfRealAbMonoid.+ y", "Expression": "real-lower-ext {?}", "Premises": ["\\lemma real-lower-ext \\plevels  \\hlevels  {x y : InfReal} (_ : x = y) : x = y ", "\\infixl 6 + \\hlevels  (x y : Real) : Real => \\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "\\infixl 6 + \\hlevels  (x y : LowerReal) : LowerReal \n=> \\new LowerReal (\\lam (a : Rat) => TruncP (\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b + c))) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\infixl 6 + \\hlevels  (x y : InfReal) : InfReal => \\new InfReal (L {x LowerRealAbMonoid.+ y}) (U {x ExUpperReal.+ y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n}"]}
{"Context": ["x : Rat", "y : Rat"], "Expected type": "RealAbGroup.join (fromRat x) (fromRat y) = fromRat (x JoinSemilattice.\u2228 y)", "Expression": "real-ext {?}", "Premises": ["\\data Rat \\plevels  \\hlevels  \n  | rat (nom : Int) (denom : Nat) (\\property (denom /= 0)) (\\property (gcd {NatEuclidean} (iabs nom) denom = 1))", "join \\plevels  \\hlevels  (x y : Real) : Real => \\new Real (L {InfRealAbMonoid.join x y}) (U {InfRealAbMonoid.join x y}) {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}", "\\func join (_ _ : Rat) : Rat \n  | rat n1 d1 denom/=0 reduced, rat n2 d2 denom/=0 reduced => \\case dec<_<= {IntRing} (n1 * pos d2) (n2 * pos d1) \\with {\n    | inl x<y => rat n2 d2 {?hidden} {?hidden}\n    | inr y<=x => rat n1 d1 {?hidden} {?hidden}\n  }", "| join \\alias \\infixl 6 \u2228 E E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma real-ext \\plevels  \\hlevels  {x y : Real} (_ : \\Pi {a : Rat} -> x.L a <-> y.L a) : x = y ", "\\func fromRat \\hlevels  (x : Rat) : Real (\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\new Real {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}"]}
{"Context": ["this : Embedding ", "p : A {\\this}", "A : \\Type", "p' : A {\\this}", "B : A -> \\Prop"], "Expected type": "Retraction {p = p'} {f {\\this} p = f {\\this} p'} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {p} {p'}) {\n  | sec => \\lam (q : B {\\this}) => path (\\lam (i : I) => (q @ i, prop-dpi (\\lam (i : I) => B1 (q @ i)) p.2 p'.2 @ i))\n  | f_sec => idpe {p.1 = p'.1}\n}", "Expression": "\\new Retraction {\n  | sec => \\lam q => ext q\n  | f_sec => idpe\n}", "Premises": ["\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| f A : B", "| B : \\Type", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| A : \\Type", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func idpe {A : \\Type} (a : A) : a = a => idp {A} {a}"]}
{"Context": ["arg : \\Sigma (p1 : L.L = L'.L) (transport {Locale} (\\lam (x : Locale) => VSheaf CRingCat x) {L.L} {L'.L} p1 L.R = L'.R)", "i : I", "L : RingedLocale", "L' : RingedLocale"], "Expected type": "RingedLocale (arg.1 @ i) (pathOver {\\lam (i : I) => VSheaf CRingCat (arg.1 @ i)} {L.R} {L'.R} arg.2 @ i)", "Expression": "\\new RingedLocale {\n  | L => arg.1 @ i\n  | R => pathOver {\\lam i => ext_coe} arg.2 @ i\n}", "Premises": ["| R : VSheaf CRingCat L", "\\func pathOver {A : I -> \\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p"]}
{"Context": ["h1 : func {f#.trans a} = func {g#.trans a}", "a : E {M.L}", "f : FrameHom M.L L.L", "L : RingedLocale", "f# : NatTrans ", "g# : NatTrans ", "M : RingedLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {Functor.F {VPresheaf.F {M.R}} a}} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {f#.trans a}) (func-+ {g#.trans a})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| R : VSheaf CRingCat L", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : func {f#.trans a} = func {g#.trans a}", "a : E {M.L}", "f : FrameHom M.L L.L", "L : RingedLocale", "f# : NatTrans ", "g# : NatTrans ", "M : RingedLocale"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {Functor.F {VPresheaf.F {M.R}} a}) = ide {Functor.F {VPresheaf.F {L.R}} (f.func a)})\n  (func-ide {f#.trans a}) (func-ide {g#.trans a})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| R : VSheaf CRingCat L", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| ide : E"]}
{"Context": ["h1 : func {f#.trans a} = func {g#.trans a}", "a : E {M.L}", "f : FrameHom M.L L.L", "L : RingedLocale", "f# : NatTrans ", "g# : NatTrans ", "M : RingedLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {Functor.F {VPresheaf.F {M.R}} a}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y)\n  (func-* {f#.trans a}) (func-* {g#.trans a})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| R : VSheaf CRingCat L", "| \\infixl 7 * E E : E", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : FrameHom M.L L.L", "L : RingedLocale", "h1 : (\\lam (X : E {M.L}) => (\n  \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} X}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          {func {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) X)}\n            (func {g#.trans X} x)} {func {f#.trans X} x} (q X x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))}\n          {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))) =>\n            h.func (func {g#.trans X} x)) {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (id (f.func X))}\n          {id (Functor.F {VPresheaf.F {L.R}} (f.func X))} (Func-id {VPresheaf.F {L.R}} {f.func X})\n  \\in \n        \\let _ => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} X}) => arg e @ i)\n        \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} X) (Functor.F {VPresheaf.F {L.R}} (f.func X)) {\n              | func => func {f#.trans X}\n              | func-+ => {?hidden}\n              | func-ide => {?hidden}\n              | func-* => {?hidden}\n            })) = (\\lam (X : E {M.L}) => (\n  \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} X}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          {func {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) X)}\n            (func {g#.trans X} x)} {func {f#.trans X} x} (q X x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))}\n          {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))) =>\n            h.func (func {g#.trans X} x)) {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (id (f.func X))}\n          {id (Functor.F {VPresheaf.F {L.R}} (f.func X))} (Func-id {VPresheaf.F {L.R}} {f.func X})\n  \\in \n        \\let _ => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} X}) => arg e @ i)\n        \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} X) (Functor.F {VPresheaf.F {L.R}} (f.func X)) {\n              | func => func {g#.trans X}\n              | func-+ => {?hidden}\n              | func-ide => {?hidden}\n              | func-* => {?hidden}\n            }))", "f# : NatTrans ", "g# : NatTrans ", "M : RingedLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} -> \\Pi (f1 : Hom X Y) -> (@) h1 i Y \u2218 Func {VPresheaf.F {M.R}} {X} {Y} f1 = Func {X} {Y} f1 \u2218 (@) h1 i X)\n  f#.natural g#.natural", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| R : VSheaf CRingCat L", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["f : FrameHom M.L L.L", "i : I", "L : RingedLocale", "h1 : (\\lam (X : E {M.L}) => (\n  \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} X}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          {func {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) X)}\n            (func {g#.trans X} x)} {func {f#.trans X} x} (q X x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))}\n          {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))) =>\n            h.func (func {g#.trans X} x)) {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (id (f.func X))}\n          {id (Functor.F {VPresheaf.F {L.R}} (f.func X))} (Func-id {VPresheaf.F {L.R}} {f.func X})\n  \\in \n        \\let _ => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} X}) => arg e @ i)\n        \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} X) (Functor.F {VPresheaf.F {L.R}} (f.func X)) {\n              | func => func {f#.trans X}\n              | func-+ => {?hidden}\n              | func-ide => {?hidden}\n              | func-* => {?hidden}\n            })) = (\\lam (X : E {M.L}) => (\n  \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} X}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          {func {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) X)}\n            (func {g#.trans X} x)} {func {f#.trans X} x} (q X x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))}\n          {E {Functor.F {VPresheaf.F {L.R}} (f.func X)}}\n          (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func X)) (Functor.F {VPresheaf.F {L.R}} (f.func X))) =>\n            h.func (func {g#.trans X} x)) {Func {VPresheaf.F {L.R}} {f.func X} {f.func X} (id (f.func X))}\n          {id (Functor.F {VPresheaf.F {L.R}} (f.func X))} (Func-id {VPresheaf.F {L.R}} {f.func X})\n  \\in \n        \\let _ => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} X}) => arg e @ i)\n        \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} X) (Functor.F {VPresheaf.F {L.R}} (f.func X)) {\n              | func => func {g#.trans X}\n              | func-+ => {?hidden}\n              | func-ide => {?hidden}\n              | func-* => {?hidden}\n            }))", "f# : NatTrans ", "g# : NatTrans ", "arg : \\Pi (a : E {M.L}) -> (\n  \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} a}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func a)}}\n          {func {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) a)}\n            (func {g#.trans a} x)} {func {f#.trans a} x} (q a x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func a)) (Functor.F {VPresheaf.F {L.R}} (f.func a))}\n          {E {Functor.F {VPresheaf.F {L.R}} (f.func a)}}\n          (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func a)) (Functor.F {VPresheaf.F {L.R}} (f.func a))) =>\n            h.func (func {g#.trans a} x)) {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (id (f.func a))}\n          {id (Functor.F {VPresheaf.F {L.R}} (f.func a))} (Func-id {VPresheaf.F {L.R}} {f.func a})\n  \\in \n        \\let _ => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} a}) => arg e @ i)\n        \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} a) (Functor.F {VPresheaf.F {L.R}} (f.func a)) {\n              | func => func {f#.trans a}\n              | func-+ => {?hidden}\n              | func-ide => {?hidden}\n              | func-* => {?hidden}\n            }) = (\n  \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} a}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func a)}}\n          {func {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) a)}\n            (func {g#.trans a} x)} {func {f#.trans a} x} (q a x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func a)) (Functor.F {VPresheaf.F {L.R}} (f.func a))}\n          {E {Functor.F {VPresheaf.F {L.R}} (f.func a)}}\n          (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func a)) (Functor.F {VPresheaf.F {L.R}} (f.func a))) =>\n            h.func (func {g#.trans a} x)) {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (id (f.func a))}\n          {id (Functor.F {VPresheaf.F {L.R}} (f.func a))} (Func-id {VPresheaf.F {L.R}} {f.func a})\n  \\in \n        \\let _ => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} a}) => arg e @ i)\n        \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} a) (Functor.F {VPresheaf.F {L.R}} (f.func a)) {\n              | func => func {g#.trans a}\n              | func-+ => {?hidden}\n              | func-ide => {?hidden}\n              | func-* => {?hidden}\n            })", "M : RingedLocale"], "Expected type": "NatTrans {Precat.op {M.L}} {CRingCat} (VPresheaf.F {M.R})\n  (Comp {Precat.op {M.L}} {Precat.op {L.L}} {CRingCat} (VPresheaf.F {L.R}) (Functor.op {functor {f}})) {\n  | trans => \\lam (X : Ob {C {\\this}}) => arg X @ i\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam X => arg X @ i\n  | natural => \\lam {X} => (@) (prop-dpi (\\lam i => ext_coe) (natural {f#}) (natural {g#})) i {X}\n}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| F : Functor (op {C}) D", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| C : Precat", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| L : Locale", "| R : VSheaf CRingCat L", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\func functor \\hlevels  {this2 : FrameHom} : Functor Dom Cod func {\n  | Func => func-<=\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X", "\\func Comp \\plevels obj >= hom \\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\lam (X : Ob {C {\\this}}) => G.F (F.F X)) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (f : Hom {C {\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}"]}
{"Context": ["X : Ob {C {\\this}}", "p : Hom {C {\\this}} X Y", "this : NatTrans ", "Y : Ob {C {\\this}}", "arg : func {Func {VPresheaf.F {L.R}} {X} {func {id L.L} Y} p} = func {Func {VPresheaf.F {L.R}} {X} {func {id L.L} Y} (Func {X} {Y} p)}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {Functor.F {NatTrans.F {\\this}} X}} -> (@) arg i (x + y) = (@) arg i x + (@) arg i y)\n  (func-+ {trans {\\this} Y \u2218 Func {NatTrans.F {\\this}} {X} {Y} p}) (func-+ {Func {G {\\this}} {X} {Y} p \u2218 trans {\\this} X})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| G : Functor C D", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| F : Functor C D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["X : Ob {C {\\this}}", "p : Hom {C {\\this}} X Y", "this : NatTrans ", "Y : Ob {C {\\this}}", "arg : func {Func {VPresheaf.F {L.R}} {X} {func {id L.L} Y} p} = func {Func {VPresheaf.F {L.R}} {X} {func {id L.L} Y} (Func {X} {Y} p)}"], "Expected type": "Path (\\lam (i : I) => (@) arg i (ide {Functor.F {NatTrans.F {\\this}} X}) = ide {Functor.F {G {\\this}} Y})\n  (func-ide {trans {\\this} Y \u2218 Func {NatTrans.F {\\this}} {X} {Y} p})\n  (func-ide {Func {G {\\this}} {X} {Y} p \u2218 trans {\\this} X})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "| G : Functor C D", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E", "| F : Functor C D"]}
{"Context": ["X : Ob {C {\\this}}", "p : Hom {C {\\this}} X Y", "this : NatTrans ", "Y : Ob {C {\\this}}", "arg : func {Func {VPresheaf.F {L.R}} {X} {func {id L.L} Y} p} = func {Func {VPresheaf.F {L.R}} {X} {func {id L.L} Y} (Func {X} {Y} p)}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {Functor.F {NatTrans.F {\\this}} X}} -> (@) arg i (x * y) = (@) arg i x * (@) arg i y)\n  (func-* {trans {\\this} Y \u2218 Func {NatTrans.F {\\this}} {X} {Y} p}) (func-* {Func {G {\\this}} {X} {Y} p \u2218 trans {\\this} X})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| G : Functor C D", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| F : Functor C D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : RingedLocaleHom L1 L1 (id L.L) (\\new NatTrans ", "L : RingedLocale"], "Expected type": "NatTrans {Precat.op {L {Cod {\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\this}}})\n  (VPresheaf.F {direct_image_locale {L {RingedLocaleHom.Dom {\\this}}} {L {Cod {\\this}}} (f {\\this}) (R {RingedLocaleHom.Dom {\\this}})}) {\n  | trans => \\lam (x : Ob {C {\\this}}) => id (Functor.F {VPresheaf.F {L.R}} x)\n  | natural => {?hidden}\n}", "Expression": "\\new NatTrans {\n  | trans => \\lam x => id _\n  | natural => \\lam p => ext $ pmap (\\lam x => (Func {F {R {L}}} x).func) prop-pi\n}", "Premises": ["| Hom Ob Ob : \\Set", "| F : Functor (op {C}) D", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "| D : Precat", "| F : Functor C D", "\\lemma prop-pi \\plevels  \\hlevels  {A : \\Prop} {a a' : A} : a = a' ", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Dom : RingedLocale", "| F (Ob {C}) : Ob {D}", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\lemma direct_image_locale \\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\n  | C => L\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) ", "| func (E {Dom}) : E {Cod}", "| C : Precat", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| L : Locale", "| R : VSheaf CRingCat L", "| Dom : BaseSet", "| id (X : Ob) : Hom X X", "| Cod : RingedLocale", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| f : FrameHom (L {Cod}) (L {Dom})"]}
{"Context": ["this : NatTrans ", "x : Ob {C {\\this}}", "h1 : func {trans {\\this} y \u2218 Func {VPresheaf.F {N.R}} {x} {y} p} = func {Func {x} {y} p \u2218 trans {\\this} x}", "y : Ob {C {\\this}}", "p : Hom {C {\\this}} x y"], "Expected type": "Path (\\lam (i : I) => \\Pi {x1 y1 : E {Functor.F {NatTrans.F {\\this}} x}} -> (@) h1 i (x1 + y1) = (@) h1 i x1 + (@) h1 i y1)\n  (func-+ {trans {\\this} y \u2218 Func {NatTrans.F {\\this}} {x} {y} p}) (func-+ {Func {G {\\this}} {x} {y} p \u2218 trans {\\this} x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| G : Functor C D", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| F : Functor C D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : NatTrans ", "x : Ob {C {\\this}}", "h1 : func {trans {\\this} y \u2218 Func {VPresheaf.F {N.R}} {x} {y} p} = func {Func {x} {y} p \u2218 trans {\\this} x}", "y : Ob {C {\\this}}", "p : Hom {C {\\this}} x y"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {Functor.F {NatTrans.F {\\this}} x}) = ide {Functor.F {G {\\this}} y})\n  (func-ide {trans {\\this} y \u2218 Func {NatTrans.F {\\this}} {x} {y} p})\n  (func-ide {Func {G {\\this}} {x} {y} p \u2218 trans {\\this} x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "| G : Functor C D", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E", "| F : Functor C D"]}
{"Context": ["this : NatTrans ", "x : Ob {C {\\this}}", "h1 : func {trans {\\this} y \u2218 Func {VPresheaf.F {N.R}} {x} {y} p} = func {Func {x} {y} p \u2218 trans {\\this} x}", "y : Ob {C {\\this}}", "p : Hom {C {\\this}} x y"], "Expected type": "Path (\\lam (i : I) => \\Pi {x1 y1 : E {Functor.F {NatTrans.F {\\this}} x}} -> (@) h1 i (x1 * y1) = (@) h1 i x1 * (@) h1 i y1)\n  (func-* {trans {\\this} y \u2218 Func {NatTrans.F {\\this}} {x} {y} p}) (func-* {Func {G {\\this}} {x} {y} p \u2218 trans {\\this} x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| F (Ob {C}) : Ob {D}", "| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| G : Functor C D", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| F : Functor C D", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Iso ", "h1 : (\\lam (X : E {L'.L}) =>\n  trans {f# {e.f}} X \u2218 homMap {Cod {e.f \u2218 e.hinv}} {Dom {e.f \u2218 e.hinv}} {e.f \u2218 e.hinv} {RingedLocalePrecat.id L'} e.f_hinv X \u2218 trans {f# {e.hinv}} (func {RingedLocaleHom.f {e.f}} X)) = (\\lam (X : E {L'.L}) => RingHom.id {Functor.F {VPresheaf.F {L.R}} (func {RingedLocaleHom.f {e.f}} X)})", "L' : RingedLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} -> \\Pi (f : Hom X Y) ->\n  (@) h1 i Y \u2218 Func {VPresheaf.F {dom {\\this}}} {X} {Y} f = Func {VPresheaf.F {dom {\\this}}} {X} {Y} f \u2218 (@) h1 i X)\n  (natural {hinv {\\this} \u2218 f {\\this}}) (natural {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["h1 : (\\lam (X : E {L'.L}) =>\n  homMap {Cod {e.f \u2218 e.hinv}} {Dom {e.f \u2218 e.hinv}} {e.f \u2218 e.hinv} {RingedLocalePrecat.id L'} e.f_hinv X \u2218 trans {f# {e.hinv}} (func {RingedLocaleHom.f {e.f}} X) \u2218 trans {f# {e.f}} X) = (\\lam (X : E {L'.L}) => RingHom.id {Functor.F {VPresheaf.F {L'.R}} X})", "this : Iso ", "L' : RingedLocale"], "Expected type": "Path (\\lam (i : I) => \\Pi {X Y : Ob} -> \\Pi (f : Hom X Y) ->\n  (@) h1 i Y \u2218 Func {VPresheaf.F {cod {\\this}}} {X} {Y} f = Func {VPresheaf.F {cod {\\this}}} {X} {Y} f \u2218 (@) h1 i X)\n  (natural {f {\\this} \u2218 hinv {\\this}}) (natural {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| F : Functor (op {C}) D", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod", "| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X"]}
{"Context": ["arg : \\Sigma (p1 : L {e.dom} = L {e.cod})\n  (transport {Locale} (\\lam (x : Locale) => VSheaf CRingCat x) {L {e.dom}} {L {e.cod}} p1 (R {e.dom}) = R {e.cod})", "e : Iso ", "h1 : L {e.dom} = L {e.cod}", "i : I"], "Expected type": "RingedLocale (h1 @ i) (pathOver {\\lam (i : I) => VSheaf CRingCat (h1 @ i)} {R {e.dom}} {R {e.cod}} arg.2 @ i)", "Expression": "\\new RingedLocale {\n  | L => h1 @ i\n  | R => pathOver {\\lam i => ext_coe} arg.2 @ i\n}", "Premises": ["| R : VSheaf CRingCat L", "\\func pathOver {A : I -> \\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p", "| dom : Ob {C}", "| cod : Ob {C}"]}
{"Context": ["this : Iso ", "L : Locale", "h1 : (\\lam (e : \\Sigma (b : L.E) (b L.<= L.top)) => (\n  \\have _ => top-right {L} {func {hinv {\\this}} e}\n  \\in (func {hinv {\\this}} e L.\u2227 L.top, (func {hinv {\\this} \u2218 f {\\this}} e).2))) = (\\lam (e : \\Sigma (b : L.E) (b L.<= L.top)) => (\n  \\have _ => top-right {L} {func {hinv {\\this}} e}\n  \\in (func {hinv {\\this}} e, (func {id {C {\\this}} (dom {\\this})} e).2)))"], "Expected type": "Path (\\lam (i : I) => (top {dom {\\this}}).1 L.<= ((@) h1 i (top {dom {\\this}})).1) (func-top>= {hinv {\\this} \u2218 f {\\this}})\n  (func-top>= {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Iso ", "L : Locale", "h1 : (\\lam (e : L.E) => e L.\u2227 L.top) = (\\lam (e : L.E) => e)"], "Expected type": "Path (\\lam (i : I) => top {cod {\\this}} L.<= (@) h1 i (top {cod {\\this}})) (func-top>= {f {\\this} \u2218 hinv {\\this}})\n  (func-top>= {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| top : E", "| \\infix 4 <= E E : \\Prop", "| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-top>= : top {Cod} <= func (top {Dom})", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["L : Locale", "S : VSheaf CRingCat L"], "Expected type": "hinv {L} {S} \u2218 restrict_map {L} L.top S = id (fromSheaf {Locale.restrict {L} L.top} (VSheaf.restrict {L} L.top S))", "Expression": "ext (hinv \u2218 {RingedLocalePrecat} restrict_map (top {L}) S) _ {?} {?}", "Premises": ["\\lemma ext {L1 M : RingedLocale} (f1 g : RingedLocaleHom L1 M) (p : f.f = g.f)\n  (_ : \\Pi (a : E {M.L}) -> \\Pi (x : E {Functor.F {VPresheaf.F {M.R}} a}) ->\n    func {Func {VPresheaf.F {L.R}} {func {g.f} a} {func {f.f} a} (fromHomEq {Cod {f.f}} {Dom {f.f}} {f.f} {g.f} p a)}\n      (func {trans {g.f#} a} x) = func {trans {f.f#} a} x) : f1 = g ", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "\\func restrict \\hlevels  {this2 : Locale} (a : E) : Locale (\\Sigma (b : E) (b <= a)) {\n  | <= => \\lam (p : E {\\this}) (q : E {\\this}) => p.1 <= q.1\n  | meet => \\lam (p : E {\\this}) (q : E {\\this}) => (p.1 \u2227 q.1, meet-left {p.1} {q.1} <=\u2218 p.2)\n  | top => (a, <=-refl {a})\n  | Join => \\lam {J : \\Set} (g : J -> E {\\this}) =>\n    (Join {J} (\\lam (j : J) => (g j).1), Join-univ {J} {\\lam (j : J) => (g j).1} {a} (\\lam (j : J) => (g j).2))\n} => \\new Locale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n}", "\\func restrict_map {L1 : Locale} (a : L.E) (S : VSheaf CRingCat L1) : RingedLocaleHom\n  (\\new RingedLocale (Locale.restrict {L1} a) (VSheaf.restrict {L1} a S)) (\\new RingedLocale L1 S) (map {L1} {a})\n    (\\new NatTrans {Precat.op {L {Cod {\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\this}}})\n      (VPresheaf.F {direct_image_locale {L {Dom {\\this}}} {L {Cod {\\this}}} (f {\\this}) (R {Dom {\\this}})}) {\n      | trans => \\lam (b : Ob {C {\\this}}) => Func {S.F} {b} {(func {map {L1} {a}} b).1} (L.meet-left {b} {a})\n      | natural => {?hidden}\n    }) => \\new RingedLocaleHom", "\\func hinv {L1 : Locale} {S : VSheaf CRingCat L1} : RingedLocaleHom\n  (fromSheaf {L1} S) (fromSheaf {Locale.restrict {L1} L.top} (VSheaf.restrict {L1} L.top S)) (hinv {locale_iso {L1}})\n    (\\new NatTrans {Precat.op {L {Cod {\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\this}}})\n      (VPresheaf.F {direct_image_locale {L {Dom {\\this}}} {L {Cod {\\this}}} (f {\\this}) (R {Dom {\\this}})}) {\n      | trans => \\lam (p : Ob {C {\\this}}) => id (Functor.F {S.F} p.1)\n      | natural => {?hidden}\n    }) => \\new RingedLocaleHom", "\\func RingedLocalePrecat : Precat RingedLocale {\n  | Hom => RingedLocaleHom\n  | id => RingedLocalePrecat.id\n  | o => RingedLocalePrecat.o\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "\\func fromSheaf {L : Locale} (S : VSheaf CRingCat L) : RingedLocale L S => \\new RingedLocale", "\\func map \\hlevels  {this4 : Locale} {a : E} : FrameHom this4 (restrict a) {\n  | func => \\lam (b : E {Dom {\\this}}) => (b \u2227 a, meet-right {b} {a})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| top : E", "| L : Locale", "| R : VSheaf CRingCat L", "| id (X : Ob) : Hom X X", "| hinv : Hom {C} cod dom", "\\func restrict {L : Locale} (a : L.E) (S1 : VSheaf {\n  | C => L\n}) : VSheaf S.D (restrict {L} a) (Comp {Precat.op {restrict {L} a}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {L} {a}})) \n=> \\new VSheaf {\n  | isSheaf => {?hidden}\n}"]}
{"Context": ["L : Locale", "S : VSheaf CRingCat L"], "Expected type": "restrict_map {L} L.top S \u2218 hinv {L} {S} = id (fromSheaf {L} S)", "Expression": "ext (restrict_map (top {L}) S \u2218 {RingedLocalePrecat} hinv) _ {?} {?}", "Premises": ["\\lemma ext {L1 M : RingedLocale} (f1 g : RingedLocaleHom L1 M) (p : f.f = g.f)\n  (_ : \\Pi (a : E {M.L}) -> \\Pi (x : E {Functor.F {VPresheaf.F {M.R}} a}) ->\n    func {Func {VPresheaf.F {L.R}} {func {g.f} a} {func {f.f} a} (fromHomEq {Cod {f.f}} {Dom {f.f}} {f.f} {g.f} p a)}\n      (func {trans {g.f#} a} x) = func {trans {f.f#} a} x) : f1 = g ", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func restrict \\hlevels  {this2 : Locale} (a : E) : Locale (\\Sigma (b : E) (b <= a)) {\n  | <= => \\lam (p : E {\\this}) (q : E {\\this}) => p.1 <= q.1\n  | meet => \\lam (p : E {\\this}) (q : E {\\this}) => (p.1 \u2227 q.1, meet-left {p.1} {q.1} <=\u2218 p.2)\n  | top => (a, <=-refl {a})\n  | Join => \\lam {J : \\Set} (g : J -> E {\\this}) =>\n    (Join {J} (\\lam (j : J) => (g j).1), Join-univ {J} {\\lam (j : J) => (g j).1} {a} (\\lam (j : J) => (g j).2))\n} => \\new Locale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n}", "\\func restrict_map {L1 : Locale} (a : L.E) (S : VSheaf CRingCat L1) : RingedLocaleHom\n  (\\new RingedLocale (Locale.restrict {L1} a) (VSheaf.restrict {L1} a S)) (\\new RingedLocale L1 S) (map {L1} {a})\n    (\\new NatTrans {Precat.op {L {Cod {\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\this}}})\n      (VPresheaf.F {direct_image_locale {L {Dom {\\this}}} {L {Cod {\\this}}} (f {\\this}) (R {Dom {\\this}})}) {\n      | trans => \\lam (b : Ob {C {\\this}}) => Func {S.F} {b} {(func {map {L1} {a}} b).1} (L.meet-left {b} {a})\n      | natural => {?hidden}\n    }) => \\new RingedLocaleHom", "\\func hinv {L1 : Locale} {S : VSheaf CRingCat L1} : RingedLocaleHom\n  (fromSheaf {L1} S) (fromSheaf {Locale.restrict {L1} L.top} (VSheaf.restrict {L1} L.top S)) (hinv {locale_iso {L1}})\n    (\\new NatTrans {Precat.op {L {Cod {\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\this}}})\n      (VPresheaf.F {direct_image_locale {L {Dom {\\this}}} {L {Cod {\\this}}} (f {\\this}) (R {Dom {\\this}})}) {\n      | trans => \\lam (p : Ob {C {\\this}}) => id (Functor.F {S.F} p.1)\n      | natural => {?hidden}\n    }) => \\new RingedLocaleHom", "\\func RingedLocalePrecat : Precat RingedLocale {\n  | Hom => RingedLocaleHom\n  | id => RingedLocalePrecat.id\n  | o => RingedLocalePrecat.o\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "\\func fromSheaf {L : Locale} (S : VSheaf CRingCat L) : RingedLocale L S => \\new RingedLocale", "\\func map \\hlevels  {this4 : Locale} {a : E} : FrameHom this4 (restrict a) {\n  | func => \\lam (b : E {Dom {\\this}}) => (b \u2227 a, meet-right {b} {a})\n} => \\new FrameHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}", "| top : E", "| id (X : Ob) : Hom X X", "| hinv : Hom {C} cod dom", "\\func restrict {L : Locale} (a : L.E) (S1 : VSheaf {\n  | C => L\n}) : VSheaf S.D (restrict {L} a) (Comp {Precat.op {restrict {L} a}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {L} {a}})) \n=> \\new VSheaf {\n  | isSheaf => {?hidden}\n}"]}
{"Context": ["x : Carrier R", "p : x.1 = R.zro", "R : GradedCRing"], "Expected type": "(\\case inr {\\Sigma (n : Nat) (a b : R.E) (R.isHomogen a (suc n)) (R.isHomogen b (suc n))} {Nat} x.2 \\with {\n  | inl (n, a, b, ah, bh) =>\n    (Bool, (a R.+ b, n, R.homogen-+ {suc n} {a} {b} ah bh), \\lam (p0 : Bool) => if {Carrier R} p0 (a, n, ah) (b, n, bh))\n  | inr n => (Empty, (R.zro, n, R.homogen-zro {suc n}), absurd {\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))})\n}).2 = x", "Expression": "ext (inv p, idp)", "Premises": ["\\func absurd {A : \\Type} (_ : Empty) : A ", "| homogen-+ {n : Nat} {a b : E} (isHomogen a n) (isHomogen b n) : isHomogen (a + b) n", "| homogen-zro {n : Nat} : isHomogen zro n", "\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "| isHomogen E Nat : \\Prop", "\\data Bool \\plevels  \\hlevels  \n  | false\n  | true", "inr B", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func if {A : \\Type} (_ : Bool) (_ _ : A) : A \n  | {A}, true, then, else => then\n  | {A}, false, then, else => else", "| \\infixl 6 + E E : E", "\\data Empty \\plevels  \\hlevels  ", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "suc Nat", "| E : \\Set", "\\func Carrier \\hlevels  (R : GradedCRing) : \\Set => \\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))", "| zro : E"]}
{"Context": ["a : R.E", "bd : Nat", "b : R.E", "R : GradedCRing", "h1 : func {shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6} = func {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6}", "ad : Nat", "ah : R.isHomogen a ad", "t : \\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)", "s : \\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)", "bh : R.isHomogen b bd"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6})\n  (func-+ {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func shom \\hlevels  {R : GradedCRing} {a b : R.E} {ad bd : Nat} {ah : R.isHomogen a ad} {bh : R.isHomogen b bd} (n : Nat) (c : R.E)\n  (cd : Nat) (ch : R.isHomogen c cd) (p : pow {R} b n = a R.* c) (bd*n=ad+cd : bd Semigroup.* n = ad + cd) :\nRingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b)) {\n  | func => \\lam (x : E {Dom {\\this}}) => (smap {R} {a} {b} {ad} {bd} ah bh n c cd ch p bd*n=ad+cd x).1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : R.E", "bd : Nat", "b : R.E", "R : GradedCRing", "h1 : func {shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6} = func {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6}", "ad : Nat", "ah : R.isHomogen a ad", "t : \\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)", "s : \\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)", "bh : R.isHomogen b bd"], "Expected type": "Path (\\lam (i : I) => (@) h1 i ide = ide) (func-ide {shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6})\n  (func-ide {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func shom \\hlevels  {R : GradedCRing} {a b : R.E} {ad bd : Nat} {ah : R.isHomogen a ad} {bh : R.isHomogen b bd} (n : Nat) (c : R.E)\n  (cd : Nat) (ch : R.isHomogen c cd) (p : pow {R} b n = a R.* c) (bd*n=ad+cd : bd Semigroup.* n = ad + cd) :\nRingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b)) {\n  | func => \\lam (x : E {Dom {\\this}}) => (smap {R} {a} {b} {ad} {bd} ah bh n c cd ch p bd*n=ad+cd x).1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E"]}
{"Context": ["a : R.E", "bd : Nat", "b : R.E", "R : GradedCRing", "h1 : func {shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6} = func {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6}", "ad : Nat", "ah : R.isHomogen a ad", "t : \\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)", "s : \\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)", "bh : R.isHomogen b bd"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y)\n  (func-* {shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6})\n  (func-* {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func shom \\hlevels  {R : GradedCRing} {a b : R.E} {ad bd : Nat} {ah : R.isHomogen a ad} {bh : R.isHomogen b bd} (n : Nat) (c : R.E)\n  (cd : Nat) (ch : R.isHomogen c cd) (p : pow {R} b n = a R.* c) (bd*n=ad+cd : bd Semigroup.* n = ad + cd) :\nRingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b)) {\n  | func => \\lam (x : E {Dom {\\this}}) => (smap {R} {a} {b} {ad} {bd} ah bh n c cd ch p bd*n=ad+cd x).1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : C.Ob", "C : Precat", "arg : \\Sigma (e.f = e'.f) (e.hinv = e'.hinv)", "e' : Iso ", "h2 : e.hinv = e'.hinv", "e : Iso ", "x : C.Ob"], "Expected type": "Path (\\lam (i : I) => h2 @ i C.\u2218 arg.1 @ i = C.id x) e.hinv_f e'.hinv_f", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| hinv_f : hinv \u2218 f = id {C} dom", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["y : C.Ob", "C : Precat", "arg : \\Sigma (e.f = e'.f) (e.hinv = e'.hinv)", "e' : Iso ", "h2 : e.hinv = e'.hinv", "e : Iso ", "x : C.Ob"], "Expected type": "Path (\\lam (i : I) => arg.1 @ i C.\u2218 h2 @ i = C.id y) e.f_hinv e'.f_hinv", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f_hinv : f \u2218 hinv = id {C} cod"]}
{"Context": ["y : C.Ob", "C : Precat", "arg : \\Sigma (e.f = e'.f) (e.hinv = e'.hinv)", "e' : Iso ", "h2 : e.hinv = e'.hinv", "i : I", "e : Iso ", "x : C.Ob"], "Expected type": "Iso {C} {x} {y} (arg.1 @ i) {\n  | hinv => h2 @ i\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "Expression": "\\new Iso {\n  | f => arg.1 @ i\n  | hinv => h2 @ i\n  | hinv_f => prop-dpi (\\lam i => ext_coe) (hinv_f {e}) (hinv_f {e'}) @ i\n  | f_hinv => prop-dpi (\\lam i => ext_coe) (f_hinv {e}) (f_hinv {e'}) @ i\n}", "Premises": ["| id (X : Ob) : Hom X X", "| hinv_f : hinv \u2218 f = id {C} dom", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f_hinv : f \u2218 hinv = id {C} cod"]}
{"Context": ["X : \\Set", "h1 : x.F = y.F", "y : E {\\this}", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {U : Set X} -> (@) h1 i U -> TruncP (\\Sigma (x : X) (U x))) x.isProper y.isProper", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop", "| isProper {U : Set X} (F U) : TruncP (\\Sigma (x : X) (U x))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["U : Set X", "x : X", "X : \\Type", "W : Set (Total {X} U)", "e : (\u2227) (extend {X} {U} V) (extend {X} {U} W) x"], "Expected type": "W (x, e.1.1)", "Expression": "transport W (ext idp) {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)"]}
{"Context": ["V : Set (Total {X} U)", "U : Set X", "x : X", "X : \\Type", "W : Set (Total {X} U)", "e : (\u2227) (extend {X} {U} V) (extend {X} {U} W) x"], "Expected type": "(\u2227) V W (x, e.1.1)", "Expression": "(e.1.2, transport W (ext idp) {?})", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)"]}
{"Context": ["V : Set (Total {X} U)", "U : Set X", "x : X", "X : \\Type", "W : Set (Total {X} U)", "e : (\u2227) (extend {X} {U} V) (extend {X} {U} W) x"], "Expected type": "extend {X} {U} (V \u2227 W) x", "Expression": "(e.1.1, (e.1.2, transport W (ext idp) {?}))", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func extend {X : \\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\lam (x : X) => \\Sigma (Ux : U x) (V (x, Ux))"]}
{"Context": ["f : A -> B", "g : \\Pi (i : Fin l.len) -> \\Sigma (x : A) (f x = l.at i)", "l : Array B", "A : \\Type", "B : \\Type"], "Expected type": "TruncP (\\Sigma (x : Array A) (map {A} {B} f x = l))", "Expression": "inP (\\lam j => (g j).1, exts (\\lam j => (g j).2))", "Premises": ["\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "inP A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["u : Partial X", "d : u.isDefined", "p : u.value d = x", "X : \\Set", "x : X"], "Expected type": "u = defined {X} x", "Expression": "partial-ext {?} {?}", "Premises": ["\\lemma partial-ext \\hlevels  {X : \\Set} {u v : Partial X} (_ : u.isDefined <-> v.isDefined)\n  (_ : \\Pi (p : u.isDefined) -> \\Pi (q : v.isDefined) -> u.value {?hidden} = v.value {?hidden}) : u = v ", "\\func defined \\hlevels  {X : \\Set} (x : X) : Partial X {\n  | isDefined => \\Sigma\n  | value => \\lam (_ : isDefined {\\this}) => x\n} => \\new Partial"]}
{"Context": ["u : Partial X", "d : Not u.isDefined", "X : \\Set"], "Expected type": "u = undefined {X}", "Expression": "partial-ext {?} {?}", "Premises": ["\\lemma partial-ext \\hlevels  {X : \\Set} {u v : Partial X} (_ : u.isDefined <-> v.isDefined)\n  (_ : \\Pi (p : u.isDefined) -> \\Pi (q : v.isDefined) -> u.value {?hidden} = v.value {?hidden}) : u = v ", "\\func undefined \\hlevels  {X : \\Set} : Partial X {\n  | isDefined => Empty\n  | value => \\lam (p0 : isDefined {\\this}) => (\\case p0 \\with {})\n} => \\new Partial", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : AddMonoid (Partial X.E) ", "x : E {\\this}", "X : AddMonoid"], "Expected type": "x + zro {\\this} = x", "Expression": "partial-ext {?} {?}", "Premises": ["\\lemma partial-ext \\hlevels  {X : \\Set} {u v : Partial X} (_ : u.isDefined <-> v.isDefined)\n  (_ : \\Pi (p : u.isDefined) -> \\Pi (q : v.isDefined) -> u.value {?hidden} = v.value {?hidden}) : u = v ", "| \\infixl 6 + E E : E", "| zro : E"]}
{"Context": ["F : Functor J this", "c : B {\\this}", "J : Precat", "this : BicompleteCat \\Set ", "Z : Ob {D {\\this}}", "z : Z"], "Expected type": "Cone {J1} F1 (\\Sigma) {\n  | coneMap => \\lam (j : Ob {J {\\this}}) (_ : apex {\\this}) => c.coneMap j z\n  | coneCoh => {?hidden}\n}", "Expression": "\\new Cone {\n  | coneMap => \\lam j _ => coneMap {c} j z\n  | coneCoh => \\lam h => ext (\\lam _ => pmap (\\lam p0 => p0 z) (coneCoh {c} h))\n}", "Premises": ["| apex : Ob {D}", "| J : Precat", "| F (Ob {C}) : Ob {D}", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| Ob : \\hType", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["c : Cone ", "z : Z", "c' : Cone "], "Expected type": "Cone {c.J} {SetCat} c.G (\\Sigma) {\n  | coneMap => \\lam (j : Ob {J {\\this}}) (_ : apex {\\this}) => c'.coneMap j z\n  | coneCoh => {?hidden}\n}", "Expression": "\\new Cone {\n  | coneMap => \\lam j _ => coneMap {c'} j z\n  | coneCoh => \\lam h => ext (\\lam _ => path (\\lam i => coneCoh {c'} h i z))\n}", "Premises": ["| apex : Ob {D}", "| J : Precat", "| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'", "| G : Functor J D", "| Ob : \\hType", "| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)"]}
{"Context": ["y : A", "c : List A", "b : List A", "sl' : SubList {A} (y :: b) c", "A : \\Set"], "Expected type": "shrink {A} {y} {b ++ nil {A} ++ nil {A}} {c ++ nil {A} ++ nil {A}} (extend-right-both {A} {y :: b} {c} sl' {nil {A} ++ nil {A}}) = extend-right-both {A} {b} {c} (shrink {A} {y} {b} {c} sl') {nil {A} ++ nil {A}}", "Expression": "shrink-over-extend-right sl'", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\infixr 5 :: A (List A)", "\\func shrink-over-extend-right \\hlevels  {A2 : \\Set} {x1 : A2} {a2 b2 c2 : List A2} (sl2 : SubList {A2} (x1 :: a2) b2) :\n  shrink {A2} {x1} {a2 ++ c2} {b2 ++ c2} (extend-right-both {A2} {x1 :: a2} {b2} sl2 {c2}) = extend-right-both {A2} {a2} {b2} (shrink {A2} {x1} {a2} {b2} sl2) {c2} \n  | {A}, {x}, {a}, {y :: b}, {c}, sublist-match p sl => transport {SubList {A} (a ++ c) (y :: b ++ c)}\n    ((=) (sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} sl {c})))\n    {sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} sl {c})}\n    {extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} sl) {c}}\n    (skip-over-extend-right {A} {y} {a} {b} {c} sl)\n    (pmap {SubList {A} (a ++ c) (b ++ c)} {SubList {A} (a ++ c) (y :: b ++ c)} (sublist-skip {A} {a ++ c} {y} {b ++ c})\n      {extend-right-both {A} {a} {b} sl {c}} {extend-right-both {A} {a} {b} sl {c}}\n      (idp {SubList {A} (a ++ c) (b ++ c)} {extend-right-both {A} {a} {b} sl {c}}))\n  | {A}, {x}, {a}, {y :: b}, {c}, sublist-skip sl => transport {SubList {A} (a ++ c) (y :: b ++ c)}\n    ((=) (sublist-skip {A} {a ++ c} {y} {b ++ c} (shrink {A} {x} {a ++ c} {b ++ c} (extend-right-both {A} {x :: a} {b} sl {c}))))\n    {sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} (shrink {A} {x} {a} {b} sl) {c})}\n    {extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} (shrink {A} {x} {a} {b} sl)) {c}}\n    (skip-over-extend-right {A} {y} {a} {b} {c} (shrink {A} {x} {a} {b} sl))\n    (pmap {SubList {A} (a ++ c) (b ++ c)} {SubList {A} (a ++ c) (y :: b ++ c)} (sublist-skip {A} {a ++ c} {y} {b ++ c})\n      {shrink {A} {x} {a ++ c} {b ++ c} (extend-right-both {A} {x :: a} {b} sl {c})}\n      {extend-right-both {A} {a} {b} (shrink {A} {x} {a} {b} sl) {c}} (shrink-over-extend-right {A} {x} {a} {b} {c} sl))", "nil", "\\func shrink {A2 : \\Type} {a1 : A2} {list2 list'2 : List A2} (_ : SubList {A2} (a1 :: list2) list'2) : SubList {A2} list2 list'2 \n  | {A}, {a}, {list}, {y :: list'}, sublist-match p sublist => sublist-skip {A} {list} {y} {list'} sublist\n  | {A}, {a}, {list}, {y :: list'}, sublist-skip sublist =>\n    sublist-skip {A} {list} {y} {list'} (shrink {A} {a} {list} {list'} sublist)", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["a : List A", "A : \\Set", "c : List A", "y : A", "b : List A", "sl : SubList {A} a b"], "Expected type": "sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} sl {c}) = extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} sl) {c}", "Expression": "skip-over-extend-right _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func skip-over-extend-right \\hlevels  {A4 : \\Set} {x5 : A4} {a3 b3 c4 : List A4} (sl3 : SubList {A4} a3 b3) :\n  sublist-skip {A4} {a3 ++ c4} {x5} {b3 ++ c4} (extend-right-both {A4} {a3} {b3} sl3 {c4}) = extend-right-both {A4} {a3} {x5 :: b3} (sublist-skip {A4} {a3} {x5} {b3} sl3) {c4} \n  | {A}, {x}, {nil}, {nil}, {c}, sublist-nil => idp {SubList {A} (nil {A} ++ c) (x :: nil {A} ++ c)}\n    {sublist-skip {A} {nil {A} ++ c} {x} {nil {A} ++ c} (extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {c})}\n  | {A}, {x}, {x1 :: a}, {y :: b}, {c}, sublist-match p sl => idp {SubList {A} ((x1 :: a) ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {(x1 :: a) ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {x1 :: a} {y :: b} (sublist-match {A} {x1} {a} {y} {b} p sl) {c})}\n  | {A}, {x}, {nil}, {y :: b}, {c}, sublist-skip sl => idp {SubList {A} (nil {A} ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {nil {A} ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {nil {A}} {y :: b} (sublist-skip {A} {nil {A}} {y} {b} sl) {c})}\n  | {A}, {x}, {a :: a1}, {y :: b}, {c}, sublist-skip sl => idp {SubList {A} ((a :: a1) ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {(a :: a1) ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {a :: a1} {y :: b} (sublist-skip {A} {a :: a1} {y} {b} sl) {c})}", "\\infixr 5 :: A (List A)", "sublist-skip (SubList {A} l ys)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["A : \\Set", "y : A", "b : List A", "x : A", "a : List A", "c : List A", "sl : SubList {A} (x :: a) b"], "Expected type": "sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} (shrink {A} {x} {a} {b} sl) {c}) = extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} (shrink {A} {x} {a} {b} sl)) {c}", "Expression": "skip-over-extend-right _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\func skip-over-extend-right \\hlevels  {A4 : \\Set} {x5 : A4} {a3 b3 c4 : List A4} (sl3 : SubList {A4} a3 b3) :\n  sublist-skip {A4} {a3 ++ c4} {x5} {b3 ++ c4} (extend-right-both {A4} {a3} {b3} sl3 {c4}) = extend-right-both {A4} {a3} {x5 :: b3} (sublist-skip {A4} {a3} {x5} {b3} sl3) {c4} \n  | {A}, {x}, {nil}, {nil}, {c}, sublist-nil => idp {SubList {A} (nil {A} ++ c) (x :: nil {A} ++ c)}\n    {sublist-skip {A} {nil {A} ++ c} {x} {nil {A} ++ c} (extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {c})}\n  | {A}, {x}, {x1 :: a}, {y :: b}, {c}, sublist-match p sl => idp {SubList {A} ((x1 :: a) ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {(x1 :: a) ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {x1 :: a} {y :: b} (sublist-match {A} {x1} {a} {y} {b} p sl) {c})}\n  | {A}, {x}, {nil}, {y :: b}, {c}, sublist-skip sl => idp {SubList {A} (nil {A} ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {nil {A} ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {nil {A}} {y :: b} (sublist-skip {A} {nil {A}} {y} {b} sl) {c})}\n  | {A}, {x}, {a :: a1}, {y :: b}, {c}, sublist-skip sl => idp {SubList {A} ((a :: a1) ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {(a :: a1) ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {a :: a1} {y :: b} (sublist-skip {A} {a :: a1} {y} {b} sl) {c})}", "\\infixr 5 :: A (List A)", "\\func shrink {A2 : \\Type} {a1 : A2} {list2 list'2 : List A2} (_ : SubList {A2} (a1 :: list2) list'2) : SubList {A2} list2 list'2 \n  | {A}, {a}, {list}, {y :: list'}, sublist-match p sublist => sublist-skip {A} {list} {y} {list'} sublist\n  | {A}, {a}, {list}, {y :: list'}, sublist-skip sublist =>\n    sublist-skip {A} {list} {y} {list'} (shrink {A} {a} {list} {list'} sublist)", "sublist-skip (SubList {A} l ys)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["A : \\Set", "x : A", "b : List A", "a : List A", "c : List A", "sl : SubList {A} (x :: a) b"], "Expected type": "shrink {A} {x} {a ++ c} {b ++ c} (extend-right-both {A} {x :: a} {b} sl {c}) = extend-right-both {A} {a} {b} (shrink {A} {x} {a} {b} sl) {c}", "Expression": "shrink-over-extend-right _", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\infixr 5 :: A (List A)", "\\func shrink {A2 : \\Type} {a1 : A2} {list2 list'2 : List A2} (_ : SubList {A2} (a1 :: list2) list'2) : SubList {A2} list2 list'2 \n  | {A}, {a}, {list}, {y :: list'}, sublist-match p sublist => sublist-skip {A} {list} {y} {list'} sublist\n  | {A}, {a}, {list}, {y :: list'}, sublist-skip sublist =>\n    sublist-skip {A} {list} {y} {list'} (shrink {A} {a} {list} {list'} sublist)", "\\func shrink-over-extend-right \\hlevels  {A2 : \\Set} {x1 : A2} {a2 b2 c2 : List A2} (sl2 : SubList {A2} (x1 :: a2) b2) :\n  shrink {A2} {x1} {a2 ++ c2} {b2 ++ c2} (extend-right-both {A2} {x1 :: a2} {b2} sl2 {c2}) = extend-right-both {A2} {a2} {b2} (shrink {A2} {x1} {a2} {b2} sl2) {c2} \n  | {A}, {x}, {a}, {y :: b}, {c}, sublist-match p sl => transport {SubList {A} (a ++ c) (y :: b ++ c)}\n    ((=) (sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} sl {c})))\n    {sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} sl {c})}\n    {extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} sl) {c}}\n    (skip-over-extend-right {A} {y} {a} {b} {c} sl)\n    (pmap {SubList {A} (a ++ c) (b ++ c)} {SubList {A} (a ++ c) (y :: b ++ c)} (sublist-skip {A} {a ++ c} {y} {b ++ c})\n      {extend-right-both {A} {a} {b} sl {c}} {extend-right-both {A} {a} {b} sl {c}}\n      (idp {SubList {A} (a ++ c) (b ++ c)} {extend-right-both {A} {a} {b} sl {c}}))\n  | {A}, {x}, {a}, {y :: b}, {c}, sublist-skip sl => transport {SubList {A} (a ++ c) (y :: b ++ c)}\n    ((=) (sublist-skip {A} {a ++ c} {y} {b ++ c} (shrink {A} {x} {a ++ c} {b ++ c} (extend-right-both {A} {x :: a} {b} sl {c}))))\n    {sublist-skip {A} {a ++ c} {y} {b ++ c} (extend-right-both {A} {a} {b} (shrink {A} {x} {a} {b} sl) {c})}\n    {extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} (shrink {A} {x} {a} {b} sl)) {c}}\n    (skip-over-extend-right {A} {y} {a} {b} {c} (shrink {A} {x} {a} {b} sl))\n    (pmap {SubList {A} (a ++ c) (b ++ c)} {SubList {A} (a ++ c) (y :: b ++ c)} (sublist-skip {A} {a ++ c} {y} {b ++ c})\n      {shrink {A} {x} {a ++ c} {b ++ c} (extend-right-both {A} {x :: a} {b} sl {c})}\n      {extend-right-both {A} {a} {b} (shrink {A} {x} {a} {b} sl) {c}} (shrink-over-extend-right {A} {x} {a} {b} {c} sl))", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["A : \\Set", "y : A", "b : List A", "x : A", "a : List A", "c : List A", "sl : SubList {A} (x :: a) b"], "Expected type": "sublist-skip {A} {a ++ c} {y} {b ++ c} (shrink {A} {x} {a ++ c} {b ++ c} (extend-right-both {A} {x :: a} {b} sl {c})) = extend-right-both {A} {a} {y :: b} (sublist-skip {A} {a} {y} {b} (shrink {A} {x} {a} {b} sl)) {c}", "Expression": "rewriteI skip-over-extend-right {?}", "Premises": ["\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys", "\\infixr 5 :: A (List A)", "\\func skip-over-extend-right \\hlevels  {A4 : \\Set} {x5 : A4} {a3 b3 c4 : List A4} (sl3 : SubList {A4} a3 b3) :\n  sublist-skip {A4} {a3 ++ c4} {x5} {b3 ++ c4} (extend-right-both {A4} {a3} {b3} sl3 {c4}) = extend-right-both {A4} {a3} {x5 :: b3} (sublist-skip {A4} {a3} {x5} {b3} sl3) {c4} \n  | {A}, {x}, {nil}, {nil}, {c}, sublist-nil => idp {SubList {A} (nil {A} ++ c) (x :: nil {A} ++ c)}\n    {sublist-skip {A} {nil {A} ++ c} {x} {nil {A} ++ c} (extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {c})}\n  | {A}, {x}, {x1 :: a}, {y :: b}, {c}, sublist-match p sl => idp {SubList {A} ((x1 :: a) ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {(x1 :: a) ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {x1 :: a} {y :: b} (sublist-match {A} {x1} {a} {y} {b} p sl) {c})}\n  | {A}, {x}, {nil}, {y :: b}, {c}, sublist-skip sl => idp {SubList {A} (nil {A} ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {nil {A} ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {nil {A}} {y :: b} (sublist-skip {A} {nil {A}} {y} {b} sl) {c})}\n  | {A}, {x}, {a :: a1}, {y :: b}, {c}, sublist-skip sl => idp {SubList {A} ((a :: a1) ++ c) (x :: (y :: b) ++ c)}\n    {sublist-skip {A} {(a :: a1) ++ c} {x} {(y :: b) ++ c} (extend-right-both {A} {a :: a1} {y :: b} (sublist-skip {A} {a :: a1} {y} {b} sl) {c})}", "\\func shrink {A2 : \\Type} {a1 : A2} {list2 list'2 : List A2} (_ : SubList {A2} (a1 :: list2) list'2) : SubList {A2} list2 list'2 \n  | {A}, {a}, {list}, {y :: list'}, sublist-match p sublist => sublist-skip {A} {list} {y} {list'} sublist\n  | {A}, {a}, {list}, {y :: list'}, sublist-skip sublist =>\n    sublist-skip {A} {list} {y} {list'} (shrink {A} {a} {list} {list'} sublist)", "sublist-skip (SubList {A} l ys)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})"]}
{"Context": ["S : SubSemigroup A", "A : CSemigroup"], "Expected type": "CSemigroup (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\n  | *-assoc => {?hidden}\n  | *-comm => {?hidden}\n}", "Expression": "\\new CSemigroup {\n  | Semigroup => ISemigroup {S}\n  | *-comm => ext *-comm\n}", "Premises": ["| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| *-comm {x y : E} : x * y = y * x", "| S : BaseSet", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "\\func ISemigroup \\hlevels  {this2 : SubSemigroup} : Semigroup (\\Sigma (x : E {S}) (contains x)) {\n  | * => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n} => \\new Semigroup {\n  | *-assoc => {?hidden}\n}", "| E : \\Set"]}
{"Context": ["this : SubSemigroup"], "Expected type": "Semigroup (\\Sigma (x : E {S}) (contains x)) {\n  | * => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | *-assoc => {?hidden}\n}", "Expression": "\\new Semigroup {\n  | BaseSet => ISet \n  | * => \\lam x y => (x.1 * y.1, contains_*  x.2 y.2)\n  | *-assoc => ext *-assoc\n}", "Premises": ["| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| S : BaseSet", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "| E : \\Set"]}
{"Context": ["x : E {\\this}", "this : Monoid (\\Sigma (x : E ", "this : SubMonoid"], "Expected type": "x * ide {\\this} = x", "Expression": "ext ide-right", "Premises": ["| \\infixl 7 * E E : E", "| ide-right {x : E} : x * ide = x", "| ide : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : SubMonoid"], "Expected type": "Monoid (\\Sigma (x : E {S}) (contains x)) {\n  | ide => (ide {S}, contains_ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n}", "Expression": "\\new Monoid {\n  | Pointed => IPointed \n  | Semigroup => ISemigroup \n  | ide-left => ext ide-left\n  | ide-right => ext ide-right\n}", "Premises": ["| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| S : BaseSet", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "\\func ISemigroup \\hlevels  {this2 : SubSemigroup} : Semigroup (\\Sigma (x : E {S}) (contains x)) {\n  | * => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n} => \\new Semigroup {\n  | *-assoc => {?hidden}\n}", "| ide-left {x : E} : ide * x = x", "| contains_ide : contains (ide {S})", "| ide-right {x : E} : x * ide = x", "| E : \\Set", "| ide : E"]}
{"Context": ["S : SubAddMonoid A", "A : AbMonoid"], "Expected type": "AbMonoid (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | zro => (zro {S.S}, S.contains_zro)\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, S.contains_+ {x.1} {y.1} x.2 y.2)\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n}", "Expression": "\\new AbMonoid {\n  | AddMonoid => IAddMonoid {S}\n  | +-comm => ext +-comm\n}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "\\func IAddMonoid \\hlevels  {this2 : SubAddMonoid} : AddMonoid (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro)\n  | + => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\n} => \\new AddMonoid {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "| S : BaseSet", "| contains (E {S}) : \\Prop", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| zro-right {x : E} : x + zro = x", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)", "| \\infixl 6 + E E : E", "| contains_zro : contains (zro {S})", "| zro-left {x : E} : zro + x = x", "| E : \\Set", "| zro : E"]}
{"Context": ["this : SubAddMonoid"], "Expected type": "AddMonoid (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro)\n  | + => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "Expression": "\\new AddMonoid {\n  | AddPointed => IAddPointed \n  | + => \\lam x y => (x.1 + y.1, contains_+  x.2 y.2)\n  | zro-left => ext zro-left\n  | zro-right => ext zro-right\n  | +-assoc => ext +-assoc\n}", "Premises": ["| S : BaseSet", "| \\infixl 6 + E E : E", "| contains_zro : contains (zro {S})", "| contains (E {S}) : \\Prop", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| zro-left {x : E} : zro + x = x", "| zro-right {x : E} : x + zro = x", "| E : \\Set", "| zro : E", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)"]}
{"Context": ["M : Monoid", "N : Monoid", "g : MonoidHom M N", "h1 : f.func = g.func", "f : MonoidHom M N"], "Expected type": "Path (\\lam (i : I) => (@) h1 i M.ide = N.ide) f.func-ide g.func-ide", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E"]}
{"Context": ["M : Monoid", "N : Monoid", "g : MonoidHom M N", "h1 : f.func = g.func", "f : MonoidHom M N"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) h1 i (x M.* y) = (@) h1 i x N.* (@) h1 i y) f.func-* g.func-*", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["M : Monoid", "S : \\Set"], "Expected type": "MonoidHom (ListMonoid {S}) M {\n  | func => extension {S} {M} {{?error}}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "Expression": "\\new MonoidHom {\n  | Dom => ListMonoid {S}\n  | Cod => M\n  | func => extension\n  | func-ide => idp\n  | func-* => helper\n}", "Premises": ["\\instance ListMonoid \\hlevels  {A : \\Set} : Monoid (List A) {\n  | ide => nil {A}\n  | * => (++)\n} => \\new Monoid {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n}", "| Dom : BaseSet", "\\func extension \\hlevels  {S1 : \\Set} {M2 : Monoid} {in1 : S1 -> M.E} (_ : E) : M.E \n  | {S}, {M}, {in}, nil => M.ide\n  | {S}, {M}, {in}, a :: l => in a M.* extension {S} {M} {in} l", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| func (E {Dom}) : E {Cod}", "| ide : E", "\\func helper \\hlevels  {S2 : \\Set} {M2 : Monoid} {in2 : S2 -> M.E} {x y2 : List S2} :\n  extension {S2} {M2} {in2} (x ++ y2) = extension {S2} {M2} {in2} x M.* extension {S2} {M2} {in2} y2 \n  | {S}, {M}, {in}, {nil}, {y} =>\n  transportInv {M.E} ((=) (extension {S} {M} {in} y)) {M.ide M.* extension {S} {M} {in} y} {extension {S} {M} {in} y}\n    (M.ide-left {extension {S} {M} {in} y}) (idp {M.E} {extension {S} {M} {in} y})\n  | {S}, {M}, {in}, {s :: l}, {y} => transportInv\n    {M.E} ((=) (in s M.* extension {S} {M} {in} (l ++ y))) {in s M.* extension {S} {M} {in} l M.* extension {S} {M} {in} y}\n      {in s M.* (extension {S} {M} {in} l M.* extension {S} {M} {in} y)}\n      (M.*-assoc {in s} {extension {S} {M} {in} l} {extension {S} {M} {in} y})\n      (transportInv {M.E} (\\lam (x : M.E) => in s M.* x = in s M.* (extension {S} {M} {in} l M.* extension {S} {M} {in} y))\n        {extension {S} {M} {in} (l ++ y)} {extension {S} {M} {in} l M.* extension {S} {M} {in} y} (helper {S} {M} {in} {l} {y})\n        (idp {M.E} {in s M.* (extension {S} {M} {in} l M.* extension {S} {M} {in} y)}))"]}
{"Context": ["A : \\Set", "l : Array A", "l' : Array A", "e : EPerm {A} l l'"], "Expected type": "inPS {A} l = inPS {A} l'", "Expression": "permSet-ext {?}", "Premises": ["\\lemma permSet-ext \\hlevels  {A : \\Set} {x y : PermSet A} (_ : x = y) : x = y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func inPS \\hlevels  {A : \\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l"]}
{"Context": ["l' : Array A.E", "l : Array A.E", "A : DecSet", "p : in~ {Array A.E} {EPerm {A.E}} l = in~ {Array A.E} {EPerm {A.E}} l'"], "Expected type": "TruncP (EPerm {A.E} l l')", "Expression": "unext p", "Premises": ["\\lemma unext \\hlevels  {A : \\Set} {l l' : Array A} (_ : inPS~ {A} l = inPS~ {A} l') : TruncP (EPerm {A} l l') ", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["A : \\Set", "l2 : Array A", "l3 : Array A", "l1 : Array A"], "Expected type": "in~ {Array A} {EPerm {A}} l1 * in~ {Array A} {EPerm {A}} l2 * in~ {Array A} {EPerm {A}} l3 = in~ {Array A} {EPerm {A}} l1 * (in~ {Array A} {EPerm {A}} l2 * in~ {Array A} {EPerm {A}} l3)", "Expression": "permSet-ext {?}", "Premises": ["\\lemma permSet-ext \\hlevels  {A : \\Set} {x y : PermSet A} (_ : x = y) : x = y ", "\\func * {A3 : \\Set} (_ _ : PermSet A3) : PermSet A3 \n  | {A}, in~ l, in~ l' => in~ {Array A} {EPerm {A}} (l ++ l')\n  | {A}, in~ l, ~-equiv l1 l2 r i => ~-psequiv {A} {l ++ l1} {l ++ l2} (eperm-++-right {A} {l} {l1} {l2} r) @ i\n  | {A}, ~-equiv l1 l2 r i, in~ l => ~-psequiv {A} {l1 ++ l} {l2 ++ l} (eperm-++-left {A} {l1} {l2} {l} r) @ i", "in~ A", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : A -> B", "l : Array A", "A : \\Set", "B : \\Set", "l' : Array A"], "Expected type": "permSet-map {A} {B} f (in~ {Array A} {EPerm {A}} l * in~ {Array A} {EPerm {A}} l') = permSet-map {A} {B} f (in~ {Array A} {EPerm {A}} l) * permSet-map {A} {B} f (in~ {Array A} {EPerm {A}} l')", "Expression": "permSet-ext {?}", "Premises": ["\\lemma permSet-ext \\hlevels  {A : \\Set} {x y : PermSet A} (_ : x = y) : x = y ", "\\func permSet-map \\hlevels  {A2 B2 : \\Set} (_ : A2 -> B2) (_ : PermSet A2) : PermSet B2 \n  | {A}, {B}, f, in~ l => in~ {Array B} {EPerm {B}} (map {A} {B} f l)\n  | {A}, {B}, f, ~-equiv x y r i => ~-psequiv {B} {map {A} {B} f x} {map {A} {B} f y} (EPerm_map {A} {B} f {x} {y} r) @ i", "| \\infixl 7 * E E : E", "in~ A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)"]}
{"Context": ["a : A", "n : Nat", "A : \\Set", "l : Array A n", "p : in~ {Array A} {EPerm {A}} (a :: l) = ide"], "Expected type": "TruncP (EPerm {A} (a :: l) nil)", "Expression": "unext p", "Premises": ["\\lemma unext \\hlevels  {A : \\Set} {l l' : Array A} (_ : inPS~ {A} l = inPS~ {A} l') : TruncP (EPerm {A} l l') ", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["S1 : Monoid X", "X : \\Set", "S2 : Monoid X", "h2 : (S1.*) = (S2.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h2 i ((@) h2 i x y) z = (@) h2 i x ((@) h2 i y z)) S1.*-assoc S2.*-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| *-assoc {x y z : E} : x * y * z = x * (y * z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : Monoid X", "h1 : S1.ide = S2.ide", "X : \\Set", "S2 : Monoid X", "h2 : (S1.*) = (S2.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i (h1 @ i) x = x) S1.ide-left S2.ide-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-left {x : E} : ide * x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : Monoid X", "h1 : S1.ide = S2.ide", "X : \\Set", "S2 : Monoid X", "h2 : (S1.*) = (S2.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i x (h1 @ i) = x) S1.ide-right S2.ide-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-right {x : E} : x * ide = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Cat Monoid ", "e : Iso", "q : \\new Monoid (E {e.dom}) {\n  | ide => ide {e.dom}\n  | * => (*) {e.dom}\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n} = \\new Monoid (E {e.cod}) {\n  | ide => ide {e.cod}\n  | * => (*) {e.cod}\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n}", "h1 : func {transport {Monoid} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {e.dom}) = ide {e.cod})\n  (func-ide {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-ide {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| f : Hom {C} dom cod", "| ide : E", "| Ob : \\hType"]}
{"Context": ["this : Cat Monoid ", "e : Iso", "q : \\new Monoid (E {e.dom}) {\n  | ide => ide {e.dom}\n  | * => (*) {e.dom}\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n} = \\new Monoid (E {e.cod}) {\n  | ide => ide {e.cod}\n  | * => (*) {e.cod}\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n}", "h1 : func {transport {Monoid} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y)\n  (func-* {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-* {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| \\infixl 7 * E E : E", "| id (X : Ob) : Hom X X", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType"]}
{"Context": ["S1 : AddMonoid X", "S2 : AddMonoid X", "X : \\Set", "h2 : (S1.+) = (S2.+)", "h1 : S1.zro = S2.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i (h1 @ i) x = x) S1.zro-left S2.zro-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-left {x : E} : zro + x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : AddMonoid X", "S2 : AddMonoid X", "X : \\Set", "h2 : (S1.+) = (S2.+)", "h1 : S1.zro = S2.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i x (h1 @ i) = x) S1.zro-right S2.zro-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-right {x : E} : x + zro = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : AddMonoid X", "S2 : AddMonoid X", "X : \\Set", "h2 : (S1.+) = (S2.+)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h2 i ((@) h2 i x y) z = (@) h2 i x ((@) h2 i y z)) S1.+-assoc S2.+-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["q : \\new AddMonoid (E {e.dom}) {\n  | zro => zro {e.dom}\n  | + => (+) {e.dom}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n} = \\new AddMonoid (E {e.cod}) {\n  | zro => zro {e.cod}\n  | + => (+) {e.cod}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "e : Iso", "h1 : func {transport {AddMonoid} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat AddMonoid "], "Expected type": "Path (\\lam (i : I) => (@) h1 i (zro {e.dom}) = zro {e.cod})\n  (func-zro {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-zro {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| cod : Ob {C}", "| dom : Ob {C}", "| id (X : Ob) : Hom X X", "| func-zro : func (zro {Dom}) = zro {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E", "| f : Hom {C} dom cod", "| Ob : \\hType"]}
{"Context": ["q : \\new AddMonoid (E {e.dom}) {\n  | zro => zro {e.dom}\n  | + => (+) {e.dom}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n} = \\new AddMonoid (E {e.cod}) {\n  | zro => zro {e.cod}\n  | + => (+) {e.cod}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "e : Iso", "h1 : func {transport {AddMonoid} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat AddMonoid "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {e.dom}} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-+ {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType"]}
{"Context": ["arg : zro {f.Dom} + x.1 = x.1", "x : E {\\this}", "this : AddMonoid (Kernel f) ", "f : AddMonoidHom"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (zro {\\this} + x).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["x : E {\\this}", "arg : x.1 + zro {f.Dom} = x.1", "this : AddMonoid (Kernel f) ", "f : AddMonoidHom"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (x + zro {\\this}).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["arg : x.1 + y.1 + z.1 = x.1 + (y.1 + z.1)", "y : E {\\this}", "x : E {\\this}", "z : E {\\this}", "this : AddMonoid (Kernel f) ", "f : AddMonoidHom"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (x + y + z).2 (x + (y + z)).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["y : E {\\this}", "arg : x.1 A.+ y.1 = y.1 A.+ x.1", "this : AbMonoid (Kernel f) ", "f : AddMonoidHom A", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (x + y).2 (y + x).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["A : AbMonoid", "f : AddMonoidHom A"], "Expected type": "AbMonoid (Kernel f) {\n  | zro => (zro {f.Dom}, f.func-zro)\n  | + => \\lam (a : E) (b : E) => (a.1 + b.1,\n    f.func-+ {a.1} {b.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func a.1} {zro {f.Cod}} a.2 {f.func b.1} {zro {f.Cod}} b.2 *> zro-left {f.Cod} {zro {f.Cod}})\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n}", "Expression": "\\new AbMonoid {\n  | E => Kernel f\n  | AddMonoid => KerAddMonoid f\n  | +-comm => ext +-comm\n}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap2 {A B C : \\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \n  => path (\\lam (i : I) => f (p @ i) (q @ i))", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| zro-right {x : E} : x + zro = x", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Dom : BaseSet", "| \\infixl 6 + E E : E", "| func-zro : func (zro {Dom}) = zro {Cod}", "| zro-left {x : E} : zro + x = x", "| Cod : BaseSet", "\\type Kernel \\hlevels  (f : AddPointedHom) : \\Set => \\Sigma (a : E {f.Dom}) (f.func a = zro {f.Cod})", "| zro : E", "| E : \\Set"]}
{"Context": ["f : AddMonoidHom", "arg : zro {f.Cod} + x.1 = x.1", "x : E {\\this}", "this : AddMonoid (Image "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (zro {\\this} + x).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : x.1 + zro {f.Cod} = x.1", "f : AddMonoidHom", "x : E {\\this}", "this : AddMonoid (Image "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x + zro {\\this}).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["z : E {\\this}", "f : AddMonoidHom", "y : E {\\this}", "x : E {\\this}", "arg : x.1 + y.1 + z.1 = x.1 + (y.1 + z.1)", "this : AddMonoid (Image "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x + y + z).2 (x + (y + z)).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : MonoidHom", "this : Monoid (Image ", "arg : ide {f.Cod} * x.1 = x.1", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (ide {\\this} * x).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : MonoidHom", "this : Monoid (Image ", "x : E {\\this}", "arg : x.1 * ide {f.Cod} = x.1"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x * ide {\\this}).2 x.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : MonoidHom", "this : Monoid (Image ", "x : E {\\this}", "z : E {\\this}", "arg : x.1 * y.1 * z.1 = x.1 * (y.1 * z.1)", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x * y * z).2 (x * (y * z)).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E {Dom {\\this}}", "this : MonoidHom f.Dom (ImageMonoid f) ", "f : MonoidHom", "arg : f.func (x * y) = f.func x * f.func y", "y : E {Dom {\\this}}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {\\this} (x * y)).2\n  (func {\\this} x * func {\\this} y).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : MonoidHom"], "Expected type": "MonoidHom f.Dom (ImageMonoid f) {\n  | func => \\lam (a : E {Dom {ImagePointedLeftHom f}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "Expression": "\\new MonoidHom {\n  | Dom => Dom {f}\n  | Cod => ImageMonoid f\n  | PointedHom => ImagePointedLeftHom f\n  | func-* => ext func-*\n}", "Premises": ["| \\infixl 7 * E E : E", "| func-ide : func (ide {Dom}) = ide {Cod}", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "| func (E {Dom}) : E {Cod}", "\\func ImagePointedLeftHom \\hlevels  (f : PointedHom) : PointedHom f.Dom (ImagePointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new PointedHom {\n  | func-ide => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Dom : BaseSet", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Cod : BaseSet", "inP A", "| E : \\Set"]}
{"Context": ["arg : f.func (x + y) = f.func x + f.func y", "this : AddMonoidHom f.Dom (ImageAddMonoid f) ", "x : E {Dom {\\this}}", "f : AddMonoidHom", "y : E {Dom {\\this}}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {\\this} (x + y)).2\n  (func {\\this} x + func {\\this} y).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : AddMonoidHom"], "Expected type": "AddMonoidHom f.Dom (ImageAddMonoid f) {\n  | func => \\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n  | func-zro => {?hidden}\n  | func-+ => {?hidden}\n}", "Expression": "\\new AddMonoidHom {\n  | Dom => Dom {f}\n  | Cod => ImageAddMonoid f\n  | AddPointedHom => ImageAddPointedLeftHom f\n  | func-+ => ext func-+\n}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| func-zro : func (zro {Dom}) = zro {Cod}", "| Cod : BaseSet", "inP A", "| E : \\Set", "\\func ImageAddPointedLeftHom \\hlevels  (f : AddPointedHom) : AddPointedHom f.Dom (ImageAddPointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new AddPointedHom {\n  | func-zro => {?hidden}\n}"]}
{"Context": ["y : E {\\this}", "x : E {\\this}", "f : AddMonoidHom A B", "this : AbMonoid (Image ", "arg : x.1 B.+ y.1 = y.1 B.+ x.1"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x + y).2 (y + x).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["D : BottomJoinSemilattice", "p : d D.<= d'", "F : Functor D MonoidCat", "h1 : (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, e)) = (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d', func {F.Func {d} {d'} p} e))", "d' : D.E", "d : D.E"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {F.F d}) = ide) (func-ide {inMap {D} {F1} d})\n  (func-ide {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D MonoidCat} (d : D.E) : MonoidHom (F.F d) (MonoidLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new MonoidHom {\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E"]}
{"Context": ["D : BottomJoinSemilattice", "p : d D.<= d'", "F : Functor D MonoidCat", "h1 : (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, e)) = (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d', func {F.Func {d} {d'} p} e))", "d' : D.E", "d : D.E"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {F.F d}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y) (func-* {inMap {D} {F1} d})\n  (func-* {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D MonoidCat} (d : D.E) : MonoidHom (F.F d) (MonoidLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new MonoidHom {\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 7 * E E : E", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, e)) = (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d', func {F.Func {d} {d'} p} e))", "d' : D.E", "D : BottomJoinSemilattice", "F : Functor D AddMonoidCat", "d : D.E", "p : d D.<= d'"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (zro {F.F d}) = zro) (func-zro {inMap {D} {F1} d})\n  (func-zro {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-zro : func (zro {Dom}) = zro {Cod}", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D AddMonoidCat} (d : D.E) :\nAddMonoidHom (F.F d) (AddMonoidLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new AddMonoidHom {\n  | func-zro => {?hidden}\n  | func-+ => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["h1 : (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, e)) = (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d', func {F.Func {d} {d'} p} e))", "d' : D.E", "D : BottomJoinSemilattice", "F : Functor D AddMonoidCat", "d : D.E", "p : d D.<= d'"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {F.F d}} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y) (func-+ {inMap {D} {F1} d})\n  (func-+ {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D AddMonoidCat} (d : D.E) :\nAddMonoidHom (F.F d) (AddMonoidLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new AddMonoidHom {\n  | func-zro => {?hidden}\n  | func-+ => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["d : D.E", "i : I", "h1 : (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, e)) = (\\lam (e : E {F.F d}) => in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d', func {F.Func {d} {d'} p} e))", "d' : D.E", "p : d D.<= d'", "F : Functor D AddGroupCat", "arg : \\Pi (a : E {F.F d}) ->\nin~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a) = in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d', func {F.Func {d} {d'} p} a)", "D : BottomJoinSemilattice"], "Expected type": "AddGroupHom (F.F d) (AddGroupLatticeColimit {D} F1) {\n  | func => \\lam (e : E {Dom {\\this}}) => arg e @ i\n  | func-+ => {?hidden}\n}", "Expression": "\\new AddGroupHom {\n  | func => \\lam e => arg e @ i\n  | func-+ => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (func-+ {inMap {D} {F} d}) (func-+ {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p})) i {x}\n}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| E : \\Set", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D AddGroupCat} (d : D.E) :\nAddGroupHom (F.F d) (AddGroupLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new AddGroupHom {\n  | func-+ => {?hidden}\n}"]}
{"Context": ["F : Functor D CRingCat", "D : BottomJoinSemilattice", "q : zro {\\this} = ide {\\this}"], "Expected type": "TruncP (\\Sigma (j : D.E) (p : D.bottom D.<= j) (q : D.bottom D.<= j)\n  (Func {D.bottom} {j} p (zro {F.F D.bottom}) = Func {D.bottom} {j} q (ide {F.F D.bottom})))", "Expression": "unext-ub q", "Premises": ["\\lemma unext-ub \\hlevels  {J : JoinSemilattice} {F1 : Functor J SetCat} {s s' : \\Sigma (j : J.E) (F.F j)} (_ : inC {J} {F1} s = inC {J} {F1} s') :\n  TruncP (\\Sigma (j : J.E) (p : s.1 J.<= j) (q : s'.1 J.<= j) (F.Func {s.1} {j} p s.2 = F.Func {s'.1} {j} q s'.2)) ", "| \\infix 4 <= E E : \\Prop", "| F (Ob {C}) : Ob {D}", "| bottom : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| zro : E", "| E : \\Set", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : E = J.E", "J : FinSet"], "Expected type": "Path (\\lam (i : I) => \\Pi (x y : h1 @ i) -> Dec (x = y)) decideEq J.decideEq", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Dec \\plevels  \\hlevels  \\Prop \n  | yes E\n  | no (Not E)", "\\field decideEq (x y : E) : Dec (x = y)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : E = J.E", "J : FinSet", "h2 : finCard = J.finCard"], "Expected type": "Path (\\lam (i : I) => TruncP (Equiv {Fin (h2 @ i)} {h1 @ i})) finEq J.finEq", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| finEq : TruncP (Equiv {Fin finCard} {E})", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["s : \\Sigma (c : Array (\\Sigma (E {R}) K)) (x = sum {K} g c)", "f : J -> K", "this : LModule", "g : K -> E", "h : \\Pi (i : Fin (len {s.1})) -> \\Sigma (x : J) (f x = (at {s.1} i).2)", "J : \\Set", "K : \\Set", "x : E"], "Expected type": "TruncP (\\Sigma (c : Array (\\Sigma (E {R}) J)) (x = sum {J} (\\lam (j : J) => g (f j)) c))", "Expression": "inP (mkArray (\\lam i => ((s.1 i).1, (h i).1)), s.2 *> pmap (BigSum ) (exts (\\lam i => cong (inv (h i).2))))", "Premises": ["\\func mkArray {A : \\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\new DArray", "| R : Ring", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func sum \\hlevels  {this : LModule} {J : \\Set} (g : J -> E) (c : Array (\\Sigma (E {R}) J)) : E \n  => BigSum (\\new Array E c.len (\\lam (j : Fin c.len) => (c.at j).1 *c g (c.at j).2))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : (**) (ide {G}) = (\\lam (e : E) => e)", "this : LinRepres"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y) (func-+ {toLinearMap (ide {G})})\n  (func-+ {id {R} {\\new this {}}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| G : Group", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| R : Ring", "\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func toLinearMap \\hlevels  {this2 : LinRepres} (g : E {G}) : LinearMap {LModule.R} (\\new this2 {}) (\\new this2 {}) {\n  | func => (**) g\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["h1 : (**) (ide {G}) = (\\lam (e : E) => e)", "this : LinRepres"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : E {R}} -> \\Pi {x : E} -> (@) h1 i (r *c x) = r *c (@) h1 i x) (func-*c {toLinearMap (ide {G})})\n  (func-*c {id {R} {\\new this {}}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| G : Group", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func toLinearMap \\hlevels  {this2 : LinRepres} (g : E {G}) : LinearMap {LModule.R} (\\new this2 {}) (\\new this2 {}) {\n  | func => (**) g\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["this : Equiv ", "C : Precat", "c : A {\\this}", "M : Monoid", "h1 : c {ret {\\this} (f {\\this} c1)} = c.c", "arg : \\Sigma (p1 : c {ret {\\this} (f {\\this} c1)} = c.c)\n  (transport {C.Ob} (\\lam (x : C.Ob) => MonoidHom M (End {C} x)) {c.c} {c.c} p1 (act {ret {\\this} (f {\\this} c1)}) = c.act)", "i : I"], "Expected type": "MonoidCatAction {C} M (h1 @ i) {\n  | act => pathOver {\\lam (i : I) => MonoidHom M (End {C} (h1 @ i))} {act {ret {\\this} (functor {c})}} {c.act} arg.2 @ i\n}", "Expression": "\\new MonoidCatAction {\n  | c => h1 @ i\n  | act => pathOver {\\lam i => ext_coe} arg.2 @ i\n}", "Premises": ["| ret B : A", "\\func pathOver {A : I -> \\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p", "\\func End \\plevels obj >= hom \\hlevels  {C : Precat} (c : C.Ob) : Monoid (C.Hom c c) {\n  | ide => C.id c\n  | * => (C.\u2218) {c} {c} {c}\n} => \\new Monoid {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n}", "| act : MonoidHom M (End {C} c)", "\\func functor \\plevels obj >= hom \\hlevels  {this2 : MonoidCatAction} : Functor (DeloopM M) MonoidCatAction.C (\\lam (_ : Ob {Functor.C {\\this}}) => c) {\n  | Func => \\lam {X Y : Ob {Functor.C {\\this}}} => func {act}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}"]}
{"Context": ["S2 : GroupAction G X", "G : Group", "X : \\Set", "S1 : GroupAction G X", "h1 : (\\lam (e1 : G.E) (x : X) => e.func (e1 ** x)) = (\\lam (e1 : G.E) (x : X) => e1 ** e.func x)"], "Expected type": "Path (\\lam (i : I) => \\Pi {m n : G.E} -> \\Pi {e : X} -> (@) h1 i m ((@) h1 i n e) = (@) h1 i (m G.* n) e) S1.**-assoc\n  S2.**-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| **-assoc {m n : E {G}} {e : E} : m ** (n ** e) = (m * n) ** e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S2 : GroupAction G X", "X : \\Set", "G : Group", "S1 : GroupAction G X", "h1 : (\\lam (e1 : G.E) (x : X) => e.func (e1 ** x)) = (\\lam (e1 : G.E) (x : X) => e1 ** e.func x)"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : X} -> (@) h1 i G.ide e = e) S1.id-action S2.id-action", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id-action {e : E} : ide {G} ** e = e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["e : Iso", "q : \\new GroupAction G1 (E {e.dom}) {\n  | ** => (**) {e.dom}\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n} = \\new GroupAction G1 (E {e.cod}) {\n  | ** => (**) {e.cod}\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n}", "G : Group", "h1 : func {transport {GroupAction G} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}", "this : Cat (GroupAction G1) "], "Expected type": "Path (\\lam (i : I) => \\Pi {e1 : E {e.dom}} -> \\Pi {g : G.E} -> (@) h1 i (g ** e1) = g ** (@) h1 i e1)\n  (func-** {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-** {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| \\infixl 8 ** (E {G}) E : E", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType"]}
{"Context": ["h1 : S1.ide = S2.ide", "h3 : S1.inverse = S2.inverse", "X : \\Set", "S1 : Group X", "S2 : Group X", "h2 : (S1.*) = (S2.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i ((@) h3 i x) x = h1 @ i) S1.inverse-left S2.inverse-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| inverse-left {x : E} : inverse x * x = ide"]}
{"Context": ["h1 : S1.ide = S2.ide", "h3 : S1.inverse = S2.inverse", "X : \\Set", "S1 : Group X", "S2 : Group X", "h2 : (S1.*) = (S2.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i x ((@) h3 i x) = h1 @ i) S1.inverse-right S2.inverse-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| inverse-right {x : E} : x * inverse x = ide", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : Func {\\this} {X} {Y} f = Func {\\this} {X} {Y} g", "Y : Ob {C {\\this}}", "g : Hom {C {\\this}} X Y", "X : Ob {C {\\this}}", "f : Hom {C {\\this}} X Y"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) p i (x X.* y) = (@) p i x Y.* (@) p i y) f.func-* g.func-*", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : Func {\\this} {X} {Y} f = Func {\\this} {X} {Y} g", "i : I", "Y : Ob {C {\\this}}", "g : Hom {C {\\this}} X Y", "X : Ob {C {\\this}}", "f : Hom {C {\\this}} X Y"], "Expected type": "GroupHom X Y {\n  | func => p @ i\n  | func-* => {?hidden}\n}", "Expression": "\\new GroupHom {\n  | func => p @ i\n  | func-* => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (func-* {f}) (func-* {g})) i {x}\n}", "Premises": ["| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": [], "Expected type": "FaithfulFunctor GroupCat SetCat (\\lam (G : Ob {C {\\this}}) => G.E) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (f : Hom {C {\\this}} X Y) => f.func\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n  | isFaithful => {?hidden}\n}", "Expression": "\\new FaithfulFunctor {\n  | C => GroupCat\n  | D => SetCat\n  | F => \\lam G => G\n  | Func => \\lam f => f\n  | Func-id => idp\n  | Func-o => idp\n  | isFaithful => \\lam p => ext p\n}", "Premises": ["| Hom Ob Ob : \\Set", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func (E {Dom}) : E {Cod}", "| Ob : \\hType", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| id (X : Ob) : Hom X X", "| C : Precat", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)", "| E : \\Set", "| D : Precat"]}
{"Context": ["this : Iso ", "h1 : func {hinv {\\this} \u2218 f} = func {id G}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {dom {\\this}}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y)\n  (func-* {hinv {\\this} \u2218 f {\\this}}) (func-* {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| \\infixl 7 * E E : E", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Iso ", "h1 : func {f \u2218 hinv {\\this}} = func {id H}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {cod {\\this}}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y)\n  (func-* {f {\\this} \u2218 hinv {\\this}}) (func-* {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| \\infixl 7 * E E : E", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "arg : inverse {f.Cod} x.1 * x.1 = ide {f.Cod}", "this : Group (Image ", "f : GroupHom"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (inverse {\\this} x * x).2 (ide {\\this}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| inverse E : E", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E {\\this}", "arg : x.1 * inverse {f.Cod} x.1 = ide {f.Cod}", "this : Group (Image ", "f : GroupHom"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x * inverse {\\this} x).2 (ide {\\this}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| inverse E : E", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h2 : (A.+) = (B.+)", "B : AddGroup X", "A : AddGroup X", "X : \\Set", "h1 : A.zro = B.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i (h1 @ i) x = x) A.zro-left B.zro-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-left {x : E} : zro + x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (A.+) = (B.+)", "B : AddGroup X", "A : AddGroup X", "X : \\Set", "h1 : A.zro = B.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i x (h1 @ i) = x) A.zro-right B.zro-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-right {x : E} : x + zro = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (A.+) = (B.+)", "B : AddGroup X", "A : AddGroup X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h2 i ((@) h2 i x y) z = (@) h2 i x ((@) h2 i y z)) A.+-assoc B.+-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (A.+) = (B.+)", "h3 : A.negative = B.negative", "B : AddGroup X", "A : AddGroup X", "X : \\Set", "h1 : A.zro = B.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i ((@) h3 i x) x = h1 @ i) A.negative-left B.negative-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| negative-left {x : E} : negative x + x = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (A.+) = (B.+)", "h3 : A.negative = B.negative", "B : AddGroup X", "A : AddGroup X", "X : \\Set", "h1 : A.zro = B.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i x ((@) h3 i x) = h1 @ i) A.negative-right B.negative-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| negative-right {x : E} : x + negative x = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : negative {f.Dom} x.1 + x.1 = zro {f.Dom}", "x : E {\\this}", "this : AddGroup (Kernel f) ", "f : AddGroupHom"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (negative {\\this} x + x).2 (zro {\\this}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| Cod : BaseSet", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["x : E {\\this}", "this : AddGroup (Kernel f) ", "arg : x.1 + negative {f.Dom} x.1 = zro {f.Dom}", "f : AddGroupHom"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (x + negative {\\this} x).2 (zro {\\this}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| Cod : BaseSet", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["x : Kernel f", "arg : x.1 = zro.1", "f : AddGroupHom"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) x.2 zro.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["x : E {\\this}", "this : AddGroup (Image ", "arg : negative {f.Cod} x.1 + x.1 = zro {f.Cod}", "f : AddGroupHom"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (negative {\\this} x + x).2 (zro {\\this}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : x.1 + negative {f.Cod} x.1 = zro {f.Cod}", "x : E {\\this}", "this : AddGroup (Image ", "f : AddGroupHom"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (x + negative {\\this} x).2 (zro {\\this}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : func {universalQuotientMorph \u2218 quotient-map {G} {N}} = func {f}", "this : UniversalGroupQuotient"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {G}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y)\n  (func-* {universalQuotientMorph \u2218 quotient-map {G} {N}}) (func-* {f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "\\func universalQuotientMorph \\hlevels  {this : UniversalGroupQuotient} : GroupHom (G // N) H {\n  | func => uqms\n} => \\new GroupHom {\n  | func-* => {?hidden}\n}", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "| f : GroupHom G H", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func quotient \\hlevels  {this1 : NormalSubGroup} : Group Cosets {\n  | ide => in~ {E {S}} {(~)} (ide {S})\n  | * => (NormalSubGroup.quotient.*)\n  | inverse => NormalSubGroup.quotient.inverse\n} => \\new Group {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse-left => {?hidden}\n  | inverse-right => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func quotient-map \\hlevels  {S1 : Group} {H : NormalSubGroup S1} : GroupHom S1 (quotient {H}) {\n  | func => func {quotient-proj-setwise {H}}\n} => \\new GroupHom {\n  | func-* => {?hidden}\n}", "| G : Group", "| N : NormalSubGroup G"]}
{"Context": ["h1 : func {universalQuotientMorph \u2218 quotient-map {G} {N}} = func {f}", "i : I", "arg : \\Pi (x : E {G}) -> func {universalQuotientMorph \u2218 quotient-map {G} {N}} x = func {f} x", "this : UniversalGroupQuotient"], "Expected type": "GroupHom G H {\n  | func => \\lam (e : E {Dom {\\this}}) => arg e @ i\n  | func-* => {?hidden}\n}", "Expression": "\\new GroupHom {\n  | func => \\lam e => arg e @ i\n  | func-* => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (func-* {universalQuotientMorph \u2218 quotient-map {G} {N}}) (func-* {f})) i {x}\n}", "Premises": ["| \\infixl 7 * E E : E", "\\func universalQuotientMorph \\hlevels  {this : UniversalGroupQuotient} : GroupHom (G // N) H {\n  | func => uqms\n} => \\new GroupHom {\n  | func-* => {?hidden}\n}", "| H : Group", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "| f : GroupHom G H", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func quotient \\hlevels  {this1 : NormalSubGroup} : Group Cosets {\n  | ide => in~ {E {S}} {(~)} (ide {S})\n  | * => (NormalSubGroup.quotient.*)\n  | inverse => NormalSubGroup.quotient.inverse\n} => \\new Group {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse-left => {?hidden}\n  | inverse-right => {?hidden}\n}", "| Dom : BaseSet", "| E : \\Set", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func quotient-map \\hlevels  {S1 : Group} {H : NormalSubGroup S1} : GroupHom S1 (quotient {H}) {\n  | func => func {quotient-proj-setwise {H}}\n} => \\new GroupHom {\n  | func-* => {?hidden}\n}", "| G : Group", "| N : NormalSubGroup G"]}
{"Context": ["G : CGroup", "S : SubGroup G"], "Expected type": "CGroup (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | ide => (ide {S.S}, S.contains_ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse => \\lam (x : E) => (inverse {S.S} x.1, S.contains_inverse {x.1} x.2)\n  | inverse-left => {?hidden}\n  | *-comm => {?hidden}\n}", "Expression": "\\new CGroup {\n  | Group => IGroup {S}\n  | *-comm => ext *-comm\n}", "Premises": ["| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)", "| S : BaseSet", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "| contains_ide : contains (ide {S})", "\\func IGroup \\hlevels  {this2 : SubGroup} : Group (\\Sigma (x : E {S}) (contains x)) {\n  | ide => (ide {S}, contains_ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | inverse => \\lam (x : E {\\this}) => (inverse {S} x.1, contains_inverse {x.1} x.2)\n} => \\new Group {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse-left => {?hidden}\n  | inverse-right => {?hidden}\n}", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| inverse E : E", "| *-comm {x y : E} : x * y = y * x", "| ide-left {x : E} : ide * x = x", "| ide-right {x : E} : x * ide = x", "| E : \\Set", "| contains_inverse {x : E {S}} (contains x) : contains (inverse {S} x)", "| ide : E", "| inverse-left {x : E} : inverse x * x = ide"]}
{"Context": ["this : SubGroup"], "Expected type": "Group (\\Sigma (x : E {S}) (contains x)) {\n  | ide => (ide {S}, contains_ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse => \\lam (x : E {\\this}) => (inverse {S} x.1, contains_inverse {x.1} x.2)\n  | inverse-left => {?hidden}\n  | inverse-right => {?hidden}\n}", "Expression": "\\new Group {\n  | Monoid => IMonoid \n  | inverse => \\lam x => (inverse x.1, contains_inverse  x.2)\n  | inverse-left => ext inverse-left\n  | inverse-right => ext inverse-right\n}", "Premises": ["| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)", "| S : BaseSet", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "| contains_ide : contains (ide {S})", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "\\func IMonoid \\hlevels  {this1 : SubMonoid} : Monoid (\\Sigma (x : E {S}) (contains x)) {\n  | ide => (ide {S}, contains_ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n} => \\new Monoid {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n}", "| inverse-right {x : E} : x * inverse x = ide", "| inverse E : E", "| ide-left {x : E} : ide * x = x", "| ide-right {x : E} : x * ide = x", "| E : \\Set", "| contains_inverse {x : E {S}} (contains x) : contains (inverse {S} x)", "| ide : E", "| inverse-left {x : E} : inverse x * x = ide"]}
{"Context": ["A : AbGroup", "S : SubAddGroup A"], "Expected type": "AbGroup (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | zro => (zro {S.S}, S.contains_zro)\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, S.contains_+ {x.1} {y.1} x.2 y.2)\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => \\lam (x : E) => (negative {S.S} x.1, S.contains_negative {x.1} x.2)\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n}", "Expression": "\\new AbGroup {\n  | AddGroup => IAddGroup {S}\n  | +-comm => ext +-comm\n}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "| S : BaseSet", "| contains (E {S}) : \\Prop", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)", "| zro-right {x : E} : x + zro = x", "| negative E : E", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)", "| negative-left {x : E} : negative x + x = zro", "| \\infixl 6 + E E : E", "| contains_zro : contains (zro {S})", "| zro-left {x : E} : zro + x = x", "| E : \\Set", "| zro : E", "\\func IAddGroup \\hlevels  {this2 : SubAddGroup} : AddGroup (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro)\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E {\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\n} => \\new AddGroup {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | negative-right => {?hidden}\n}"]}
{"Context": ["this : SubAddGroup"], "Expected type": "AddGroup (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro)\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => \\lam (x : E {\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\n  | negative-left => {?hidden}\n  | negative-right => {?hidden}\n}", "Expression": "\\new AddGroup {\n  | AddMonoid => IAddMonoid \n  | negative => \\lam x => (negative x.1, contains_negative  x.2)\n  | negative-left => ext negative-left\n  | negative-right => ext negative-right\n}", "Premises": ["\\func IAddMonoid \\hlevels  {this2 : SubAddMonoid} : AddMonoid (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro)\n  | + => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\n} => \\new AddMonoid {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "| S : BaseSet", "| contains (E {S}) : \\Prop", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)", "| zro-right {x : E} : x + zro = x", "| negative E : E", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)", "| negative-left {x : E} : negative x + x = zro", "| negative-right {x : E} : x + negative x = zro", "| \\infixl 6 + E E : E", "| contains_zro : contains (zro {S})", "| zro-left {x : E} : zro + x = x", "| E : \\Set", "| zro : E"]}
{"Context": ["this : SplitMono ", "h1 : (\\lam (e : BaseSet.E {SubLRepres.S {Maschke'sLemma.S}}) =>\n  func {mean_func {Maschke'sLemma.E} {SubLRepres.S {Maschke'sLemma.S}} p.hinv} (func {in {Maschke'sLemma.S}} e)) = func {id (SubLRepres.S {Maschke'sLemma.S})}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {dom {\\this}}} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {hinv {\\this} \u2218 f {\\this}}) (func-+ {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Maschke'sLemma", "this : SplitMono ", "h1 : (\\lam (e : BaseSet.E {SubLRepres.S {Maschke'sLemma.S}}) =>\n  func {mean_func {Maschke'sLemma.E} {SubLRepres.S {Maschke'sLemma.S}} p.hinv} (func {in {Maschke'sLemma.S}} e)) = func {id (SubLRepres.S {Maschke'sLemma.S})}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : E {R}} -> \\Pi {x : E {dom {\\this}}} -> (@) h1 i (r *c x) = r *c (@) h1 i x)\n  (func-*c {hinv {\\this} \u2218 f {\\this}}) (func-*c {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 *c (E {R}) E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| R : CRing", "| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : Maschke'sLemma", "this : SplitMono ", "h1 : (\\lam (e : BaseSet.E {SubLRepres.S {Maschke'sLemma.S}}) =>\n  func {mean_func {Maschke'sLemma.E} {SubLRepres.S {Maschke'sLemma.S}} p.hinv} (func {in {Maschke'sLemma.S}} e)) = func {id (SubLRepres.S {Maschke'sLemma.S})}"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : E {dom {\\this}}} -> \\Pi {g : E {G}} -> (@) h1 i (g ** e) = g ** (@) h1 i e)\n  (func-** {hinv {\\this} \u2218 f {\\this}}) (func-** {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 8 ** (E {G}) E : E", "| dom : Ob {C}", "| G : FinGroup", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod"]}
{"Context": ["this : PermutationRepresReducible"], "Expected type": "LinearMap {PermutationRepresReducible.R} R_m Module {\n  | func => \\lam (r : E {PermutationRepresReducible.R}) (_ : E {X}) => r\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "Expression": "\\new LinearMap {\n  | R => _\n  | Dom => R_m \n  | Cod => Module \n  | func => \\lam (r : R ) => \\lam _ => r\n  | func-+ => ext (\\lam _ => idp)\n  | func-*c => ext (\\lam _ => idp)\n}", "Premises": ["| R : Ring", "| Dom : BaseSet", "| \\infixl 6 + E E : E", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| X : GroupAction G", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func Module \\hlevels  {this1 : PermutationRepresReducible} : LModule PermutationRepresReducible.R (E {X} -> E) {\n  | zro => \\lam (_ : E {X}) => zro\n  | + => \\lam (f : E {\\this}) (g : E {\\this}) (j : E {X}) => f j + g j\n  | negative => \\lam (f : E {\\this}) (j : E {X}) => negative (f j)\n  | *c => \\lam (r : E {LModule.R {\\this}}) (f : E {\\this}) (j : E {X}) => r *c f j\n} => PowerLModule {PermutationRepresReducible.R} (E {X}) R_m", "| Cod : BaseSet", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func R_m \\hlevels  {this : PermutationRepresReducible} : LModule R (E {R}) {\n  | zro => zro {R}\n  | + => (+) {R}\n  | negative => negative {R}\n  | *c => (*) {R}\n} => RingLModule R"]}
{"Context": ["this : PermutationRepresReducible", "this : SubLRepres "], "Expected type": "InterwiningMap {SubLRepres.G {\\this}} {SubLRepres.R {\\this}} (S {\\this}) (SubLRepres.E {\\this}) {\n  | func => \\lam (r : BaseSet.E {PermutationRepresReducible.R}) (_ : BaseSet.E {X}) => r\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n  | func-** => {?hidden}\n}", "Expression": "\\new InterwiningMap {\n  | LinearMap => invSubMod \n  | func-** => \\lam {e : R_m-triv } {g : G } => ext (\\lam _ => rewrite (fixed-submodule  g e) idp)\n}", "Premises": ["| S : LinRepres R G", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| G : Group", "| X : GroupAction G", "| func (E {Dom}) : E {Cod}", "\\func fixed-submodule \\hlevels  {this : PermutationRepresReducible} (g : E {G}) (r : E {R}) : g ** func {invSubMod} r = func {invSubMod} r \n  => path (\\lam (i : I) (e : E {X}) => aux r e (inverse {G} g ** e) @ i)", "| R : Ring", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| G : Group", "| R : Ring", "| \\infixl 8 ** (E {G}) E : E", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : LinRepres R G", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\func Repr \\hlevels  {this1 : PermutationRepresReducible} : LinRepres PermutationRepresReducible.R PermutationRepresReducible.G (E {X} -> E) {\n  | zro => \\lam (_ : E {X}) => zro\n  | + => \\lam (f : E) (g : E) (j : E {X}) => f j + g j\n  | negative => \\lam (f : E) (j : E {X}) => negative (f j)\n  | *c => \\lam (r : E {LModule.R}) (f : E) (j : E {X}) => r *c f j\n  | ** => \\lam (g : E {GroupAction.G {\\this}}) (f : E {\\this}) (j : E {X}) => f (inverse {PermutationRepresReducible.G} g ** j)\n} => PermRepr {PermutationRepresReducible.R} {PermutationRepresReducible.G} X", "| E : \\Set", "\\func R_m-triv \\hlevels  {this : PermutationRepresReducible} : LinRepres R PermutationRepresReducible.G E {\n  | zro => zro\n  | + => (+)\n  | negative => negative\n  | *c => (*c)\n  | ** => \\lam (_ : E {GroupAction.G}) (e : E) => e\n} => TrivialAction {R} R_m PermutationRepresReducible.G", "\\func invSubMod \\hlevels  {this1 : PermutationRepresReducible} : LinearMap {PermutationRepresReducible.R} R_m Module {\n  | func => \\lam (r : E {PermutationRepresReducible.R}) (_ : E {X}) => r\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}"]}
{"Context": ["p : func {KerLRepresHom {R} {G} {A} {B} f} a = func {KerLRepresHom {R} {G} {A} {B} f} a'", "a : E", "a' : E", "f : InterwiningMap "], "Expected type": "Path (\\lam (i : I) => f.func (p @ i) = zro {f.Cod}) a.2 a'.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["a' : E", "p : func {ImageLRepresRightHom {R} {G} f} a = func {ImageLRepresRightHom {R} {G} f} a'", "f : InterwiningMap ", "a : E"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = p @ i))) a.2 a'.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["X : Ob {\\this}", "this : Cat (LinRepres R G) ", "Y : Ob {\\this}", "arg : func {id {\\this} Y \u2218 f} = func {id {\\this} Y \u2218 f}", "f : Hom {\\this} X Y"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) arg i (x X.+ y) = (@) arg i x Y.+ (@) arg i y) (func-+ {id {\\this} Y \u2218 f})\n  f.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["X : Ob {\\this}", "R : Ring", "this : Cat (LinRepres R G) ", "Y : Ob {\\this}", "arg : func {id {\\this} Y \u2218 f} = func {id {\\this} Y \u2218 f}", "f : Hom {\\this} X Y"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) arg i (r X.*c x) = r Y.*c (@) arg i x)\n  (func-*c {id {\\this} Y \u2218 f}) f.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| \\infixl 7 *c (E {R}) E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["X : Ob {\\this}", "G : Group", "this : Cat (LinRepres R G) ", "Y : Ob {\\this}", "arg : func {id {\\this} Y \u2218 f} = func {id {\\this} Y \u2218 f}", "f : Hom {\\this} X Y"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : X.E} -> \\Pi {g : G.E} -> (@) arg i (g X.** e) = g Y.** (@) arg i e)\n  (func-** {id {\\this} Y \u2218 f}) f.func-**", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| id (X : Ob) : Hom X X", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : func {f \u2218 id {\\this} X} = func {f \u2218 id {\\this} X}", "Y : Ob {\\this}", "f : Hom {\\this} X Y", "this : Cat (LinRepres R G) ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) arg i (x X.+ y) = (@) arg i x Y.+ (@) arg i y) (func-+ {f \u2218 id {\\this} X})\n  f.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : func {f \u2218 id {\\this} X} = func {f \u2218 id {\\this} X}", "Y : Ob {\\this}", "f : Hom {\\this} X Y", "R : Ring", "this : Cat (LinRepres R G) ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) arg i (r X.*c x) = r Y.*c (@) arg i x)\n  (func-*c {f \u2218 id {\\this} X}) f.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id (X : Ob) : Hom X X", "| \\infixl 7 *c (E {R}) E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : func {f \u2218 id {\\this} X} = func {f \u2218 id {\\this} X}", "Y : Ob {\\this}", "f : Hom {\\this} X Y", "G : Group", "this : Cat (LinRepres R G) ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : X.E} -> \\Pi {g : G.E} -> (@) arg i (g X.** e) = g Y.** (@) arg i e)\n  (func-** {f \u2218 id {\\this} X}) f.func-**", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| id (X : Ob) : Hom X X", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : Ob {\\this}", "g : Hom {\\this} Y Z", "Z : Ob {\\this}", "arg : func {h \u2218 g \u2218 f} = func {h \u2218 g \u2218 f}", "this : Cat (LinRepres R G) ", "f : Hom {\\this} X Y", "X : Ob {\\this}", "W : Ob {\\this}", "h : Hom {\\this} Z W"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) arg i (x X.+ y) = (@) arg i x W.+ (@) arg i y) (func-+ {h \u2218 g \u2218 f})\n  (func-+ {h \u2218 (g \u2218 f)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : Ob {\\this}", "g : Hom {\\this} Y Z", "R : Ring", "Z : Ob {\\this}", "arg : func {h \u2218 g \u2218 f} = func {h \u2218 g \u2218 f}", "this : Cat (LinRepres R G) ", "f : Hom {\\this} X Y", "X : Ob {\\this}", "W : Ob {\\this}", "h : Hom {\\this} Z W"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) arg i (r X.*c x) = r W.*c (@) arg i x) (func-*c {h \u2218 g \u2218 f})\n  (func-*c {h \u2218 (g \u2218 f)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 *c (E {R}) E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["Y : Ob {\\this}", "g : Hom {\\this} Y Z", "Z : Ob {\\this}", "G : Group", "arg : func {h \u2218 g \u2218 f} = func {h \u2218 g \u2218 f}", "this : Cat (LinRepres R G) ", "f : Hom {\\this} X Y", "X : Ob {\\this}", "W : Ob {\\this}", "h : Hom {\\this} Z W"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : X.E} -> \\Pi {g : G.E} -> (@) arg i (g X.** e) = g W.** (@) arg i e) (func-** {h \u2218 g \u2218 f})\n  (func-** {h \u2218 (g \u2218 f)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "X : \\Set", "h2 : (S1.+) = (S2.+)", "h1 : S1.zro = S2.zro", "h3 : S1.negative = S2.negative"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i ((@) h3 i x) x = h1 @ i) S1.negative-left S2.negative-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| negative-left {x : E} : negative x + x = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "X : \\Set", "h2 : (S1.+) = (S2.+)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X} -> (@) h2 i x y = (@) h2 i y x) S1.+-comm S2.+-comm", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "h4 : (S1.*c) = (S2.*c)", "X : \\Set", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {r r' : R.E} -> \\Pi {a : X} -> (@) h4 i (r R.* r') a = (@) h4 i r ((@) h4 i r' a)) S1.*c-assoc\n  S2.*c-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "h4 : (S1.*c) = (S2.*c)", "X : \\Set", "h2 : (S1.+) = (S2.+)", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {a b : X} -> (@) h4 i r ((@) h2 i a b) = (@) h2 i ((@) h4 i r a) ((@) h4 i r b))\n  S1.*c-ldistr S2.*c-ldistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "h4 : (S1.*c) = (S2.*c)", "X : \\Set", "h2 : (S1.+) = (S2.+)", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {r s : R.E} -> \\Pi {a : X} -> (@) h4 i (r R.+ s) a = (@) h2 i ((@) h4 i r a) ((@) h4 i s a))\n  S1.*c-rdistr S2.*c-rdistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *c-rdistr {r s : E {R}} {a : E} : (r + s) *c a = r *c a + s *c a"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "h4 : (S1.*c) = (S2.*c)", "X : \\Set", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {a : X} -> (@) h4 i R.ide a = a) S1.ide_*c S2.ide_*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide_*c {a : E} : ide {R} *c a = a", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "X : \\Set", "G : Group", "h5 : (S1.**) = (S2.**)"], "Expected type": "Path (\\lam (i : I) => \\Pi {m n : G.E} -> \\Pi {e : X} -> (@) h5 i m ((@) h5 i n e) = (@) h5 i (m G.* n) e) S1.**-assoc\n  S2.**-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| **-assoc {m n : E {G}} {e : E} : m ** (n ** e) = (m * n) ** e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "X : \\Set", "h5 : (S1.**) = (S2.**)", "G : Group"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : X} -> (@) h5 i G.ide e = e) S1.id-action S2.id-action", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| id-action {e : E} : ide {G} ** e = e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "X : \\Set", "h2 : (S1.+) = (S2.+)", "G : Group", "h5 : (S1.**) = (S2.**)"], "Expected type": "Path (\\lam (i : I) => \\Pi {g : G.E} -> \\Pi {e e' : X} -> (@) h5 i g ((@) h2 i e e') = (@) h2 i ((@) h5 i g e) ((@) h5 i g e'))\n  S1.**-ldistr S2.**-ldistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| **-ldistr {g : E {G}} {e e' : E} : g ** (e + e') = g ** e + g ** e'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S1 : LinRepres R G X", "S2 : LinRepres R G X", "h4 : (S1.*c) = (S2.*c)", "X : \\Set", "R : Ring", "G : Group", "h5 : (S1.**) = (S2.**)"], "Expected type": "Path (\\lam (i : I) => \\Pi {g : G.E} -> \\Pi {e : X} -> \\Pi {c : R.E} -> (@) h5 i g ((@) h4 i c e) = (@) h4 i c ((@) h5 i g e))\n  S1.**-*c S2.**-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| **-*c {g : E {G}} {e : E} {c : E {R}} : g ** (c *c e) = c *c g ** e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["e : Iso", "q : \\new LinRepres R1 G1 (E {e.dom}) {\n  | zro => zro {e.dom}\n  | + => (+) {e.dom}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => negative {e.dom}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c => (*c) {e.dom}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | ** => (**) {e.dom}\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n  | **-ldistr => {?hidden}\n  | **-*c => {?hidden}\n} = \\new LinRepres R1 G1 (E {e.cod}) {\n  | zro => zro {e.cod}\n  | + => (+) {e.cod}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => negative {e.cod}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c => (*c) {e.cod}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | ** => (**) {e.cod}\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n  | **-ldistr => {?hidden}\n  | **-*c => {?hidden}\n}", "R : Ring", "this : Cat (LinRepres R G) ", "h1 : func {transport {LinRepres R G} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} = func {e.f}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : E {e.dom}} -> (@) h1 i (r *c x) = r *c (@) h1 i x)\n  (func-*c {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}) (func-*c {e.f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| Hom Ob Ob : \\Set", "| dom : Ob {C}", "| cod : Ob {C}", "| id (X : Ob) : Hom X X", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Ob : \\hType"]}
{"Context": ["arg : (\\lam (e : A.E) => func {p.hinv} (func {p.f} e)) = (\\lam (e : A.E) => e)", "G : Group", "B : LinRepres R G", "p : Iso ", "A : LinRepres R G", "R : Ring", "f : InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) arg i (x A.+ y) = (@) arg i x A.+ (@) arg i y)\n  (func-+ {\\new InterwiningMap {G1} {R} A A {\n    | func => \\lam (a : E {Dom {inverseMap {R} {G1} {A} {B} {f} {p} \u2218 f}}) => func {inverseMap {R} {G1} {A} {B} {f} {p}} (f.func a)\n    | func-+ => {?hidden}\n    | func-*c => {?hidden}\n    | func-** => {?hidden}\n  }}) (func-+ {id-interwining {R} {G1} A})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\func id-interwining \\hlevels  {R : Ring} {G1 : Group} (X : LinRepres R G1) : InterwiningMap {G1} {R} X X {\n  | func => \\lam (a : E {Dom {id {R} {X}}}) => a\n} => \\new InterwiningMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n  | func-** => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func inverseMap {R : Ring} {G : Group} {A B : LinRepres R G} {f : InterwiningMap {G} {R} A B} {p : Iso {LModuleCat R} {A} {B} f} :\nInterwiningMap {G} {R} B A {\n  | func => func {p.hinv}\n} => \\new InterwiningMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n  | func-** => {?hidden}\n}", "| Dom : BaseSet", "| G : Group", "| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["B : LinRepres R G", "G : Group", "p : Iso ", "R : Ring", "A : LinRepres R G", "f : InterwiningMap ", "arg : (\\lam (e : B.E) => func {p.f} (func {p.hinv} e)) = (\\lam (e : B.E) => e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : B.E} -> (@) arg i (x B.+ y) = (@) arg i x B.+ (@) arg i y)\n  (func-+ {\\new InterwiningMap {G1} {R} B B {\n    | func => \\lam (a : E {Dom {f \u2218 inverseMap {R} {G1} {A} {B} {f} {p}}}) => f.func (func {inverseMap {R} {G1} {A} {B} {f} {p}} a)\n    | func-+ => {?hidden}\n    | func-*c => {?hidden}\n    | func-** => {?hidden}\n  }}) (func-+ {id-interwining {R} {G1} B})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\func id-interwining \\hlevels  {R : Ring} {G1 : Group} (X : LinRepres R G1) : InterwiningMap {G1} {R} X X {\n  | func => \\lam (a : E {Dom {id {R} {X}}}) => a\n} => \\new InterwiningMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n  | func-** => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func inverseMap {R : Ring} {G : Group} {A B : LinRepres R G} {f : InterwiningMap {G} {R} A B} {p : Iso {LModuleCat R} {A} {B} f} :\nInterwiningMap {G} {R} B A {\n  | func => func {p.hinv}\n} => \\new InterwiningMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n  | func-** => {?hidden}\n}", "| Dom : BaseSet", "| G : Group", "| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["this : LinRepres R1 G1 (Kernel f) ", "arg : _x A.** (e A.** e1.1) = (_x * e) A.** e1.1", "_ : G.E", "f : InterwiningMap ", "_ : G.E", "_ : E"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (_x ** (e ** e1)).2 ((_x * e) ** e1).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 7 * E E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["this : LinRepres R1 G1 (Kernel f) ", "arg : ide {A.G} A.** e.1 = e.1", "f : InterwiningMap ", "e : E {\\this}"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (ide {G {\\this}} ** e).2 e.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| G : Group", "| \\infixl 8 ** (E {G}) E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E", "| ide : E"]}
{"Context": ["this : LinRepres R1 G1 (Kernel f) ", "e : E {\\this}", "e' : E {\\this}", "arg : g A.** (e.1 A.+ e'.1) = g A.** e.1 A.+ g A.** e'.1", "g : E {G {\\this}}", "f : InterwiningMap "], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (g ** (e + e')).2 (g ** e + g ** e').2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["this : LinRepres R1 G1 (Kernel f) ", "g : E {G {\\this}}", "e : E {\\this}", "f : InterwiningMap ", "c : E {R {\\this}}", "arg : g A.** (c A.*c e.1) = c A.*c g A.** e.1"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (g ** (c *c e)).2 (c *c g ** e).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 7 *c (E {R}) E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["f : InterwiningMap ", "this : LinRepres R1 G1 (Image ", "m : E {G {\\this}}", "e : E {\\this}", "arg : m B.** (n B.** e.1) = (m * n) B.** e.1", "n : E {G {\\this}}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (m ** (n ** e)).2 ((m * n) ** e).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 8 ** (E {G}) E : E", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : InterwiningMap ", "this : LinRepres R1 G1 (Image ", "e : E {\\this}", "arg : ide {B.G} B.** e.1 = e.1"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (ide {G {\\this}} ** e).2 e.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| G : Group", "| \\infixl 8 ** (E {G}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["g : E {G {\\this}}", "e : E {\\this}", "f : InterwiningMap ", "this : LinRepres R1 G1 (Image ", "arg : g B.** (e.1 B.+ e'.1) = g B.** e.1 B.+ g B.** e'.1", "e' : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (g ** (e + e')).2 (g ** e + g ** e').2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : InterwiningMap ", "g : E {G {\\this}}", "e : E {\\this}", "arg : g B.** (c B.*c e.1) = c B.*c g B.** e.1", "this : LinRepres R1 G1 (Image ", "c : E {R {\\this}}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (g ** (c *c e)).2 (c *c g ** e).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 8 ** (E {G}) E : E", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : f.func (e1 ** e) = (e1 ** (f.func e, inP {\\Sigma (a : E {f.Dom}) (f.func a = f.func e)} (e, idp {E {f.Cod}} {f.func e}))).1", "f : InterwiningMap ", "_ : E {Dom {\\this}}", "this : InterwiningMap ", "_ : E {G {\\this}}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {\\this} (e1 ** e)).2\n  (e1 ** func {\\this} e).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 8 ** (E {G}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : InterwiningMap ", "R : Ring", "G : Group"], "Expected type": "InterwiningMap {G1} {R} f.Dom (ImageLRepres {R} {G1} {f.Dom} {f.Cod} (\\new f {})) {\n  | func => \\lam (a : E {Dom {ImageAddPointedLeftHom (\\new f {})}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n  | func-** => {?hidden}\n}", "Expression": "\\new InterwiningMap {\n  | G => _\n  | R => _\n  | Dom => Dom {f}\n  | Cod => ImageLRepres f\n  | LinearMap => ImageLModuleLeftHom f\n  | func-** => \\lam {_} {_} => exts (rewrite (func-** {f}) idp)\n}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Dom : BaseSet", "| G : Group", "| \\infixl 8 ** (E {G}) E : E", "\\func ImageLRepres \\hlevels  {R1 : Ring} {G1 : Group} {A B : LinRepres R1 G1} (f : InterwiningMap {G1} {R1} A B) :\nLinRepres R1 G1 (Image {E {f.Dom}} {E {f.Cod}} f.func) {\n  | zro => (zro {f.Cod}, inP {\\Sigma (a : E {f.Dom}) (f.func a = zro {f.Cod})} (zro {f.Dom}, f.func-zro))\n  | + => \\lam (a : E) (b : E) => (a.1 + b.1, \\case a.2, b.2 \\with {\n    | inP t, inP s => inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1 + b.1)} (t.1 + s.1,\n      f.func-+ {t.1} {s.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func t.1} {a.1} t.2 {f.func s.1} {b.1} s.2)\n  })\n  | negative => \\lam (a : E) => (negative {f.Cod} a.1,\n    map {\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)} {\\Sigma (a1 : E {f.Dom}) (f.func a1 = negative {f.Cod} a.1)} a.2\n      (\\lam (s : \\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)) =>\n        (negative {f.Dom} s.1, func-negative {f} {s.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func s.1} {a.1} s.2)))\n  | *c => \\lam (r : E {R}) (a : E) =>\n  (r B.*c a.1, map {\\Sigma (a1 : A.E) (f.func a1 = a.1)} {\\Sigma (a1 : A.E) (f.func a1 = r B.*c a.1)} a.2\n    (\\lam (s : \\Sigma (a1 : A.E) (f.func a1 = a.1)) =>\n      (r A.*c s.1, f.func-*c {r} {s.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func s.1} {a.1} s.2)))\n  | ** => \\lam (g : G.E) (e : E) => (g B.** e.1, map {\\Sigma (a : A.E) (f.func a = e.1)} {\\Sigma (a : A.E) (f.func a = g B.** e.1)} e.2\n    (\\lam (s : \\Sigma (a : A.E) (f.func a = e.1)) =>\n      (g A.** s.1, f.func-** {s.1} {g} *> pmap {B.E} {B.E} ((B.**) g) {f.func s.1} {e.1} s.2)))\n} => \\new LinRepres {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n  | **-ldistr => {?hidden}\n  | **-*c => {?hidden}\n}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Cod : BaseSet", "inP A", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| E : \\Set", "\\func ImageAddPointedLeftHom \\hlevels  (f : AddPointedHom) : AddPointedHom f.Dom (ImageAddPointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new AddPointedHom {\n  | func-zro => {?hidden}\n}", "\\func ImageLModuleLeftHom \\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LinearMap {R1} A (ImageLModule {R1} {A} {B} f) {\n  | func => \\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}"]}
{"Context": ["h1 : (\\lam (e : A.E) => B.zro B.+ x.func e) = x.func", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {zro {\\this} + x}) x.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : CRing", "h1 : (\\lam (e : A.E) => B.zro B.+ x.func e) = x.func", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {zro {\\this} + x})\n  x.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["G : Group", "h1 : (\\lam (e : A.E) => B.zro B.+ x.func e) = x.func", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {zro {\\this} + x})\n  x.func-**", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap ", "h1 : (\\lam (e : A.E) => x.func e B.+ B.zro) = x.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {x + zro {\\this}}) x.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "R : CRing", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap ", "h1 : (\\lam (e : A.E) => x.func e B.+ B.zro) = x.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {x + zro {\\this}})\n  x.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "G : Group", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap ", "h1 : (\\lam (e : A.E) => x.func e B.+ B.zro) = x.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {x + zro {\\this}})\n  x.func-**", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => x.func e B.+ y.func e B.+ z.func e) = (\\lam (e : A.E) => x.func e B.+ (y.func e B.+ z.func e))", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap ", "y : E {\\this}", "z : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {x + y + z})\n  (func-+ {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => x.func e B.+ y.func e B.+ z.func e) = (\\lam (e : A.E) => x.func e B.+ (y.func e B.+ z.func e))", "R : CRing", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap ", "y : E {\\this}", "z : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {x + y + z})\n  (func-*c {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => x.func e B.+ y.func e B.+ z.func e) = (\\lam (e : A.E) => x.func e B.+ (y.func e B.+ z.func e))", "G : Group", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap ", "y : E {\\this}", "z : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {x + y + z})\n  (func-** {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => B.negative (x.func e) B.+ x.func e) = (\\lam (_ : A.E) => B.zro)", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {negative {\\this} x + x})\n  (func-+ {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => B.negative (x.func e) B.+ x.func e) = (\\lam (_ : A.E) => B.zro)", "R : CRing", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x)\n  (func-*c {negative {\\this} x + x}) (func-*c {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => B.negative (x.func e) B.+ x.func e) = (\\lam (_ : A.E) => B.zro)", "G : Group", "x : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e)\n  (func-** {negative {\\this} x + x}) (func-** {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => x.func e B.+ y.func e) = (\\lam (e : A.E) => y.func e B.+ x.func e)", "x : E {\\this}", "y : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {x + y}) (func-+ {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => x.func e B.+ y.func e) = (\\lam (e : A.E) => y.func e B.+ x.func e)", "x : E {\\this}", "y : E {\\this}", "R : CRing", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {x + y})\n  (func-*c {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => x.func e B.+ y.func e) = (\\lam (e : A.E) => y.func e B.+ x.func e)", "x : E {\\this}", "G : Group", "y : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {x + y})\n  (func-** {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["r : E {R {\\this}}", "r' : E {R {\\this}}", "a : E {\\this}", "h1 : (\\lam (e : A.E) => r * r' B.*c a.func e) = (\\lam (e : A.E) => r B.*c (r' B.*c a.func e))", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {r * r' *c a})\n  (func-+ {r *c (r' *c a)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 7 * E E : E", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["r : E {R {\\this}}", "R : CRing", "r' : E {R {\\this}}", "a : E {\\this}", "h1 : (\\lam (e : A.E) => r * r' B.*c a.func e) = (\\lam (e : A.E) => r B.*c (r' B.*c a.func e))", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {r * r' *c a})\n  (func-*c {r *c (r' *c a)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["r : E {R {\\this}}", "G : Group", "r' : E {R {\\this}}", "a : E {\\this}", "h1 : (\\lam (e : A.E) => r * r' B.*c a.func e) = (\\lam (e : A.E) => r B.*c (r' B.*c a.func e))", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {r * r' *c a})\n  (func-** {r *c (r' *c a)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 7 * E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["r : E {R {\\this}}", "a : E {\\this}", "b : E {\\this}", "A : LinRepres R G", "h1 : (\\lam (e : A.E) => r B.*c (a.func e B.+ b.func e)) = (\\lam (e : A.E) => r B.*c a.func e B.+ r B.*c b.func e)", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {r *c (a + b)})\n  (func-+ {r *c a + r *c b})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : CRing", "r : E {R {\\this}}", "a : E {\\this}", "b : E {\\this}", "A : LinRepres R G", "h1 : (\\lam (e : A.E) => r B.*c (a.func e B.+ b.func e)) = (\\lam (e : A.E) => r B.*c a.func e B.+ r B.*c b.func e)", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {r *c (a + b)})\n  (func-*c {r *c a + r *c b})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["G : Group", "r : E {R {\\this}}", "a : E {\\this}", "b : E {\\this}", "A : LinRepres R G", "h1 : (\\lam (e : A.E) => r B.*c (a.func e B.+ b.func e)) = (\\lam (e : A.E) => r B.*c a.func e B.+ r B.*c b.func e)", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {r *c (a + b)})\n  (func-** {r *c a + r *c b})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : E {\\this}", "r : E {R {\\this}}", "s : E {R {\\this}}", "A : LinRepres R G", "h1 : (\\lam (e : A.E) => (r + s) B.*c a.func e) = (\\lam (e : A.E) => r B.*c a.func e B.+ s B.*c a.func e)", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {(r + s) *c a})\n  (func-+ {r *c a + s *c a})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["a : E {\\this}", "R : CRing", "r : E {R {\\this}}", "s : E {R {\\this}}", "A : LinRepres R G", "h1 : (\\lam (e : A.E) => (r + s) B.*c a.func e) = (\\lam (e : A.E) => r B.*c a.func e B.+ s B.*c a.func e)", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x) (func-*c {(r + s) *c a})\n  (func-*c {r *c a + s *c a})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["G : Group", "a : E {\\this}", "r : E {R {\\this}}", "s : E {R {\\this}}", "A : LinRepres R G", "h1 : (\\lam (e : A.E) => (r + s) B.*c a.func e) = (\\lam (e : A.E) => r B.*c a.func e B.+ s B.*c a.func e)", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e) (func-** {(r + s) *c a})\n  (func-** {r *c a + s *c a})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| \\infixl 6 + E E : E", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : A.E) => ide {B.R} B.*c a.func e) = a.func", "a : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y) (func-+ {ide {R {\\this}} *c a})\n  a.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["h1 : (\\lam (e : A.E) => ide {B.R} B.*c a.func e) = a.func", "R : CRing", "a : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : A.E} -> (@) h1 i (r A.*c x) = r B.*c (@) h1 i x)\n  (func-*c {ide {R {\\this}} *c a}) a.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["G : Group", "h1 : (\\lam (e : A.E) => ide {B.R} B.*c a.func e) = a.func", "a : E {\\this}", "A : LinRepres R G", "B : LinRepres R G", "this : LModule R (InterwiningMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {e : A.E} -> \\Pi {g : G.E} -> (@) h1 i (g A.** e) = g B.** (@) h1 i e)\n  (func-** {ide {R {\\this}} *c a}) a.func-**", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 ** (E {G}) E : E", "| R : Ring", "| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["v : Nat", "b : Bool", "p : \\Sigma Nat Bool", "e : (v, b) = p"], "Expected type": "(v, false) = (p.1, if {Bool} b (not p.2) p.2)", "Expression": "ext (pmap (\\lam p0 => p0.1) e, \\case \\elim b, \\elim e \\with {\n  | false, e => pmap (\\lam p0 => p0.2) e\n  | true, e => rewriteI (pmap (\\lam p0 => p0.2) e) idp\n})", "Premises": ["\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "false", "\\data Bool \\plevels  \\hlevels  \n  | false\n  | true", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func if {A : \\Type} (_ : Bool) (_ _ : A) : A \n  | {A}, true, then, else => then\n  | {A}, false, then, else => else", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "true", "\\func not \\plevels  \\hlevels  (_ : Bool) : Bool \n  | true => false\n  | false => true"]}
{"Context": ["v : Nat", "b : Bool", "p : \\Sigma Nat Bool", "q : Not ((v, false) = (p.1, if {Bool} b (not p.2) p.2))", "e : (v, b) = p"], "Expected type": "(\\case yes {(v, b) = p} e \\with {\n  | yes p => 1\n  | no n => 0\n}) = (\\case no {(v, false) = (p.1, if {Bool} b (not p.2) p.2)} q \\with {\n| yes p => 1\n| no n => 0\n})", "Expression": "\\case q $ ext (pmap (\\lam p0 => p0.1) e, \\case \\elim b, \\elim e \\with {\n  | false, e => pmap (\\lam p0 => p0.2) e\n  | true, e => rewriteI (pmap (\\lam p0 => p0.2) e) idp\n}) \\with {}", "Premises": ["yes E", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "no (Not E)", "false", "\\data Bool \\plevels  \\hlevels  \n  | false\n  | true", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func if {A : \\Type} (_ : Bool) (_ _ : A) : A \n  | {A}, true, then, else => then\n  | {A}, false, then, else => else", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "true", "\\func not \\plevels  \\hlevels  (_ : Bool) : Bool \n  | true => false\n  | false => true"]}
{"Context": ["v : Nat", "b : Bool", "e : (v, false) = (p.1, if {Bool} b (not p.2) p.2)", "p : \\Sigma Nat Bool"], "Expected type": "(v, b) = p", "Expression": "ext (pmap (\\lam p0 => p0.1) e, \\case \\elim b, \\elim e \\with {\n  | false, e => pmap (\\lam p0 => p0.2) e\n  | true, e => pmap (\\lam s => not s.2) e *> not-isInv\n})", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "false", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma not-isInv \\plevels  \\hlevels  {b : Bool} : not (not b) = b ", "true", "\\func not \\plevels  \\hlevels  (_ : Bool) : Bool \n  | true => false\n  | false => true"]}
{"Context": ["q : Not ((v, b) = p)", "v : Nat", "b : Bool", "e : (v, false) = (p.1, if {Bool} b (not p.2) p.2)", "p : \\Sigma Nat Bool"], "Expected type": "(\\case no {(v, b) = p} q \\with {\n  | yes p => 1\n  | no n => 0\n}) = (\\case yes {(v, false) = (p.1, if {Bool} b (not p.2) p.2)} e \\with {\n| yes p => 1\n| no n => 0\n})", "Expression": "\\case q $ ext (pmap (\\lam p0 => p0.1) e, \\case \\elim b, \\elim e \\with {\n  | false, e => pmap (\\lam p0 => p0.2) e\n  | true, e => pmap (\\lam s => not s.2) e *> not-isInv\n}) \\with {}", "Premises": ["yes E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "no (Not E)", "false", "\\data Bool \\plevels  \\hlevels  \n  | false\n  | true", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma not-isInv \\plevels  \\hlevels  {b : Bool} : not (not b) = b ", "\\func if {A : \\Type} (_ : Bool) (_ _ : A) : A \n  | {A}, true, then, else => then\n  | {A}, false, then, else => else", "true", "\\func not \\plevels  \\hlevels  (_ : Bool) : Bool \n  | true => false\n  | false => true"]}
{"Context": ["B : E", "A : E", "R : CRing", "n : Nat", "j : Fin m"], "Expected type": "BigSum {R} (\\new Array R.E n (\\lam (k : Fin n) => at {at {A} k} j R.* at {at {B} j} k)) = BigSum {R} (\\new Array R.E n (\\lam (j1 : Fin n) => at {at {B} j} j1 R.* at {at {A} j1} j))", "Expression": "BigSum-ext {R} {?}", "Premises": ["\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 * E E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma BigSum-ext \\hlevels  {this : AddMonoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigSum l = BigSum l' "]}
{"Context": ["m : Nat", "B : E", "A : E", "R : CRing", "n : Nat"], "Expected type": "BigSum {R}\n  (\\new Array R.E m (\\lam (j : Fin m) => BigSum {R} (\\new Array R.E n (\\lam (k : Fin n) => at {at {A} k} j R.* at {at {B} j} k)))) = BigSum {R}\n  (\\new Array R.E m (\\lam (i : Fin m) => BigSum {R} (\\new Array R.E n (\\lam (j : Fin n) => at {at {B} i} j R.* at {at {A} j} i))))", "Expression": "BigSum-ext {R} {?}", "Premises": ["\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 * E E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma BigSum-ext \\hlevels  {this : AddMonoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigSum l = BigSum l' "]}
{"Context": ["Y : Ob {\\this}", "x : E {\\this}", "h1 : (\\lam (e : X.E) => Y.zro Y.+ x.func e) = x.func", "this : AbGroup (Hom ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Y.+ (@) h1 i y) (func-+ {zro {\\this} + x}) x.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : Ring", "Y : Ob {\\this}", "x : E {\\this}", "h1 : (\\lam (e : X.E) => Y.zro Y.+ x.func e) = x.func", "this : AbGroup (Hom ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Y.*c (@) h1 i x) (func-*c {zro {\\this} + x})\n  x.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "Y : Ob {\\this}", "h1 : (\\lam (e : X.E) => x.func e Y.+ Y.zro) = x.func", "this : AbGroup (Hom ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Y.+ (@) h1 i y) (func-+ {x + zro {\\this}}) x.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "R : Ring", "Y : Ob {\\this}", "h1 : (\\lam (e : X.E) => x.func e Y.+ Y.zro) = x.func", "this : AbGroup (Hom ", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Y.*c (@) h1 i x) (func-*c {x + zro {\\this}})\n  x.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["z : E {\\this}", "Y : Ob {\\this}", "x : E {\\this}", "h1 : (\\lam (e : X.E) => x.func e Y.+ y.func e Y.+ z.func e) = (\\lam (e : X.E) => x.func e Y.+ (y.func e Y.+ z.func e))", "this : AbGroup (Hom ", "y : E {\\this}", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Y.+ (@) h1 i y) (func-+ {x + y + z})\n  (func-+ {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["z : E {\\this}", "R : Ring", "Y : Ob {\\this}", "x : E {\\this}", "h1 : (\\lam (e : X.E) => x.func e Y.+ y.func e Y.+ z.func e) = (\\lam (e : X.E) => x.func e Y.+ (y.func e Y.+ z.func e))", "this : AbGroup (Hom ", "y : E {\\this}", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Y.*c (@) h1 i x) (func-*c {x + y + z})\n  (func-*c {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "Y : Ob {\\this}", "this : AbGroup (Hom ", "h1 : (\\lam (e : X.E) => Y.negative (x.func e) Y.+ x.func e) = (\\lam (_ : X.E) => Y.zro)", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Y.+ (@) h1 i y) (func-+ {negative {\\this} x + x})\n  (func-+ {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "R : Ring", "Y : Ob {\\this}", "this : AbGroup (Hom ", "h1 : (\\lam (e : X.E) => Y.negative (x.func e) Y.+ x.func e) = (\\lam (_ : X.E) => Y.zro)", "X : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Y.*c (@) h1 i x)\n  (func-*c {negative {\\this} x + x}) (func-*c {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : E {\\this}", "Y : Ob {\\this}", "x : E {\\this}", "this : AbGroup (Hom ", "X : Ob {\\this}", "h1 : (\\lam (e : X.E) => x.func e Y.+ y.func e) = (\\lam (e : X.E) => y.func e Y.+ x.func e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Y.+ (@) h1 i y) (func-+ {x + y}) (func-+ {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : E {\\this}", "R : Ring", "Y : Ob {\\this}", "x : E {\\this}", "this : AbGroup (Hom ", "X : Ob {\\this}", "h1 : (\\lam (e : X.E) => x.func e Y.+ y.func e) = (\\lam (e : X.E) => y.func e Y.+ x.func e)"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Y.*c (@) h1 i x) (func-*c {x + y})\n  (func-*c {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["g : Hom {\\this} X Y", "Y : Ob {\\this}", "f : Hom {\\this} Y Z", "h1 : (\\lam (e : X.E) => f.func (g.func e + h.func e)) = (\\lam (e : X.E) => f.func (g.func e) + f.func (h.func e))", "this : PreAdditivePrecat (LModule R1) ", "h : Hom {\\this} X Y", "X : Ob {\\this}", "Z : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Z.+ (@) h1 i y) (func-+ {(g + h) >> f})\n  (func-+ {g >> f + h >> f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 8 >> \\plevels obj >= hom \\hlevels  {this : Precat} {x y z : Ob} (f : Hom x y) (g : Hom y z) : Hom x z => g \u2218 f"]}
{"Context": ["R : Ring", "g : Hom {\\this} X Y", "Y : Ob {\\this}", "f : Hom {\\this} Y Z", "h1 : (\\lam (e : X.E) => f.func (g.func e + h.func e)) = (\\lam (e : X.E) => f.func (g.func e) + f.func (h.func e))", "this : PreAdditivePrecat (LModule R1) ", "h : Hom {\\this} X Y", "X : Ob {\\this}", "Z : Ob {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Z.*c (@) h1 i x) (func-*c {(g + h) >> f})\n  (func-*c {g >> f + h >> f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 8 >> \\plevels obj >= hom \\hlevels  {this : Precat} {x y z : Ob} (f : Hom x y) (g : Hom y z) : Hom x z => g \u2218 f"]}
{"Context": ["g : Hom {\\this} Y Z", "h1 : func {f >> (g + h)} = func {f >> (g + h)}", "Z : Ob {\\this}", "f : Hom {\\this} X Y", "this : PreAdditivePrecat (LModule R1) ", "Y : Ob {\\this}", "X : Ob {\\this}", "h : Hom {\\this} Y Z"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X.E} -> (@) h1 i (x X.+ y) = (@) h1 i x Z.+ (@) h1 i y) (func-+ {f >> (g + h)})\n  (func-+ {f >> g + f >> h})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 8 >> \\plevels obj >= hom \\hlevels  {this : Precat} {x y z : Ob} (f : Hom x y) (g : Hom y z) : Hom x z => g \u2218 f"]}
{"Context": ["g : Hom {\\this} Y Z", "R : Ring", "h1 : func {f >> (g + h)} = func {f >> (g + h)}", "Z : Ob {\\this}", "f : Hom {\\this} X Y", "this : PreAdditivePrecat (LModule R1) ", "Y : Ob {\\this}", "X : Ob {\\this}", "h : Hom {\\this} Y Z"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : X.E} -> (@) h1 i (r X.*c x) = r Z.*c (@) h1 i x) (func-*c {f >> (g + h)})\n  (func-*c {f >> g + f >> h})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func \\infixl 8 >> \\plevels obj >= hom \\hlevels  {this : Precat} {x y z : Ob} (f : Hom x y) (g : Hom y z) : Hom x z => g \u2218 f"]}
{"Context": ["f : LinearMap ", "r' : E {R {\\this}}", "arg : r * r' A.*c a.1 = r A.*c (r' A.*c a.1)", "a : E {\\this}", "r : E {R {\\this}}", "this : LModule R1 (Kernel f) "], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (r * r' *c a).2 (r *c (r' *c a)).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| \\infixl 7 *c (E {R}) E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["f : LinearMap ", "a : E {\\this}", "arg : r A.*c (a.1 A.+ b.1) = r A.*c a.1 A.+ r A.*c b.1", "b : E {\\this}", "r : E {R {\\this}}", "this : LModule R1 (Kernel f) "], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (r *c (a + b)).2 (r *c a + r *c b).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["f : LinearMap ", "arg : (r + s) A.*c a.1 = r A.*c a.1 A.+ s A.*c a.1", "s : E {R {\\this}}", "this : LModule R1 (Kernel f) ", "a : E {\\this}", "r : E {R {\\this}}"], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) ((r + s) *c a).2 (r *c a + s *c a).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["f : LinearMap ", "a : E {\\this}", "arg : ide {A.R} A.*c a.1 = a.1", "this : LModule R1 (Kernel f) "], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) (ide {R {\\this}} *c a).2 a.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E", "| ide : E"]}
{"Context": ["r : E {R {\\this}}", "arg : r * r' B.*c a.1 = r B.*c (r' B.*c a.1)", "r' : E {R {\\this}}", "a : E {\\this}", "f : LinearMap ", "this : LModule R1 (Image "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (r * r' *c a).2 (r *c (r' *c a)).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 * E E : E", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : r B.*c (a.1 B.+ b.1) = r B.*c a.1 B.+ r B.*c b.1", "r : E {R {\\this}}", "b : E {\\this}", "f : LinearMap ", "this : LModule R1 (Image ", "a : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (r *c (a + b)).2 (r *c a + r *c b).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["arg : (r + s) B.*c a.1 = r B.*c a.1 B.+ s B.*c a.1", "a : E {\\this}", "f : LinearMap ", "this : LModule R1 (Image ", "s : E {R {\\this}}", "r : E {R {\\this}}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) ((r + s) *c a).2 (r *c a + s *c a).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : LinearMap ", "this : LModule R1 (Image ", "arg : ide {B.R} B.*c a.1 = a.1", "a : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (ide {R {\\this}} *c a).2 a.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["r : E {R {\\this}}", "x : E {Dom {\\this}}", "f : LinearMap ", "arg : f.func (r *c x) = r *c f.func x", "this : LinearMap "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {\\this} (r *c x)).2 (r *c func {\\this} x).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["B : LModule R", "f : LinearMap ", "R : Ring", "A : LModule R"], "Expected type": "LinearMap {R1} A (ImageLModule {R1} {A} {B} f) {\n  | func => \\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "Expression": "\\new LinearMap {\n  | R => _\n  | Dom => A\n  | Cod => ImageLModule f\n  | AddGroupHom => ImageAddGroupLeftHom f\n  | func-*c => ext func-*c\n}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Dom : BaseSet", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| Cod : BaseSet", "\\func ImageAddGroupLeftHom \\hlevels  (f : AddGroupHom) : AddGroupHom f.Dom (ImageAddGroup f) {\n  | func => \\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new AddGroupHom {\n  | func-+ => {?hidden}\n}", "inP A", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| E : \\Set", "\\func ImageAddPointedLeftHom \\hlevels  (f : AddPointedHom) : AddPointedHom f.Dom (ImageAddPointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new AddPointedHom {\n  | func-zro => {?hidden}\n}"]}
{"Context": ["h1 : (\\lam (e : U.E) => U.zro U.+ x.func e) = x.func", "x : E {\\this}", "U : LModule R", "this : Ring (LinearMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {zro {\\this} + x}) x.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : U.E) => U.zro U.+ x.func e) = x.func", "x : E {\\this}", "U : LModule R", "this : Ring (LinearMap ", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x) (func-*c {zro {\\this} + x})\n  x.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "U : LModule R", "this : Ring (LinearMap ", "y : E {\\this}", "z : E {\\this}", "h1 : (\\lam (e : U.E) => x.func e U.+ y.func e U.+ z.func e) = (\\lam (e : U.E) => x.func e U.+ (y.func e U.+ z.func e))"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {x + y + z})\n  (func-+ {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "U : LModule R", "this : Ring (LinearMap ", "R : Ring", "y : E {\\this}", "z : E {\\this}", "h1 : (\\lam (e : U.E) => x.func e U.+ y.func e U.+ z.func e) = (\\lam (e : U.E) => x.func e U.+ (y.func e U.+ z.func e))"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x) (func-*c {x + y + z})\n  (func-*c {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "h1 : (\\lam (e : U.E) => x.func e U.+ y.func e) = (\\lam (e : U.E) => y.func e U.+ x.func e)", "U : LModule R", "this : Ring (LinearMap ", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {x + y}) (func-+ {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "h1 : (\\lam (e : U.E) => x.func e U.+ y.func e) = (\\lam (e : U.E) => y.func e U.+ x.func e)", "U : LModule R", "this : Ring (LinearMap ", "R : Ring", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x) (func-*c {x + y})\n  (func-*c {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["U : LModule R", "this : Ring (LinearMap ", "h1 : (\\lam (e : U.E) => U.negative (x.func e) U.+ x.func e) = (\\lam (_ : U.E) => U.zro)", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {negative {\\this} x + x})\n  (func-+ {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["U : LModule R", "this : Ring (LinearMap ", "R : Ring", "h1 : (\\lam (e : U.E) => U.negative (x.func e) U.+ x.func e) = (\\lam (_ : U.E) => U.zro)", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x)\n  (func-*c {negative {\\this} x + x}) (func-*c {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : E {\\this}", "U : LModule R", "this : Ring (LinearMap ", "x : E {\\this}", "z : E {\\this}", "h1 : (\\lam (e : U.E) => z.func (x.func e + y.func e)) = (\\lam (e : U.E) => z.func (x.func e) + z.func (y.func e))"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {(x + y) * z})\n  (func-+ {x * z + y * z})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["y : E {\\this}", "U : LModule R", "this : Ring (LinearMap ", "R : Ring", "x : E {\\this}", "z : E {\\this}", "h1 : (\\lam (e : U.E) => z.func (x.func e + y.func e)) = (\\lam (e : U.E) => z.func (x.func e) + z.func (y.func e))"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x) (func-*c {(x + y) * z})\n  (func-*c {x * z + y * z})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (U.*c) (x + y) = (\\lam (e : U.E) => x U.*c e U.+ y U.*c e)", "this : RingHom R1 (LinearMapRing ", "y : E {Dom {\\this}}", "U : LModule R", "x : E {Dom {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {func {\\this} (x + y)})\n  (func-+ {func {\\this} x + func {\\this} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : CRing", "h1 : (U.*c) (x + y) = (\\lam (e : U.E) => x U.*c e U.+ y U.*c e)", "this : RingHom R1 (LinearMapRing ", "y : E {Dom {\\this}}", "U : LModule R", "x : E {Dom {\\this}}"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x)\n  (func-*c {func {\\this} (x + y)}) (func-*c {func {\\this} x + func {\\this} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (U.*c) (ide {U.R}) = (\\lam (e : U.E) => e)", "this : RingHom R1 (LinearMapRing ", "U : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y)\n  (func-+ {func {\\this} (ide {Dom {\\this}})}) (func-+ {ide {Cod {\\this}}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["h1 : (U.*c) (ide {U.R}) = (\\lam (e : U.E) => e)", "R : CRing", "this : RingHom R1 (LinearMapRing ", "U : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x)\n  (func-*c {func {\\this} (ide {Dom {\\this}})}) (func-*c {ide {Cod {\\this}}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| \\infixl 7 *c (E {R}) E : E", "| Cod : BaseSet", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["x : E {Dom {\\this}}", "h1 : func {func {\\this} (x R.* y)} = func {func {\\this} x * func {\\this} y}", "this : RingHom R1 (LinearMapRing ", "y : E {Dom {\\this}}", "U : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {func {\\this} (x * y)})\n  (func-+ {func {\\this} x * func {\\this} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {Dom {\\this}}", "h1 : func {func {\\this} (x R.* y)} = func {func {\\this} x * func {\\this} y}", "R : CRing", "this : RingHom R1 (LinearMapRing ", "y : E {Dom {\\this}}", "U : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x)\n  (func-*c {func {\\this} (x * y)}) (func-*c {func {\\this} x * func {\\this} y})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e1 : U.E) => e.ret (e.f e1)) = (\\lam (e : U.E) => e)", "R : Ring", "this : Iso "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : E {dom {\\this}}} -> (@) h1 i (r *c x) = r *c (@) h1 i x)\n  (func-*c {hinv {\\this} \u2218 f {\\this}}) (func-*c {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 7 *c (E {R}) E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e1 : V.E) => e.f (e.ret e1)) = (\\lam (e : V.E) => e)", "this : Iso "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {cod {\\this}}} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {f {\\this} \u2218 hinv {\\this}}) (func-+ {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : Ring", "h1 : (\\lam (e1 : V.E) => e.f (e.ret e1)) = (\\lam (e : V.E) => e)", "this : Iso "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : E {cod {\\this}}} -> (@) h1 i (r *c x) = r *c (@) h1 i x)\n  (func-*c {f {\\this} \u2218 hinv {\\this}}) (func-*c {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 7 *c (E {R}) E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| C : Precat", "| f : Hom {C} dom cod", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["N : LModule R", "M : LModule R", "arg : a.1 = M.zro", "a : E", "R : Ring", "f : LinearMap "], "Expected type": "Path (\\lam (i : I) => f.func (arg @ i) = zro {f.Cod}) a.2 zro.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["V : LModule R", "l : Array U.E", "U : LModule R", "v : V.E", "lb : IsBasis {U} l", "R : Ring", "f : Iso "], "Expected type": "TruncP (\\Sigma (c : Array R.E l.len) (v = BigSum {V} (\\new Array V.E l.len (\\lam (i : Fin l.len) => c.at i V.*c func {f.f} (l.at i)))))", "Expression": "map {?} (\\lam s => (s.1,\n  (iso<->inj+surj.1 (reverse {f})).1 $ s.2 *> pmap BigSum (exts (\\lam j => inv $ func-*c *> path (\\lam i => _ *c hinv_f {f} i (l j)))) *> inv func-BigSum))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "| hinv_f : hinv \u2218 f = id {C} dom", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| \\infixl 7 *c (E {R}) E : E", "\\func reverse \\plevels obj >= hom \\hlevels  {this : Iso} : Iso {C} {cod} {dom} hinv {\n  | hinv => f\n} => \\new Iso {\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\lemma iso<->inj+surj {R : Ring} {U V : LModule R} {f : LinearMap {R} U V} :\n  Iso {LModuleCat R} {U} {V} f <-> (\\Sigma (IsInj {U.E} {V.E} f.func) (IsSurj {U.E} {V.E} f.func)) ", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| hinv : Hom {C} cod dom", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| E : \\Set", "| f : Hom {C} dom cod", "\\lemma func-BigSum \\hlevels  {this : AddMonoidHom} {l : Array (E {Dom})} :\n  func (BigSum {Dom} l) = BigSum {Cod} (\\new Array (E {Cod}) l.len (\\lam (j : Fin l.len) => func (l.at j))) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["U : LModule R", "lv : Array V.E", "lw : Array W.E", "W : LModule R", "h1 : (\\lam (e : U.E) => BigSum {W} (\\new Array W.E lv.len (\\lam (j : Fin lv.len) =>\n  at {basis-split {V} {lv} bv (func {f.f} e)} j W.*c BigSum {W} (\\new Array W.E lw.len (\\lam (j1 : Fin lw.len) => at {at {A} j} j1 W.*c lw.at j1))))) = (\\lam (e : U.E) => BigSum {W} (\\new Array W.E lv.len (\\lam (j : Fin lv.len) =>\n  at {basis-split {U} {map {V.E} {U.E} (func {f.hinv}) lv} (iso-basis {R} {V} {U} (reverse {f1}) {lv} bv) e} j W.*c BigSum {W} (\\new Array W.E lw.len (\\lam (j1 : Fin lw.len) => at {at {A} j} j1 W.*c lw.at j1)))))", "R : Ring", "bv : IsBasis {V} lv", "f : Iso ", "A : Matrix R.E lv.len lw.len", "V : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x W.+ (@) h1 i y)\n  (func-+ {toLinearMap {R} {V} {W} {lv} bv lw A \u2218 f.f})\n  (func-+ {toLinearMap {R} {U} {W} {map {V.E} {U.E} (func {f.hinv}) lv} (iso-basis {R} {V} {U} (reverse {f1}) {lv} bv) lw A})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func reverse \\plevels obj >= hom \\hlevels  {this : Iso} : Iso {C} {cod} {dom} hinv {\n  | hinv => f\n} => \\new Iso {\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "\\func toLinearMap \\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\nLinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n} => extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))", "| func (E {Dom}) : E {Cod}", "\\lemma iso-basis {R : Ring} {U V : LModule R} (f1 : Iso {LModuleCat R} {U} {V}) {l : Array U.E} (_ : IsBasis {U} l) :\n  IsBasis {V} (map {U.E} {V.E} (func {f.f}) l) ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "| hinv : Hom {C} cod dom", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod"]}
{"Context": ["U : LModule R", "lv : Array V.E", "lw : Array W.E", "W : LModule R", "h1 : (\\lam (e : U.E) => BigSum {W} (\\new Array W.E lv.len (\\lam (j : Fin lv.len) =>\n  at {basis-split {V} {lv} bv (func {f.f} e)} j W.*c BigSum {W} (\\new Array W.E lw.len (\\lam (j1 : Fin lw.len) => at {at {A} j} j1 W.*c lw.at j1))))) = (\\lam (e : U.E) => BigSum {W} (\\new Array W.E lv.len (\\lam (j : Fin lv.len) =>\n  at {basis-split {U} {map {V.E} {U.E} (func {f.hinv}) lv} (iso-basis {R} {V} {U} (reverse {f1}) {lv} bv) e} j W.*c BigSum {W} (\\new Array W.E lw.len (\\lam (j1 : Fin lw.len) => at {at {A} j} j1 W.*c lw.at j1)))))", "R : Ring", "bv : IsBasis {V} lv", "f : Iso ", "A : Matrix R.E lv.len lw.len", "V : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r W.*c (@) h1 i x)\n  (func-*c {toLinearMap {R} {V} {W} {lv} bv lw A \u2218 f.f})\n  (func-*c {toLinearMap {R} {U} {W} {map {V.E} {U.E} (func {f.hinv}) lv} (iso-basis {R} {V} {U} (reverse {f1}) {lv} bv) lw A})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 *c (E {R}) E : E", "\\func reverse \\plevels obj >= hom \\hlevels  {this : Iso} : Iso {C} {cod} {dom} hinv {\n  | hinv => f\n} => \\new Iso {\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "\\func toLinearMap \\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\nLinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n} => extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))", "| func (E {Dom}) : E {Cod}", "\\lemma iso-basis {R : Ring} {U V : LModule R} (f1 : Iso {LModuleCat R} {U} {V}) {l : Array U.E} (_ : IsBasis {U} l) :\n  IsBasis {V} (map {U.E} {V.E} (func {f.f}) l) ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| hinv : Hom {C} cod dom", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| f : Hom {C} dom cod"]}
{"Context": ["lu : Array U.E n", "lv : Array V.E n", "U : LModule R", "V : LModule R", "bu : IsBasis {U} lu", "R : Ring"], "Expected type": "LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {basis-split {U} {lu} bu x} j V.*c lv.at j))\n}", "Expression": "extend bu lv", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["lu : Array U.E n", "bv : IsBasis {V} lv", "lv : Array V.E n", "V : LModule R", "U : LModule R", "R : Ring"], "Expected type": "LinearMap {R} V U {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {U} (\\new Array U.E lv.len (\\lam (j : Fin lv.len) => at {basis-split {V} {lv} bv x} j U.*c lu.at j))\n}", "Expression": "extend bv lu", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["lu : Array U.E n", "lv : Array V.E n", "j : Fin lu.len", "U : LModule R", "V : LModule R", "bu : IsBasis {U} lu", "R : Ring"], "Expected type": "func {extend {R} {U} {V} {lu} bu lv} (lu.at j) = lv.at j", "Expression": "extend-char bu lv j", "Premises": ["\\lemma extend-char \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) (j : Fin l.len) :\n  func {extend {R} {U} {V} {l} lb lv} (l.at j) = lv.at j ", "| func (E {Dom}) : E {Cod}", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}"]}
{"Context": ["lu : Array U.E n", "bv : IsBasis {V} lv", "lv : Array V.E n", "j : Fin lu.len", "V : LModule R", "U : LModule R", "R : Ring"], "Expected type": "func {extend {R} {V} {U} {lv} bv lu} (lv.at j) = lu.at j", "Expression": "extend-char bv lu j", "Premises": ["\\lemma extend-char \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) (j : Fin l.len) :\n  func {extend {R} {U} {V} {l} lb lv} (l.at j) = lv.at j ", "| func (E {Dom}) : E {Cod}", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}"]}
{"Context": ["lu : Array U.E n", "bv : IsBasis {V} lv", "lv : Array V.E n", "U : LModule R", "V : LModule R", "bu : IsBasis {U} lu", "R : Ring"], "Expected type": "\\Pi (u : U.E) -> func {extend {R} {V} {U} {lv} bv lu \u2218 extend {R} {U} {V} {lu} bu lv} u = func {id {R} {U}} u", "Expression": "basis-ext {?} id {?} {?}", "Premises": ["\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma basis-ext \\hlevels  {R : Ring} {U V : LModule R} (f g : LinearMap {R} U V) {l : Array U.E} (_ : IsGenerated {U} l)\n  (_ : \\Pi (j : Fin l.len) -> f.func (l.at j) = g.func (l.at j)) (u : U.E) : f.func u = g.func u "]}
{"Context": ["lu : Array U.E n", "bv : IsBasis {V} lv", "lv : Array V.E n", "V : LModule R", "U : LModule R", "bu : IsBasis {U} lu", "R : Ring"], "Expected type": "\\Pi (u : V.E) -> func {extend {R} {U} {V} {lu} bu lv \u2218 extend {R} {V} {U} {lv} bv lu} u = func {id {R} {V}} u", "Expression": "basis-ext {?} id {?} {?}", "Premises": ["\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma basis-ext \\hlevels  {R : Ring} {U V : LModule R} (f g : LinearMap {R} U V) {l : Array U.E} (_ : IsGenerated {U} l)\n  (_ : \\Pi (j : Fin l.len) -> f.func (l.at j) = g.func (l.at j)) (u : U.E) : f.func u = g.func u "]}
{"Context": ["bu' : IsBasis {U} lu'", "R : Ring", "lu : Array U.E n", "U : LModule R", "lu' : Array U.E n"], "Expected type": "LinearMap {R} U U {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {U} (\\new Array U.E lu'.len (\\lam (j : Fin lu'.len) => at {basis-split {U} {lu'} bu' x} j U.*c lu.at j))\n}", "Expression": "extend bu' lu", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["bu' : IsBasis {U} lu'", "f : LinearMap ", "R : Ring", "lu : Array U.E n", "lv : Array V.E", "V : LModule R", "bu : IsBasis {U} lu", "U : LModule R", "bv : IsBasis {V} lv", "lu' : Array U.E n"], "Expected type": "toLinearMap {R} {U} {V} {lu} bu lv\n  (toMatrix {R} {U} {U} {lu} lu bu (extend {R} {U} {U} {lu'} bu' lu) product toMatrix {R} {U} {V} {lv} lu' bv f) = toLinearMap {R} {U} {V} {lu'} bu' lv (toMatrix {R} {U} {V} {lv} lu' bv f) \u2218 toLinearMap {R} {U} {U} {lu} bu lu' (toMatrix {R} {U} {U} {lu} lu bu (extend {R} {U} {U} {lu'} bu' lu))", "Expression": "toLinearMap_* (toMatrix lu bu (extend bu' lu)) (toMatrix lu' bv f) bu bu' bv", "Premises": ["\\func \\infixl 7 product \\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\n  (\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\new Array R.E m (\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))", "\\func toLinearMap \\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\nLinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n} => extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))", "\\lemma toLinearMap_* \\hlevels  {R : Ring} {U V W : LModule R} {lu : Array U.E} {lv : Array V.E} {lw : Array W.E} (A : Matrix R.E lu.len lv.len)\n  (B : Matrix R.E lv.len lw.len) (bu : IsBasis {U} lu) (bv : IsBasis {V} lv) (_ : IsBasis {W} lw) :\n  toLinearMap {R} {U} {W} {lu} bu lw (A product B) = toLinearMap {R} {V} {W} {lv} bv lw B \u2218 toLinearMap {R} {U} {V} {lu} bu lv A ", "\\func toMatrix \\hlevels  {R : Ring} {U V : LModule R} {lv : Array V.E} (lu : Array U.E) (bv : IsBasis {V} lv) (f : LinearMap {R} U V) :\n  Matrix R.E lu.len lv.len \n  => mkMatrix {R.E} {lu.len} {lv.len} (\\lam (i : Fin lu.len) => at {basis-split {V} {lv} bv (f.func (lu.at i))})", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}"]}
{"Context": ["V : LModule R", "bv : IsBasis {V} lv", "R : Ring", "lv : Array V.E n", "lv' : Array V.E n"], "Expected type": "LinearMap {R} V V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E lv.len (\\lam (j : Fin lv.len) => at {basis-split {V} {lv} bv x} j V.*c lv'.at j))\n}", "Expression": "extend bv lv'", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["V : LModule R", "bv' : IsBasis {V} lv'", "bv : IsBasis {V} lv", "U : LModule R", "f : LinearMap ", "lu : Array U.E", "R : Ring", "lv : Array V.E n", "lv' : Array V.E n", "bu : IsBasis {U} lu"], "Expected type": "toLinearMap {R} {U} {V} {lu} bu lv\n  (toMatrix {R} {U} {V} {lv'} lu bv' f product toMatrix {R} {V} {V} {lv} lv bv (extend {R} {V} {V} {lv} bv lv')) = toLinearMap {R} {V} {V} {lv'} bv' lv (toMatrix {R} {V} {V} {lv} lv bv (extend {R} {V} {V} {lv} bv lv')) \u2218 toLinearMap {R} {U} {V} {lu} bu lv' (toMatrix {R} {U} {V} {lv'} lu bv' f)", "Expression": "toLinearMap_* (toMatrix lu bv' f) (toMatrix lv bv (extend bv lv')) bu bv' bv", "Premises": ["\\func \\infixl 7 product \\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\n  (\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\new Array R.E m (\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))", "\\func toLinearMap \\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\nLinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n} => extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))", "\\lemma toLinearMap_* \\hlevels  {R : Ring} {U V W : LModule R} {lu : Array U.E} {lv : Array V.E} {lw : Array W.E} (A : Matrix R.E lu.len lv.len)\n  (B : Matrix R.E lv.len lw.len) (bu : IsBasis {U} lu) (bv : IsBasis {V} lv) (_ : IsBasis {W} lw) :\n  toLinearMap {R} {U} {W} {lu} bu lw (A product B) = toLinearMap {R} {V} {W} {lv} bv lw B \u2218 toLinearMap {R} {U} {V} {lu} bu lv A ", "\\func toMatrix \\hlevels  {R : Ring} {U V : LModule R} {lv : Array V.E} (lu : Array U.E) (bv : IsBasis {V} lv) (f : LinearMap {R} U V) :\n  Matrix R.E lu.len lv.len \n  => mkMatrix {R.E} {lu.len} {lv.len} (\\lam (i : Fin lu.len) => at {basis-split {V} {lv} bv (f.func (lu.at i))})", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}"]}
{"Context": ["V : LModule R", "lv : Array V.E m", "bv' : IsBasis {V} lv'", "R : Ring", "lv' : Array V.E m"], "Expected type": "LinearMap {R} V V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E lv'.len (\\lam (j : Fin lv'.len) => at {basis-split {V} {lv'} bv' x} j V.*c lv.at j))\n}", "Expression": "extend bv' lv", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["M : LModule R", "x : E {\\this}", "h1 : x.contains = y.contains", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i M.zro) x.contains_zro y.contains_zro", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| contains_zro : contains (zro {S})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["M : LModule R", "x : E {\\this}", "h1 : x.contains = y.contains", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : M.E} -> (@) h1 i x -> (@) h1 i y -> (@) h1 i (x M.+ y)) x.contains_+ y.contains_+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)"]}
{"Context": ["M : LModule R", "x : E {\\this}", "h1 : x.contains = y.contains", "y : E {\\this}"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : M.E} -> (@) h1 i x -> (@) h1 i (M.negative x)) x.contains_negative y.contains_negative", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set"]}
{"Context": ["M : LModule R", "x : E {\\this}", "h1 : x.contains = y.contains", "y : E {\\this}", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {a : R.E} -> \\Pi {b : M.E} -> (@) h1 i b -> (@) h1 i (a M.*c b)) x.contains_*c y.contains_*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 *c (E {R}) E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| contains_*c {a : E {R}} {b : E {S}} (contains b) : contains (a *c b)"]}
{"Context": ["I : LIdeal R", "M : LModule R", "x : E {S {\\this}}", "R : Ring", "s : \\Sigma (l : Array (\\Sigma (x : R.E) (I.contains x) M.E))\n  (x = BigSum {M} (map {\\Sigma (x : R.E) (I.contains x) M.E} {M.E} (\\lam (s : \\Sigma (x : R.E) (I.contains x) M.E) => s.1 M.*c s.3) l))"], "Expected type": "TruncP (\\Sigma (l : Array (\\Sigma (x : R.E) (I.contains x) M.E))\n  (M.negative x = BigSum {M} (map {\\Sigma (x : R.E) (I.contains x) M.E} {M.E} (\\lam (s : \\Sigma (x : R.E) (I.contains x) M.E) => s.1 M.*c s.3) l)))", "Expression": "inP (map (later (\\lam t => (negative t.1, contains_negative t.2, t.3))) s.1,\n  pmap negative s.2 *> BigSum_negative {M} *> pmap (BigSum {M}) (exts (\\lam _ => inv (*c_negative-left {M}))))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| contains (E {S}) : \\Prop", "| \\infixl 7 *c (E {R}) E : E", "\\lemma BigSum_negative \\hlevels  {this : AbGroup} {l : Array E} : negative (BigSum l) = BigSum (map {E} {E} negative l) ", "| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)", "| negative E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\lemma *c_negative-left \\hlevels  {this : LModule} {r : E {R}} {a : E} : negative {R} r *c a = negative (r *c a) ", "inP A", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["I : LIdeal R", "M : LModule R", "s : \\Sigma (l : Array (\\Sigma (x : R.E) (I.contains x) M.E))\n  (e = BigSum {M} (map {\\Sigma (x : R.E) (I.contains x) M.E} {M.E} (\\lam (s : \\Sigma (x : R.E) (I.contains x) M.E) => s.1 M.*c s.3) l))", "R : Ring", "a : E {R {\\this}}", "_ : E {S {\\this}}"], "Expected type": "TruncP (\\Sigma (l : Array (\\Sigma (x : R.E) (I.contains x) M.E))\n  (a M.*c e = BigSum {M} (map {\\Sigma (x : R.E) (I.contains x) M.E} {M.E} (\\lam (s : \\Sigma (x : R.E) (I.contains x) M.E) => s.1 M.*c s.3) l)))", "Expression": "inP (map (later (\\lam t => (a * t.1, ideal-left t.2, t.3))) s.1,\n  pmap ((*c) a) s.2 *> *c_BigSum-ldistr {M} *> pmap (BigSum {M}) (exts (\\lam _ => inv (*c-assoc {M}))))", "Premises": ["\\lemma *c_BigSum-ldistr \\hlevels  {this : LModule} {r : E {R}} {l : Array E} :\n  r *c BigSum l = BigSum (\\new Array E l.len (\\lam (i : Fin l.len) => r *c l.at i)) ", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| contains (E {S}) : \\Prop", "| \\infixl 7 *c (E {R}) E : E", "| ideal-left {r a : E {S}} (contains a) : contains (r * a)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["l : Array F.E", "R : Ring", "lb : IsBasis {F} l", "U : LModule R", "F : FinModule R", "s : \\Pi (i : Fin l.len) -> \\Sigma (x : U.E) (g.func x = f.func (l.at i))"], "Expected type": "LinearMap {R} F U {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {U} (\\new Array U.E l.len (\\lam (j : Fin l.len) => at {basis-split {F} {l} lb x} j U.*c (s j).1))\n}", "Expression": "extend lb {?}", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["l : Array F.E", "f : LinearMap ", "R : Ring", "V : LModule R", "lb : IsBasis {F} l", "U : LModule R", "h : LinearMap ", "s : \\Pi (i : Fin l.len) -> \\Sigma (x : U.E) (g.func x = f.func (l.at i))", "F : FinModule R", "g : LinearMap "], "Expected type": "\\Pi (u : F.E) -> func {g \u2218 h} u = f.func u", "Expression": "basis-ext {?} f {?} {?}", "Premises": ["| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| E : \\Set", "\\lemma basis-ext \\hlevels  {R : Ring} {U V : LModule R} (f g : LinearMap {R} U V) {l : Array U.E} (_ : IsGenerated {U} l)\n  (_ : \\Pi (j : Fin l.len) -> f.func (l.at j) = g.func (l.at j)) (u : U.E) : f.func u = g.func u "]}
{"Context": ["f : LinearMap ", "h1 : (\\lam (e : U.E) => g.func (f.func e)) = (\\lam (e : U.E) => e)", "g : LinearMap ", "l' : Array U.E", "U : LModule R", "R : NonZeroCRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x U.+ (@) h1 i y) (func-+ {g \u2218 f})\n  (func-+ {id {R} {U}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : LinearMap ", "h1 : (\\lam (e : U.E) => g.func (f.func e)) = (\\lam (e : U.E) => e)", "g : LinearMap ", "l' : Array U.E", "R : NonZeroCRing", "U : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x) (func-*c {g \u2218 f})\n  (func-*c {id {R} {U}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : V.E) => g.func (h.func e)) = (\\lam (e : V.E) => e)", "g : LinearMap ", "V : LModule R", "R : CRing", "U : LModule R", "h : LinearMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : V.E} -> (@) h1 i (x V.+ y) = (@) h1 i x V.+ (@) h1 i y) (func-+ {g \u2218 h})\n  (func-+ {id {R} {V}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : V.E) => g.func (h.func e)) = (\\lam (e : V.E) => e)", "g : LinearMap ", "V : LModule R", "R : CRing", "U : LModule R", "h : LinearMap "], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : V.E} -> (@) h1 i (r V.*c x) = r V.*c (@) h1 i x) (func-*c {g \u2218 h})\n  (func-*c {id {R} {V}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : Ring", "n : Nat", "x : E"], "Expected type": "TruncP (\\Sigma (c : Array (E {R}) (len {ide {R1} {n}})) (x = BigSum {ArrayLModule {R1} n (RingLModule R1)}\n  (\\new Array E (len {ide {R1} {n}}) (\\lam (i : Fin (len {ide {R1} {n}})) => c.at i *c at {ide {R1} {n}} i))))", "Expression": "inP (x,\n  exts (\\lam j => inv $ BigSum-index *> BigSum-unique {R} j (\\lam k j/=k => later $ rewrite (decideEq/=_reduce $ /=-sym j/=k) (zro_*-right {R})) *> rewrite (decideEq=_reduce idp) ide-right))", "Premises": ["| R : Ring", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\lemma BigSum-index \\hlevels  {R : Ring} {n : Nat} {M : LModule R} {l : Array (Array M.E n)} {i : Fin n} :\n  at {BigSum {ArrayLModule {R} n M} l} i = BigSum {M} (map {Array M.E n} {M.E} (\\lam (p0 : Array M.E n) => p0.at i) l) ", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| ide-right {x : E} : x * ide = x", "| E : \\Set", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "\\field decideEq (x y : E) : Dec (x = y)", "| \\infixl 7 *c (E {R}) E : E", "\\lemma decideEq/=_reduce \\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ", "\\lemma decideEq=_reduce \\hlevels  {A : DecSet} {x y : A.E} (p : x = y) : A.decideEq x y = yes {x = y} p ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func ide {R : Ring} {n : Nat} : Matrix R.E n n => diagonal {R} (replicate {R.E} n R.ide)", "\\lemma /=-sym {A : \\Type} {a a' : A} (_ : a /= a') : a' /= a ", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "inP A", "\\func RingLModule \\hlevels  (R1 : Ring) : LModule R1 R.E {\n  | zro => R.zro\n  | + => (R.+)\n  | negative => R.negative\n  | *c => (R.*)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "\\lemma BigSum-unique \\hlevels  {this : AddMonoid} {l : Array E} (i : Fin l.len) (_ : \\Pi (j : Fin l.len) -> i /= j -> l.at j = zro) : BigSum l = l.at i ", "| ide : E", "| zro_*-right {x : E} : x * zro = zro"]}
{"Context": ["A : Matrix R.E lu.len lv.len", "V : LModule R", "R : Ring", "lu : Array U.E", "bu : IsBasis {U} lu", "U : LModule R", "lv : Array V.E"], "Expected type": "LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n}", "Expression": "extend bu {?}", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\func product-gen \\hlevels  {R : Ring} {L : LModule R} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix L.E m k) : Matrix L.E n k \n=> mkMatrix {L.E} {n} {k}\n  (\\lam (i : Fin n) (k : Fin k) => BigSum {L} (\\new Array L.E m (\\lam (j : Fin m) => at {at {M} i} j L.*c at {at {N} j} k)))", "\\func mkColumn {R : \\Type} (l : Array R) : Matrix R l.len 1 => mkMatrix {R} {l.len} {1} (\\lam (i : Fin l.len) (_ : Fin 1) => l.at i)", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["R : Ring", "V : LModule R", "U : LModule R", "bu : IsBasis {U} lu", "i : Fin lu.len", "lu : Array U.E", "lv : Array V.E", "A : Matrix R.E lu.len lv.len"], "Expected type": "func {extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (p0 : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} p0} 0))}\n  (lu.at i) = at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} i} 0", "Expression": "extend-char bu {?} i", "Premises": ["\\lemma extend-char \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) (j : Fin l.len) :\n  func {extend {R} {U} {V} {l} lb lv} (l.at j) = lv.at j ", "\\func product-gen \\hlevels  {R : Ring} {L : LModule R} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix L.E m k) : Matrix L.E n k \n=> mkMatrix {L.E} {n} {k}\n  (\\lam (i : Fin n) (k : Fin k) => BigSum {L} (\\new Array L.E m (\\lam (j : Fin m) => at {at {M} i} j L.*c at {at {N} j} k)))", "\\func mkColumn {R : \\Type} (l : Array R) : Matrix R l.len 1 => mkMatrix {R} {l.len} {1} (\\lam (i : Fin l.len) (_ : Fin 1) => l.at i)", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["U : LModule R", "bu : IsBasis {U} lu", "R : Ring", "lu : Array U.E"], "Expected type": "LinearMap {R} U U {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {U} (\\new Array U.E lu.len (\\lam (j : Fin lu.len) => at {basis-split {U} {lu} bu x} j U.*c lu.at j))\n}", "Expression": "extend bu {?}", "Premises": ["| Dom : BaseSet", "basis-split \\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 *c (E {R}) E : E", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| len : Nat"]}
{"Context": ["U : LModule R", "bu : IsBasis {U} lu", "R : Ring", "lu : Array U.E", "u : U.E"], "Expected type": "func {extend {R} {U} {U} {lu} bu (\\new Array U.E lu.len lu.at)} u = func {id {R} {U}} u", "Expression": "basis-ext {?} id {?} {?} u", "Premises": ["\\func id \\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\n  | func => \\lam (a : E {Dom {\\this}}) => a\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func extend \\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    BigSum {V} (\\new Array V.E l.len (\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\lemma basis-ext \\hlevels  {R : Ring} {U V : LModule R} (f g : LinearMap {R} U V) {l : Array U.E} (_ : IsGenerated {U} l)\n  (_ : \\Pi (j : Fin l.len) -> f.func (l.at j) = g.func (l.at j)) (u : U.E) : f.func u = g.func u ", "| len : Nat"]}
{"Context": ["U : LModule R", "h1 : func {ret {\\this} (toMatrix {R} {U} {V} {lv} lu bv f)} = f.func", "this : QEquiv ", "f : A {\\this}", "V : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x V.+ (@) h1 i y) (func-+ {ret {\\this} (f {\\this} f1)})\n  f.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["U : LModule R", "h1 : func {ret {\\this} (toMatrix {R} {U} {V} {lv} lu bv f)} = f.func", "this : QEquiv ", "R : Ring", "f : A {\\this}", "V : LModule R"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r V.*c (@) h1 i x)\n  (func-*c {ret {\\this} (f {\\this} f1)}) f.func-*c", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ret B : A", "| \\infixl 7 *c (E {R}) E : E", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| f A : B", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : func {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A} = func {toLinearMap {R} {U} {W} {lu} bu (map {V.E} {W.E} f.func lv) A}", "f : LinearMap ", "lu : Array U.E", "U : LModule R", "bu : IsBasis {U} lu", "V : LModule R", "W : LModule R", "A : Matrix R.E lu.len lv.len", "lv : Array V.E", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : U.E} -> (@) h1 i (x U.+ y) = (@) h1 i x W.+ (@) h1 i y)\n  (func-+ {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A})\n  (func-+ {toLinearMap {R} {U} {W} {lu} bu (map {V.E} {W.E} f.func lv) A})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func toLinearMap \\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\nLinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n} => extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : func {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A} = func {toLinearMap {R} {U} {W} {lu} bu (map {V.E} {W.E} f.func lv) A}", "f : LinearMap ", "lu : Array U.E", "U : LModule R", "bu : IsBasis {U} lu", "V : LModule R", "W : LModule R", "A : Matrix R.E lu.len lv.len", "lv : Array V.E", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r W.*c (@) h1 i x)\n  (func-*c {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A})\n  (func-*c {toLinearMap {R} {U} {W} {lu} bu (map {V.E} {W.E} f.func lv) A})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "| \\infixl 7 *c (E {R}) E : E", "\\func toLinearMap \\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\nLinearMap {R} U V {\n  | func => \\lam (x : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E lu.len (\\lam (j : Fin lu.len) =>\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\n} => extend {R} {U} {V} {lu} bu\n  (\\new Array V.E lu.len (\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {Dom {\\this}}", "m : Nat", "B : LModule R", "i : I", "f : Fin m -> LinearMap {R} A B", "y : E {Dom {\\this}}"], "Expected type": "Array B.E m (\\lam (i1 : Fin m) => func-+ {f i1} {x} {y} @ i)", "Expression": "\\new DArray {\n  | len => m\n  | A => \\lam (_ : Fin m) => B.E\n  | at => (ext (\\lam i => func-+) : (\\lam (i : Fin m) => func {f i} (x A.+ y)) = (\\lam (i : Fin m) => func {f i} x B.+ func {f i} y)) @ i\n}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set"]}
{"Context": ["m : Nat", "B : LModule R", "x : E {Dom {\\this}}", "i : I", "f : Fin m -> LinearMap {R} A B", "r : E {R {\\this}}"], "Expected type": "Array B.E m (\\lam (i1 : Fin m) => func-*c {f i1} {r} {x} @ i)", "Expression": "\\new DArray {\n  | len => m\n  | A => \\lam (_ : Fin m) => B.E\n  | at => (ext (\\lam i => func-*c) : (\\lam (i : Fin m) => func {f i} (r A.*c x)) = (\\lam (i : Fin m) => r B.*c func {f i} x)) @ i\n}", "Premises": ["\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x", "| E : \\Set"]}
{"Context": ["f : PointedHom", "arg : f.func (ide {f.Dom}) = ide {f.Cod}", "this : PointedHom f.Dom (ImagePointed f) "], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {\\this} (ide {Dom {\\this}})).2\n  (ide {Cod {\\this}}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : PointedHom"], "Expected type": "PointedHom f.Dom (ImagePointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n  | func-ide => {?hidden}\n}", "Expression": "\\new PointedHom {\n  | Dom => Dom {f}\n  | Cod => ImagePointed f\n  | func => \\lam a => (f a, inP (a, idp))\n  | func-ide => ext func-ide\n}", "Premises": ["| Dom : BaseSet", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| func-ide : func (ide {Dom}) = ide {Cod}", "| Cod : BaseSet", "inP A", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["this : AddPointedHom f.Dom (ImageAddPointed f) ", "arg : f.func (zro {f.Dom}) = zro {f.Cod}", "f : AddPointedHom"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {\\this} (zro {Dom {\\this}})).2\n  (zro {Cod {\\this}}).2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : AddPointedHom"], "Expected type": "AddPointedHom f.Dom (ImageAddPointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n  | func-zro => {?hidden}\n}", "Expression": "\\new AddPointedHom {\n  | Dom => Dom {f}\n  | Cod => ImageAddPointed f\n  | func => \\lam a => (f a, inP (a, idp))\n  | func-zro => ext func-zro\n}", "Premises": ["| Dom : BaseSet", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| func-zro : func (zro {Dom}) = zro {Cod}", "| Cod : BaseSet", "inP A", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : AddPointedHom", "y : Image {E {f.Dom}} {E {f.Cod}} f.func", "arg : f.func s.1 = y.1", "s : \\Sigma (a : E {f.Dom}) (f.func a = y.1)"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (a : E {f.Dom}) (f.func a = arg @ i))) (func {ImageAddPointedLeftHom f} s.1).2 y.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| Dom : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func ImageAddPointedLeftHom \\hlevels  (f : AddPointedHom) : AddPointedHom f.Dom (ImageAddPointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new AddPointedHom {\n  | func-zro => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["f : AddPointedHom", "y : Image {E {f.Dom}} {E {f.Cod}} f.func"], "Expected type": "TruncP (\\Sigma (x : E {f.Dom}) (func {ImageAddPointedLeftHom f} x = y))", "Expression": "map {?} (\\lam s => (s.1, ext s.2))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "| Dom : BaseSet", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func ImageAddPointedLeftHom \\hlevels  (f : AddPointedHom) : AddPointedHom f.Dom (ImageAddPointed f) {\n  | func => \\lam (a : E {Dom {\\this}}) => (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n} => \\new AddPointedHom {\n  | func-zro => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type Image {A B : \\Type} (f : A -> B) : \\Type => \\Sigma (b : B) (TruncP (\\Sigma (a : A) (f a = b)))", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["K : FinModule R1 (Kernel (arrayLinearMap ", "q : (l' !! 0).1 = K.zro.1", "U : FinModule R", "R : SmithDomain", "l' : Array K.E (suc n)", "l : Array U.E"], "Expected type": "Path (\\lam (i : I) => func {arrayLinearMap {R} {U} l} (q @ i) = zro {Cod {arrayLinearMap {R} {U} l}}) (l'.at 0).2 K.zro.2", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func arrayLinearMap \\hlevels  {R1 : Ring} {V : LModule R1} (v : Array V.E) : LinearMap {R1} (ArrayLModule {R1} v.len (RingLModule R1)) V {\n  | func => \\lam (c : E {Dom {\\this}}) => BigSum {V} (\\new Array V.E v.len (\\lam (j : Fin v.len) => c.at j V.*c v.at j))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "| Cod : BaseSet", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| func (E {Dom}) : E {Cod}", "| zro : E"]}
{"Context": ["K : FinModule R1 (Kernel (arrayLinearMap ", "U : FinModule R", "l' : Array K.E (suc n)", "R : SmithDomain", "l'b : IsBasis {K} l'", "l : Array U.E"], "Expected type": "TruncP (\\Sigma (c : Array (E {U.R}) l.len) (BigSum {U} (\\new Array U.E l.len (\\lam (j : Fin l.len) => c.at j U.*c l.at j)) = U.zro)\n  (j : Fin l.len) (c.at j /= zro {U.R}))", "Expression": "inP (\n  \\let | (a, p) => l' 0\n       | (j, q) => array/= {R} {len {l}} (\\lam q => zro/=ide $ independent-nonZero {K} {l'} l'b.1 (ext q))\n  \\in (a, p, j, q))", "Premises": ["| zro/=ide : zro /= ide", "| R : Ring", "| \\infixl 7 *c (E {R}) E : E", "\\func array/= {A2 : DecSet} {n1 : Nat} {l1 l'1 : Array A.E n1} (_ : l1 /= l'1) : \\Sigma (j : Fin n1) (l.at j /= l'.at j) \n  | {A}, {0}, {nil}, {nil}, p => absurd {\\Sigma (j : Fin 0) (at {nil} j /= at {nil} j)} (p (idp {Array A.E 0} {nil}))\n  | {A}, {suc n}, {a :: l}, {a' :: l'}, p => \\case A.decideEq a a' \\with {\n    | yes a=a' => \n      \\have (j, q) => array/= {A} {l.len} {l} {l'}\n              (\\lam (s : l = l') => p (pmap2 {A.E} {Array A.E l.len} {Array A.E (suc l.len)} (::) {a} {a'} a=a' {l} {l'} s))\n      \\in (suc j, q)\n    | no a/=a' => (0, a/=a')\n  }", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\lemma independent-nonZero \\hlevels  {this : LModule} {l : Array E} (_ : IsIndependent l) {j : Fin l.len} (_ : l.at j = zro) : zro {R} = ide {R} ", "inP A", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["li : Array (Fin n) k", "lj : Array (Fin m) k", "n : Nat", "s : \\Sigma (i j : Fin (len {sort {FinOrder n} li})) (i /= j) (at {sort {FinOrder n} li} i = at {sort {FinOrder n} li} j)", "R : CRing", "A : Matrix R.E n m", "k : Nat", "m : Nat"], "Expected type": "FinSum {R} {SymFin k} (\\lam (e : Sym k) => sign {R} {k} e R.* BigProd {R}\n  (\\new Array R.E k (\\lam (j : Fin k) => at {at {subMatrix {R.E} {n} {m} A (sort {FinOrder n} li) (sort {FinOrder m} lj)} (f {e} j)} j))) = zro", "Expression": "to/= {R} alternating (subMatrix A (sort li) (sort lj)) (s.1, s.2, s.3, exts (\\lam j => pmap (\\lam p0 => A p0 _) s.4))", "Premises": ["| \\infixl 7 * E E : E", "\\func sign \\hlevels  {R : Ring} {n : Nat} (e : Sym n) : R.E => pow {R} (R.negative R.ide) (inversions {n} e)", "\\func subMatrix {R : \\Type} {n m : Nat} (A : Matrix R n m) (li : Array (Fin n)) (lj : Array (Fin m)) : Matrix R li.len lj.len \n  => mkMatrix {R} {li.len} {lj.len} (\\lam (i : Fin li.len) (j : Fin lj.len) => at {at {A} (li.at i)} (lj.at j))", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func sort \\hlevels  {A : Dec} (l : Array A.E) : Array A.E l.len \n=> transport {Nat} (\\lam (n : Nat) => Array A.E n) {length {A.E} (sort {A} (toList {A.E} l))} {l.len}\n  (inv {Nat} {length {A.E} (toList {A.E} l)} {length {A.E} (sort {A} (toList {A.E} l))}\n    (perm_length {A.E} {toList {A.E} l} {sort {A} (toList {A.E} l)} (sort-perm {A} (toList {A.E} l))) *> toList_length {A.E} {l})\n  (fromList {A.E} (sort {A} (toList {A.E} l)))", "\\type Sym \\plevels  \\hlevels  (n : Nat) : \\Set0 => Equiv {Fin n} {Fin n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma alternating {R : CRing} {n : Nat} : isAlternating {R} {n} {ArrayLModule {R} n (RingLModule R)} {RingLModule R} (determinant {R} {n}) ", "\\lemma to/= \\hlevels  {R : Ring} {n : Nat} {A B : LModule R} {f : Array A.E n -> B.E} (_ : isAlternating {R} {n} {A} {B} f) (l : Array A.E n)\n  (_ : \\Sigma (i j : Fin n) (i /= j) (l.at i = l.at j)) : f l = B.zro ", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| f A : B", "| E : \\Set", "| zro : E"]}
{"Context": ["li : Array (Fin n) k", "lj : Array (Fin m) k", "n : Nat", "s : \\Sigma (i j : Fin (len {sort {FinOrder n} li})) (i /= j) (at {sort {FinOrder n} li} i = at {sort {FinOrder n} li} j)", "R : CRing", "p : k <= n", "A : Matrix R.E n m", "q : k <= m", "k : Nat", "m : Nat"], "Expected type": "TruncP (LDiv {R} (BigProd {R} (\\new Array R.E k (\\lam (j : Fin k) => at {at {A} (index {n} {k} p j)} (index {m} {k} q j))))\n  (FinSum {R} {SymFin k} (\\lam (e : Sym k) => sign {R} {k} e R.* BigProd {R}\n    (\\new Array R.E k (\\lam (j : Fin k) => at {at {A} (at {sort {FinOrder n} li} (f {e} j))} (at {sort {FinOrder m} lj} j))))))", "Expression": "inP (transportInv (LDiv _)\n  (to/= {R} alternating (subMatrix A (sort li) (sort lj)) (s.1, s.2, s.3, exts (\\lam j => pmap (\\lam p0 => A p0 _) s.4)))\n  (zero-div {R}))", "Premises": ["\\func sign \\hlevels  {R : Ring} {n : Nat} (e : Sym n) : R.E => pow {R} (R.negative R.ide) (inversions {n} e)", "\\func subMatrix {R : \\Type} {n m : Nat} (A : Matrix R n m) (li : Array (Fin n)) (lj : Array (Fin m)) : Matrix R li.len lj.len \n  => mkMatrix {R} {li.len} {lj.len} (\\lam (i : Fin li.len) (j : Fin lj.len) => at {at {A} (li.at i)} (lj.at j))", "\\type Sym \\plevels  \\hlevels  (n : Nat) : \\Set0 => Equiv {Fin n} {Fin n}", "\\func index \\plevels  \\hlevels  {n k : Nat} (p : k <= n) (i : Fin k) : Fin n => toFin i {n} {?hidden}", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| \\infixl 7 * E E : E", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func sort \\hlevels  {A : Dec} (l : Array A.E) : Array A.E l.len \n=> transport {Nat} (\\lam (n : Nat) => Array A.E n) {length {A.E} (sort {A} (toList {A.E} l))} {l.len}\n  (inv {Nat} {length {A.E} (toList {A.E} l)} {length {A.E} (sort {A} (toList {A.E} l))}\n    (perm_length {A.E} {toList {A.E} l} {sort {A} (toList {A.E} l)} (sort-perm {A} (toList {A.E} l))) *> toList_length {A.E} {l})\n  (fromList {A.E} (sort {A} (toList {A.E} l)))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma zero-div \\hlevels  {this : Semiring} {x : E} : LDiv x zro zro ", "\\func transportInv {A : \\Type} (B : A -> \\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \n  | {A}, B, {a}, {a'}, idp, b => b", "\\lemma alternating {R : CRing} {n : Nat} : isAlternating {R} {n} {ArrayLModule {R} n (RingLModule R)} {RingLModule R} (determinant {R} {n}) ", "\\lemma to/= \\hlevels  {R : Ring} {n : Nat} {A B : LModule R} {f : Array A.E n -> B.E} (_ : isAlternating {R} {n} {A} {B} f) (l : Array A.E n)\n  (_ : \\Sigma (i j : Fin n) (i /= j) (l.at i = l.at j)) : f l = B.zro ", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1", "inP A", "| f A : B"]}
{"Context": ["i/=j : i /= j", "n : Nat", "j : Fin n", "A : Matrix R.E n n", "R : CRing", "i : Fin n"], "Expected type": "at {\\new Array (Array R.E n) n (\\lam (j : Fin n) => padd {R} ide R.zro * padd {R} (pzero {R}) (\\case decideEq i j \\with {\n  | yes p => R.ide\n  | no n => R.zro\n}) *c \\new Array R.E n (\\lam (j1 : Fin n) => (\\case decideEq j j1 \\with {\n  | yes p => R.ide\n  | no n => R.zro\n})))} j = zro {polyModule {R} {ArrayFinModule {R} n} (toLinearMap {R} {n} {n} A)}", "Expression": "later (rewrite (decideEq/=_reduce i/=j) $ exts (\\lam k => simplify $ BigSum_zro {R} (\\lam l => simplify $ pmap ((*) _) (BigSum_zro {R} (\\lam _ => zro_*-right {R})) *> zro_*-right {R})))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func \\infixl 7 *c \\hlevels  {R3 : Ring} (_ : R.E) (_ : Poly R3) : Poly R3 \n  | {R}, r, pzero => pzero {R}\n  | {R}, r, padd p e => padd {R} (r *c p) (r R.* e)\n  | {R}, r, peq i =>\n    (pmap {R.E} {Poly R} (padd {R} (pzero {R})) {r R.* R.zro} {R.zro} (R.zro_*-right {r}) *> path (peq {R})) @ i", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| zro : E", "\\lemma BigSum_zro \\hlevels  {this : AddMonoid} {l : Array E} (_ : \\Pi (j : Fin l.len) -> l.at j = zro) : BigSum l = zro ", "\\func Big {A1 B1 : \\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \n  | {A}, {B}, op, b, nil => b\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)", "yes E", "| \\infixl 7 * E E : E", "\\field decideEq (x y : E) : Dec (x = y)", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "no (Not E)", "\\lemma decideEq/=_reduce \\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ", "| zro_*-right {x : E} : x * zro = zro", "\\func toLinearMap \\hlevels  {R1 : CRing} {n m : Nat} (A : Matrix R.E n m) : LinearMap {R1} (ArrayFinModule {R1} n) (ArrayFinModule {R1} m) {\n  | func => \\lam (u : E {Dom {\\this}}) =>\n    \\new Array R.E m (\\lam (j : Fin m) => BigSum {R1} (\\new Array R.E n (\\lam (i : Fin n) => at {at {A} i} j R.* u.at i)))\n} => \\new LinearMap {\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| E : \\Set", "| \\infixl 7 *c (E {R}) E : E", "\\func \\infixl 6 - \\plevels  \\hlevels  (_ _ : Nat) : Int \n  | 0, m => neg m\n  | n, 0 => pos n\n  | suc n, suc m => n - m", "right", "pzero", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "padd (Poly R) R.E", "\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \n  | {R}, pzero, q => pzero {R}\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\n  | {R}, peq i, q =>\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i", "\\func polyModule \\hlevels  {R1 : Ring} {U : LModule R1} (f : LinearMap {R1} U U) : LModule (PolyRing R1) U.E {\n  | zro => U.zro\n  | + => (U.+)\n  | negative => U.negative\n  | *c => \\lam (p : E {R {\\this}}) => poly_func {R1} {U} p f\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| ide : E"]}
{"Context": ["h1 : f.func = g.func", "f : E {\\this}", "M : DecSet", "g : E {\\this}", "R : AddPointed"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array M.E) (\\Pi (i1 : M.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = R.zro)))\n  f.fSupp g.fSupp", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["i : I", "h1 : f.func = g.func", "arg : \\Pi (i : M.E) -> f.func i = g.func i", "f : E {\\this}", "M : DecSet", "g : E {\\this}", "R : AddPointed"], "Expected type": "FinSuppFunc M R {\n  | func => \\lam (e : E {Dom {\\this}}) => arg e @ i\n  | fSupp => {?hidden}\n}", "Expression": "\\new FinSuppFunc {\n  | func => \\lam e => arg e @ i\n  | fSupp => prop-dpi (\\lam i => ext_coe) (fSupp {f}) (fSupp {g}) @ i\n}", "Premises": ["| Dom : BaseSet", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["x : E {\\this}", "this : AddMonoid (FinSuppFunc A B) ", "A : BaseSet", "B : AddMonoid", "h1 : (\\lam (e : A.E) => B.zro B.+ x.func e) = x.func"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array A.E) (\\Pi (i1 : A.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = B.zro)))\n  (fSupp {zro {\\this} + x}) x.fSupp", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["this : AddMonoid (FinSuppFunc A B) ", "A : BaseSet", "h1 : (\\lam (e : A.E) => x.func e B.+ B.zro) = x.func", "B : AddMonoid", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array A.E) (\\Pi (i1 : A.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = B.zro)))\n  (fSupp {x + zro {\\this}}) x.fSupp", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["z : E {\\this}", "h1 : (\\lam (e : A.E) => x.func e B.+ y.func e B.+ z.func e) = (\\lam (e : A.E) => x.func e B.+ (y.func e B.+ z.func e))", "y : E {\\this}", "this : AddMonoid (FinSuppFunc A B) ", "A : BaseSet", "B : AddMonoid", "x : E {\\this}"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array A.E) (\\Pi (i1 : A.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = B.zro)))\n  (fSupp {x + y + z}) (fSupp {x + (y + z)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["B : AbMonoid", "x : E {\\this}", "A : BaseSet", "this : AbMonoid (FinSuppFunc A B) ", "y : E {\\this}", "h1 : (\\lam (e : A.E) => x.func e B.+ y.func e) = (\\lam (e : A.E) => y.func e B.+ x.func e)"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array A.E) (\\Pi (i1 : A.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = B.zro)))\n  (fSupp {x + y}) (fSupp {y + x})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["B : AbMonoid", "A : BaseSet"], "Expected type": "AbMonoid (FinSuppFunc A B) {\n  | zro => \\new FinSuppFunc A B {\n    | func => \\lam (_ : E {Dom {\\this}}) => B.zro\n    | fSupp => {?hidden}\n  }\n  | + => \\lam (f : E) (g : E) => \\new FinSuppFunc A B {\n    | func => \\lam (a : E {Dom {\\this}}) => f.func a B.+ g.func a\n    | fSupp => {?hidden}\n  }\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n}", "Expression": "\\new AbMonoid {\n  | E => FinSuppFunc A B\n  | AddMonoid => FinSuppFuncAddMonoid\n  | +-comm => exts (\\lam a => +-comm)\n}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "| zro-right {x : E} : x + zro = x", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "| zro-left {x : E} : zro + x = x", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "| zro : E", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| Dom : BaseSet", "| \\infixl 6 + E E : E"]}
{"Context": ["B : AddGroup", "x : E {\\this}", "h1 : (\\lam (e : A.E) => B.negative (x.func e) B.+ x.func e) = (\\lam (_ : A.E) => B.zro)", "this : AddGroup (FinSuppFunc A B) ", "A : BaseSet"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array A.E) (\\Pi (i1 : A.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = B.zro)))\n  (fSupp {negative {\\this} x + x}) (fSupp {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["B : AddGroup", "h1 : (\\lam (e : A.E) => x.func e B.+ B.negative (x.func e)) = (\\lam (_ : A.E) => B.zro)", "this : AddGroup (FinSuppFunc A B) ", "x : E {\\this}", "A : BaseSet"], "Expected type": "Path (\\lam (i : I) => TruncP (\\Sigma (s : Array A.E) (\\Pi (i1 : A.E) -> (\\Pi (j : Fin s.len) -> s.at j /= i1) -> (@) h1 i i1 = B.zro)))\n  (fSupp {x + negative {\\this} x}) (fSupp {zro {\\this}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "| fSupp : TruncP (\\Sigma (s : Array (E {Dom})) (\\Pi (i : E {Dom}) -> (\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "| len : Nat"]}
{"Context": ["t : Term n", "n : Nat", "G : CGroup", "env : Fin n -> G.E"], "Expected type": "BigProd {G} (\\new Array G.E n (\\lam (j : Fin n) => ipow {G} (env j) (negative (at {normalize {n} t} j)))) = BigProd {G} (map {G.E} {G.E} G.inverse (\\new Array G.E n (\\lam (j : Fin n) => ipow {G} (env j) (at {normalize {n} t} j))))", "Expression": "BigProd-ext {G} {?}", "Premises": ["\\func normalize \\plevels  \\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\n  | {n}, :ide => replicate {Int} n (pos 0)\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\n  | {n}, t :* s => mkArray {Int} {n} (\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)", "\\func ipow \\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \n  | {this}, a, pos n => pow a n\n  | {this}, a, neg n => pow (inverse a) n", "| negative E : E", "| inverse E : E", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma BigProd-ext \\hlevels  {this : Monoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigProd l = BigProd l' "]}
{"Context": ["G : CGroup", "n : Nat", "t : Term n", "env : Fin n -> G.E", "s : Term n"], "Expected type": "BigProd {G} (\\new Array G.E n (\\lam (j : Fin n) => ipow {G} (env j) (at {normalize {n} t} j + at {normalize {n} s} j))) = BigProd {G}\n  (\\new Array G.E n (\\lam (i : Fin n) => ipow {G} (env i) (at {normalize {n} t} i) G.* ipow {G} (env i) (at {normalize {n} s} i)))", "Expression": "BigProd-ext {G} {?}", "Premises": ["\\func normalize \\plevels  \\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\n  | {n}, :ide => replicate {Int} n (pos 0)\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\n  | {n}, t :* s => mkArray {Int} {n} (\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)", "| \\infixl 6 + E E : E", "| \\infixl 7 * E E : E", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func ipow \\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \n  | {this}, a, pos n => pow a n\n  | {this}, a, neg n => pow (inverse a) n", "| E : \\Set", "\\lemma BigProd-ext \\hlevels  {this : Monoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigProd l = BigProd l' "]}
{"Context": ["n : Nat", "env : Array G.E n", "l' : Array Int n", "G : CGroup", "l : Array Int n"], "Expected type": "BigProd {G} (\\new Array G.E n (\\lam (j : Fin n) => ipow {G} (env.at j) (l.at j + l'.at j))) = BigProd {G} (\\new Array G.E n (\\lam (i : Fin n) => ipow {G} (env.at i) (l.at i) G.* ipow {G} (env.at i) (l'.at i)))", "Expression": "BigProd-ext {G} {?}", "Premises": ["| \\infixl 6 + E E : E", "| \\infixl 7 * E E : E", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func ipow \\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \n  | {this}, a, pos n => pow a n\n  | {this}, a, neg n => pow (inverse a) n", "| E : \\Set", "\\lemma BigProd-ext \\hlevels  {this : Monoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigProd l = BigProd l' "]}
{"Context": ["env : Array G.E l.len", "G : CGroup", "l : Array Int"], "Expected type": "BigProd {G} (\\new Array G.E l.len (\\lam (j : Fin l.len) => ipow {G} (env.at j) (negative (l.at j)))) = BigProd {G} (map {G.E} {G.E} G.inverse (\\new Array G.E l.len (\\lam (j : Fin l.len) => ipow {G} (env.at j) (l.at j))))", "Expression": "BigProd-ext {G} {len {l}} {?}", "Premises": ["| inverse E : E", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func ipow \\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \n  | {this}, a, pos n => pow a n\n  | {this}, a, neg n => pow (inverse a) n", "| negative E : E", "| E : \\Set", "\\lemma BigProd-ext \\hlevels  {this : Monoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigProd l = BigProd l' ", "| len : Nat"]}
{"Context": ["G : CGroup", "n : Nat", "c : Int", "env : Array G.E l.len", "l : Array Int n"], "Expected type": "BigProd {G} (\\new Array G.E n (\\lam (j : Fin n) => ipow {G} (env.at j) (c * l.at j))) = BigProd {G} (\\new Array G.E n (\\lam (i : Fin n) => ipow {G} (ipow {G} (env.at i) (l.at i)) c))", "Expression": "BigProd-ext {G} {len {l}} {?}", "Premises": ["| \\infixl 7 * E E : E", "\\func ipow \\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \n  | {this}, a, pos n => pow a n\n  | {this}, a, neg n => pow (inverse a) n", "| len : Nat", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma BigProd-ext \\hlevels  {this : Monoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigProd l = BigProd l' "]}
{"Context": ["a : E", "a : E.E", "K : DiscreteField", "p : func {embed {polyImage {K} {E1} f a}} a1 = func {embed {polyImage {K} {E1} f a}} a'", "f : RingHom K E", "a' : E", "E : ImpotentCRing"], "Expected type": "a1 = a'", "Expression": "ext p", "Premises": ["\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : RingHom K S", "l' : Array S.E l.len (\\lam (j : Fin l.len) => l.at j - pow ", "S : CRing", "K : DiscreteField"], "Expected type": "contains (f.func (zro {K}))", "Expression": "mPolyImage-ext f l' zro", "Premises": ["| contains (E {S}) : \\Prop", "\\lemma mPolyImage-ext \\hlevels  {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) (b : R.E) : contains (f.func b) ", "\\func mPolyImage {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) :\nSubRing (Cod {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}})\n    (func {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f} x = y))) \n  => ringHomImage (mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f)", "| zro : E", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["h : \\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "c : Countable k.E", "ps : Nat -> Poly k", "sf : \\Pi (n : Nat) -> \\Sigma (K : DiscreteField) (Countable K.E) (f : RingHom (sequence {k} c ps n).1 K)\n  (IsSplittingField {(sequence {k} c ps n).1} {K} (polyMap (S n).3 (ps n)) f)", "n : Nat", "k : DiscreteField", "F : Functor NatSemiring CRingCat (\\lam (n : Nat) => (S n).1) ", "h1 : (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (0, e)) = (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (suc n, func {(sf n).3 \u2218 (S n).3} e))", "S : Nat -> \\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {F.F 0}} -> (@) h1 i (x + y) = (@) h1 i x + (@) h1 i y) (func-+ {h 0})\n  (func-+ {h (suc n) \u2218 ((sf n).3 \u2218 (S n).3)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h : \\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "c : Countable k.E", "ps : Nat -> Poly k", "sf : \\Pi (n : Nat) -> \\Sigma (K : DiscreteField) (Countable K.E) (f : RingHom (sequence {k} c ps n).1 K)\n  (IsSplittingField {(sequence {k} c ps n).1} {K} (polyMap (S n).3 (ps n)) f)", "n : Nat", "k : DiscreteField", "F : Functor NatSemiring CRingCat (\\lam (n : Nat) => (S n).1) ", "h1 : (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (0, e)) = (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (suc n, func {(sf n).3 \u2218 (S n).3} e))", "S : Nat -> \\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {F.F 0}) = ide) (func-ide {h 0}) (func-ide {h (suc n) \u2218 ((sf n).3 \u2218 (S n).3)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E"]}
{"Context": ["h : \\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "c : Countable k.E", "ps : Nat -> Poly k", "sf : \\Pi (n : Nat) -> \\Sigma (K : DiscreteField) (Countable K.E) (f : RingHom (sequence {k} c ps n).1 K)\n  (IsSplittingField {(sequence {k} c ps n).1} {K} (polyMap (S n).3 (ps n)) f)", "n : Nat", "k : DiscreteField", "F : Functor NatSemiring CRingCat (\\lam (n : Nat) => (S n).1) ", "h1 : (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (0, e)) = (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (suc n, func {(sf n).3 \u2218 (S n).3} e))", "S : Nat -> \\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {F.F 0}} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y) (func-* {h 0})\n  (func-* {h (suc n) \u2218 ((sf n).3 \u2218 (S n).3)})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| F (Ob {C}) : Ob {D}", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h : \\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "c : Countable k.E", "ps : Nat -> Poly k", "k : DiscreteField", "F : Functor NatSemiring CRingCat (\\lam (n : Nat) => (S n).1) ", "n : Ob", "S : Nat -> \\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)", "h1 : (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (zro, e)) = (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (n, func {(S n).3} e))", "E : DiscreteField (SetColimit "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : k.E} -> (@) h1 i (x k.+ y) = (@) h1 i x E.+ (@) h1 i y) (func-+ {h zro})\n  (func-+ {inMap {NatBSemilattice} {F} n \u2218 (S n).3})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D RingCat} (d : D.E) : RingHom (F.F d) (RingLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E"]}
{"Context": ["h : \\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "c : Countable k.E", "ps : Nat -> Poly k", "k : DiscreteField", "F : Functor NatSemiring CRingCat (\\lam (n : Nat) => (S n).1) ", "n : Ob", "S : Nat -> \\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)", "h1 : (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (zro, e)) = (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (n, func {(S n).3} e))", "E : DiscreteField (SetColimit "], "Expected type": "Path (\\lam (i : I) => (@) h1 i k.ide = E.ide) (func-ide {h zro}) (func-ide {inMap {NatBSemilattice} {F} n \u2218 (S n).3})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D RingCat} (d : D.E) : RingHom (F.F d) (RingLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| ide : E"]}
{"Context": ["h : \\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "c : Countable k.E", "ps : Nat -> Poly k", "k : DiscreteField", "F : Functor NatSemiring CRingCat (\\lam (n : Nat) => (S n).1) ", "n : Ob", "S : Nat -> \\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)", "h1 : (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (zro, e)) = (\\lam (e : k.E) => in~ {\\Sigma (j : Ob) (F j)}\n  {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n  (n, func {(S n).3} e))", "E : DiscreteField (SetColimit "], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : k.E} -> (@) h1 i (x k.* y) = (@) h1 i x E.* (@) h1 i y) (func-* {h zro})\n  (func-* {inMap {NatBSemilattice} {F} n \u2218 (S n).3})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D RingCat} (d : D.E) : RingHom (F.F d) (RingLatticeColimit {D} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) =>\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E"]}
{"Context": ["this : PseudoSemiring (\\Sigma (x : E ", "x : E {\\this}", "this : SubPseudoSemiring"], "Expected type": "x * zro {\\this} = zro {\\this}", "Expression": "ext zro_*-right", "Premises": ["| \\infixl 7 * E E : E", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| zro_*-right {x : E} : x * zro = zro"]}
{"Context": ["H : Group", "p : G = H", "G : Group"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : E {p @ i}} -> x * y * z = x * (y * z)) G.*-assoc H.*-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["H : Group", "p : G = H", "G : Group"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {p @ i}} -> ide {p @ i} * x = x) G.ide-left H.ide-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| ide-left {x : E} : ide * x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["H : Group", "p : G = H", "G : Group"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {p @ i}} -> x * ide {p @ i} = x) G.ide-right H.ide-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| ide-right {x : E} : x * ide = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["H : Group", "p : G = H", "h1 : Path (\\lam (i : I) => E {p @ i} -> E {p @ i}) G.inverse H.inverse", "G : Group"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {p @ i}} -> (@) h1 i x * x = ide {p @ i}) G.inverse-left H.inverse-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E", "| inverse-left {x : E} : inverse x * x = ide"]}
{"Context": ["H : Group", "p : G = H", "h1 : Path (\\lam (i : I) => E {p @ i} -> E {p @ i}) G.inverse H.inverse", "G : Group"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {p @ i}} -> x * (@) h1 i x = ide {p @ i}) G.inverse-right H.inverse-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| inverse-right {x : E} : x * inverse x = ide", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["l : Array E", "n : Nat", "this : CGroup"], "Expected type": "BigProd (\\new Array E l.len (\\lam (i : Fin l.len) => ipow (l.at i) (neg n))) = BigProd (map {E} {E} inverse (\\new Array E l.len (\\lam (i : Fin l.len) => pow (l.at i) n)))", "Expression": "BigProd-ext {_} {len {l}} {?}", "Premises": ["| inverse E : E", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func BigProd \\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func ipow \\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \n  | {this}, a, pos n => pow a n\n  | {this}, a, neg n => pow (inverse a) n", "| E : \\Set", "\\lemma BigProd-ext \\hlevels  {this : Monoid} {n : Nat} {l l' : Array E n} (_ : \\Pi (i : Fin n) -> l.at i = l'.at i) : BigProd l = BigProd l' ", "neg Nat  {\n  | 0 => pos 0\n}", "| len : Nat"]}
{"Context": ["this : Semiring", "l : Array E", "p : \\Pi (j : Fin l.len) -> LDiv a (l.at j)", "a : E"], "Expected type": "LDiv a (BigSum l) (BigSum (\\new Array E l.len (\\lam (j : Fin l.len) => inv {p j}))) {\n  | inv-right => {?hidden}\n}", "Expression": "\\new LDiv {\n  | M => _\n  | val => a\n  | elem => BigSum  l\n  | inv => BigSum  (\\lam j => inv {p j})\n  | inv-right => BigSum-ldistr  *> pmap (BigSum ) (later $ exts (\\lam j => inv-right {p j}))\n}", "Premises": ["| inv-right : val * inv = elem", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\lemma BigSum-ldistr \\hlevels  {this : Semiring} {x : E} {l : Array E} : x * BigSum l = BigSum (map {E} {E} ((*) x) l) ", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "| inv : E {M}", "| len : Nat"]}
{"Context": ["arg : \\Sigma (p1 : M.E = N.E) (transport {\\Set} (\\lam (x : \\Set) => x) {M.E} {N.E} p1 M.ide = N.ide)\n  (\\Pi (e : M.E) -> \\Pi (e1 : M.E) ->\n    transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 (e M.* e1) = transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 e N.* transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 e1)", "M : Monoid", "N : Monoid", "h3 : Path (\\lam (i : I) => arg.1 @ i -> arg.1 @ i -> arg.1 @ i) (M.*) (N.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : arg.1 @ i} -> (@) h3 i ((@) h3 i x y) z = (@) h3 i x ((@) h3 i y z)) M.*-assoc N.*-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| *-assoc {x y z : E} : x * y * z = x * (y * z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : \\Sigma (p1 : M.E = N.E) (transport {\\Set} (\\lam (x : \\Set) => x) {M.E} {N.E} p1 M.ide = N.ide)\n  (\\Pi (e : M.E) -> \\Pi (e1 : M.E) ->\n    transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 (e M.* e1) = transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 e N.* transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 e1)", "M : Monoid", "N : Monoid", "h2 : Path ((@) arg.1) M.ide N.ide", "h3 : Path (\\lam (i : I) => arg.1 @ i -> arg.1 @ i -> arg.1 @ i) (M.*) (N.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : arg.1 @ i} -> (@) h3 i (h2 @ i) x = x) M.ide-left N.ide-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-left {x : E} : ide * x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["arg : \\Sigma (p1 : M.E = N.E) (transport {\\Set} (\\lam (x : \\Set) => x) {M.E} {N.E} p1 M.ide = N.ide)\n  (\\Pi (e : M.E) -> \\Pi (e1 : M.E) ->\n    transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 (e M.* e1) = transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 e N.* transport {\\Set} (\\lam (x1 : \\Set) => x1) {M.E} {N.E} p1 e1)", "M : Monoid", "N : Monoid", "h2 : Path ((@) arg.1) M.ide N.ide", "h3 : Path (\\lam (i : I) => arg.1 @ i -> arg.1 @ i -> arg.1 @ i) (M.*) (N.*)"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : arg.1 @ i} -> (@) h3 i x (h2 @ i) = x) M.ide-right N.ide-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-right {x : E} : x * ide = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["M : CancelMonoid", "x : M.E", "y : M.E", "t : associates {M} x y", "t' : associates {M} x y", "eq : val {t.1} = val {t'.1}"], "Expected type": "t = t'", "Expression": "ext (ext (eq, inv-isUnique t.1 t'.1 eq))", "Premises": ["\\lemma inv-isUnique \\hlevels  {M : Monoid} (j j' : Inv {M}) (_ : j.val = j'.val) : j.inv = j'.inv ", "| inv : E {M}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : A.E -> B.E", "B : FinSet", "t : \\Sigma (a : A.E) (f a = s.1)", "A : FinSet", "s : \\Sigma (b : B.E) (TruncP (\\Sigma (a : A.E) (f a = b)))"], "Expected type": "(f t.1, inP {\\Sigma (a : A.E) (f a = f t.1)} (t.1, idp {B.E} {f t.1})) = s", "Expression": "ext t.2", "Premises": ["\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "inP A", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["f : A.E -> B.E", "B : FinSet", "A : FinSet", "s : \\Sigma (b : B.E) (TruncP (\\Sigma (a : A.E) (f a = b)))"], "Expected type": "TruncP (\\Sigma (x : A.E) ((f x, inP {\\Sigma (a : A.E) (f a = f x)} (x, idp {B.E} {f x})) = s))", "Expression": "map {?} (\\lam t => (t.1, ext t.2))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "inP A", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["this : Domain", "i : Inv a.1", "this : Inv "], "Expected type": "inv {\\this} * val {\\this} = elem {\\this}", "Expression": "ext (inv-left {i})", "Premises": ["| inv-left : inv * val = elem", "| \\infixl 7 * E E : E", "| elem : E {M}", "| val : E {M}", "| inv : E {M}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : IntegralDomain"], "Expected type": "CancelCMonoid (\\Sigma (x : E) (#0 x)) {\n  | ide => (ide, zro#ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | cancel_*-left => {?hidden}\n  | *-comm => {?hidden}\n}", "Expression": "\\new CancelCMonoid {\n  | CancelMonoid => nonZeroMonoid \n  | *-comm => ext (*-comm )\n}", "Premises": ["| \\infixl 7 * E E : E", "| zro#ide : #0 ide", "| cancel_*-left (x : E) {y z : E} (x * y = x * z) : y = z", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| *-comm {x y : E} : x * y = y * x", "| ide-left {x : E} : ide * x = x", "| \\infix 8 #0 E : \\Prop", "| ide-right {x : E} : x * ide = x", "| E : \\Set", "\\func nonZeroMonoid \\hlevels  {this2 : Domain} : CancelMonoid (\\Sigma (x : E) (#0 x)) {\n  | ide => (ide, zro#ide)\n  | * => \\lam (x : E {\\this}) (y : E {\\this}) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\n} => \\new CancelMonoid {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | cancel_*-left => {?hidden}\n  | cancel_*-right => {?hidden}\n}", "| ide : E", "| #0-* {x y : E} (#0 x) (#0 y) : #0 (x * y)"]}
{"Context": ["eq : Equiv ", "f : D.E -> R.E", "D : FinSet", "a=fl : a = BigSum {R} (map {\\Sigma R.E D.E} {R.E} (\\lam (p : \\Sigma R.E D.E) => p.1 R.* f p.2) l)", "R : CRing", "a : R.E", "l : Array (\\Sigma R.E D.E)"], "Expected type": "TruncP (\\Sigma (l : Array (\\Sigma R.E (Fin D.finCard)))\n  (a = BigSum {R} (map {\\Sigma R.E (Fin D.finCard)} {R.E} (\\lam (p : \\Sigma R.E (Fin D.finCard)) => p.1 R.* f1 (eq.f p.2)) l)))", "Expression": "inP (map (\\lam p0 => (\n  \\let (r, d) => p0\n  \\in (r, ret {eq} d))) l, a=fl *> pmap BigSum (exts (\\lam j => pmap (\\lam p0 => _ * f p0) (inv (f_ret {eq} _)))))", "Premises": ["| ret B : A", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| A : \\Type", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func f_ret {this : Equiv} (y : B) : f (ret y) = y \n  => pmap {B} {B} (\\lam (y : B) => f (ret y)) {y} {f (sec y)} (inv {B} {f (sec y)} {y} (f_sec y)) *> pmap {A} {B} f {ret (f (sec y))} {sec y} (ret_f (sec y)) *> f_sec y", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| finCard : Nat", "| f A : B", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["null : Nat", "I : Ideal R"], "Expected type": "Dec (contains (ide {S {I}}))", "Expression": "{?error} (next {I.S} {{?error}} n (ideal {I.S} {{?error}} {{?error}} {I} {{?error}} n))\n  (next-fg {I.S} {{?error}} n (ideal {I.S} {{?error}} {{?error}} {I} {{?error}} n)) (ide {I.S})", "Premises": ["\\data Dec \\plevels  \\hlevels  \\Prop \n  | yes E\n  | no (Not E)", "| S : BaseSet", "| contains (E {S}) : \\Prop", "\\func next \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I1 : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\nIdeal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {I1.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n))) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "\\lemma next-fg \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\n  IsFinitelyGenerated {next {R} {c} n I} ", "\\func ideal \\hlevels  {R2 : CRing} {c1 : Countable R.E}\n  {Id1 : \\Pi (I : Ideal R2) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)} {I2 : Ideal R2}\n  {Ig2 : IsFinitelyGenerated {I2}} (_ : Nat) : \\Sigma (I : Ideal R2) (IsFinitelyGenerated {I}) \n  | {R}, {c}, {Id}, {I}, {Ig}, 0 => (I, Ig)\n  | {R}, {c}, {Id}, {I}, {Ig}, suc n =>\n  \\case Id (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) (next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) R.ide \\with {\n    | yes r => ideal {R} {c} {Id} {I} {Ig} n\n    | no r => (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n), next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n))\n  }", "| ide : E"]}
{"Context": ["n : Nat", "R : CRing", "I : Ideal R", "c : Countable R.E"], "Expected type": "Ideal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : E {R}) (contains {(ideal {S {I}} {{?error}} {{?error}} {I} {{?error}} n).1} x)\n    (z = x + y * pointed-countable {E {R}} (zro {R}) c n)))", "Expression": "next n (ideal n)", "Premises": ["\\func pointed-countable {A : \\Type} (a0 : A) (c : Countable A) (n : Nat) : A => maybe {A} {A} a0 (\\lam (a : A) => a) (c.1 n)", "| S : BaseSet", "| \\infixl 6 + E E : E", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "\\func next \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I1 : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\nIdeal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {I1.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n))) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "| E : \\Set", "| zro : E", "\\func ideal \\hlevels  {R2 : CRing} {c1 : Countable R.E}\n  {Id1 : \\Pi (I : Ideal R2) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)} {I2 : Ideal R2}\n  {Ig2 : IsFinitelyGenerated {I2}} (_ : Nat) : \\Sigma (I : Ideal R2) (IsFinitelyGenerated {I}) \n  | {R}, {c}, {Id}, {I}, {Ig}, 0 => (I, Ig)\n  | {R}, {c}, {Id}, {I}, {Ig}, suc n =>\n  \\case Id (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) (next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) R.ide \\with {\n    | yes r => ideal {R} {c} {Id} {I} {Ig} n\n    | no r => (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n), next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n))\n  }", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["n : Nat", "R : CRing", "I : Ideal R", "c : Countable R.E"], "Expected type": "TruncP (\\Sigma (l : Array (E {S})) (IsGeneratedBy {next {R} {c} n (ideal {S {I}} {{?error}} {{?error}} {I} {{?error}} n)} l))", "Expression": "next-fg n (ideal n)", "Premises": ["| S : BaseSet", "\\func next \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I1 : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\nIdeal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {I1.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n))) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "\\lemma next-fg \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\n  IsFinitelyGenerated {next {R} {c} n I} ", "| E : \\Set", "\\func IsGeneratedBy \\hlevels  {this : Ideal} (l : Array (E {S})) : \\Prop \n=> \\Sigma (\\Pi (j : Fin l.len) -> contains (l !! j)) (\\Pi {a : E {S}} -> contains a ->\n  TruncP (\\Sigma (l' : Array (E {S}) l.len) (a = BigSum {S} (\\new Array (E {S}) l.len (\\lam (j : Fin l.len) => l'.at j * l.at j)))))", "\\func ideal \\hlevels  {R2 : CRing} {c1 : Countable R.E}\n  {Id1 : \\Pi (I : Ideal R2) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)} {I2 : Ideal R2}\n  {Ig2 : IsFinitelyGenerated {I2}} (_ : Nat) : \\Sigma (I : Ideal R2) (IsFinitelyGenerated {I}) \n  | {R}, {c}, {Id}, {I}, {Ig}, 0 => (I, Ig)\n  | {R}, {c}, {Id}, {I}, {Ig}, suc n =>\n  \\case Id (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) (next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) R.ide \\with {\n    | yes r => ideal {R} {c} {Id} {I} {Ig} n\n    | no r => (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n), next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n))\n  }", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["n : Nat", "R : CRing", "I : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})", "c : Countable R.E"], "Expected type": "Ideal R\n  (\\lam (z : E {S {\\this}}) => TruncP (\\Sigma (x y : R.E) (contains {I.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n)))", "Expression": "next {R} {c} n I", "Premises": ["\\func pointed-countable {A : \\Type} (a0 : A) (c : Countable A) (n : Nat) : A => maybe {A} {A} a0 (\\lam (a : A) => a) (c.1 n)", "| S : BaseSet", "| \\infixl 6 + E E : E", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "\\func next \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I1 : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\nIdeal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {I1.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n))) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["R : CRing", "n : Nat", "I : Ideal R", "Ig : IsFinitelyGenerated {I}", "Id : \\Pi (I : Ideal R) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)", "c : Countable R.E"], "Expected type": "Ideal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {(ideal {R} {c} {Id} {I} {Ig} n).1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n)))", "Expression": "next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)", "Premises": ["\\func pointed-countable {A : \\Type} (a0 : A) (c : Countable A) (n : Nat) : A => maybe {A} {A} a0 (\\lam (a : A) => a) (c.1 n)", "| S : BaseSet", "| \\infixl 6 + E E : E", "| \\infixl 7 * E E : E", "| contains (E {S}) : \\Prop", "\\func next \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I1 : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\nIdeal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {I1.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n))) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "\\func ideal \\hlevels  {R2 : CRing} {c1 : Countable R.E}\n  {Id1 : \\Pi (I : Ideal R2) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)} {I2 : Ideal R2}\n  {Ig2 : IsFinitelyGenerated {I2}} (_ : Nat) : \\Sigma (I : Ideal R2) (IsFinitelyGenerated {I}) \n  | {R}, {c}, {Id}, {I}, {Ig}, 0 => (I, Ig)\n  | {R}, {c}, {Id}, {I}, {Ig}, suc n =>\n  \\case Id (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) (next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) R.ide \\with {\n    | yes r => ideal {R} {c} {Id} {I} {Ig} n\n    | no r => (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n), next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n))\n  }", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["R : CRing", "n : Nat", "I : Ideal R", "Ig : IsFinitelyGenerated {I}", "Id : \\Pi (I : Ideal R) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)", "c : Countable R.E"], "Expected type": "IsFinitelyGenerated {next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)}", "Expression": "next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)", "Premises": ["\\func IsFinitelyGenerated \\hlevels  {this : Ideal} : \\Prop => TruncP (\\Sigma (l : Array (E {S})) (IsGeneratedBy l))", "\\func next \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I1 : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\nIdeal R (\\lam (z : E {S {\\this}}) =>\n  TruncP (\\Sigma (x y : R.E) (contains {I1.1} x) (z = x R.+ y R.* pointed-countable {R.E} R.zro c n))) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "\\lemma next-fg \\hlevels  {R : CRing} {c : Countable R.E} (n : Nat) (I : \\Sigma (I : Ideal R) (IsFinitelyGenerated {I})) :\n  IsFinitelyGenerated {next {R} {c} n I} ", "\\func ideal \\hlevels  {R2 : CRing} {c1 : Countable R.E}\n  {Id1 : \\Pi (I : Ideal R2) -> IsFinitelyGenerated {I} -> \\Pi (x : R.E) -> Dec (I.contains x)} {I2 : Ideal R2}\n  {Ig2 : IsFinitelyGenerated {I2}} (_ : Nat) : \\Sigma (I : Ideal R2) (IsFinitelyGenerated {I}) \n  | {R}, {c}, {Id}, {I}, {Ig}, 0 => (I, Ig)\n  | {R}, {c}, {Id}, {I}, {Ig}, suc n =>\n  \\case Id (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) (next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n)) R.ide \\with {\n    | yes r => ideal {R} {c} {Id} {I} {Ig} n\n    | no r => (next {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n), next-fg {R} {c} n (ideal {R} {c} {Id} {I} {Ig} n))\n  }"]}
{"Context": ["t : \\Sigma (l' : Array (E {S}) l.len) (s.1 = BigSum {S} (\\new Array (E {S}) l.len (\\lam (j : Fin l.len) => l'.at j * l.at j)))", "this : Ideal", "s : E", "lg : IsGeneratedBy l", "l : Array (E {S})"], "Expected type": "s = BigSum {module} (\\new Array (\\Sigma (x : E {S}) (contains x)) l.len (\\lam (i : Fin l.len) => at {t.1} i *c (l.at i, lg.1 i)))", "Expression": "ext (t.2 *> inv (sub-BigSum ))", "Premises": ["\\func module \\hlevels  {this2 : Ideal} : LModule S (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this2 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this2 {}} {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this2 {}} {x.1} x.2)\n  | *c => \\lam (a : E {R {\\this}}) (s : E {\\this}) => (a * s.1, ideal-left {a} {s.1} s.2)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| S : BaseSet", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| contains (E {S}) : \\Prop", "| \\infixl 7 *c (E {R}) E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) "]}
{"Context": ["this : Ideal", "s : E", "lg : IsGeneratedBy l", "l : Array (E {S})"], "Expected type": "TruncP (\\Sigma (c : Array (E {S}) l.len)\n  (s = BigSum {module} (\\new Array (\\Sigma (x : E {S}) (contains x)) l.len (\\lam (i : Fin l.len) => c.at i *c (l.at i, lg.1 i)))))", "Expression": "map {?} (\\lam t => (t.1, ext $ t.2 *> inv (sub-BigSum )))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func module \\hlevels  {this2 : Ideal} : LModule S (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this2 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this2 {}} {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this2 {}} {x.1} x.2)\n  | *c => \\lam (a : E {R {\\this}}) (s : E {\\this}) => (a * s.1, ideal-left {a} {s.1} s.2)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| S : BaseSet", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| contains (E {S}) : \\Prop", "| \\infixl 7 *c (E {R}) E : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["this : Ideal", "lg : IsGeneratedBy l", "l : Array (E {S})"], "Expected type": "TruncP (\\Sigma (l : Array E) (IsGenerated {module} l))", "Expression": "inP (mkArray (\\lam j => later (l j, lg.1 j)), \\lam s => map (lg.2 s.2) (\\lam t => (t.1, ext $ t.2 *> inv (sub-BigSum ))))", "Premises": ["\\func mkArray {A : \\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\new DArray", "\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func module \\hlevels  {this2 : Ideal} : LModule S (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this2 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this2 {}} {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this2 {}} {x.1} x.2)\n  | *c => \\lam (a : E {R {\\this}}) (s : E {\\this}) => (a * s.1, ideal-left {a} {s.1} s.2)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| S : BaseSet", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type IsGenerated \\hlevels  {this : LModule} (l : Array E) : \\Prop \n  => \\Pi (x : E) -> TruncP (\\Sigma (c : Array (E {R}) l.len) (x = BigSum (\\new Array E l.len (\\lam (i : Fin l.len) => c.at i *c l.at i))))", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["y : E {\\this}", "h1 : x.contains = y.contains", "x : E {\\this}", "R : CRing"], "Expected type": "Path (\\lam (i : I) => (@) h1 i R.zro) x.contains_zro y.contains_zro", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| contains_zro : contains (zro {S})", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["y : E {\\this}", "h1 : x.contains = y.contains", "x : E {\\this}", "R : CRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i x -> (@) h1 i y -> (@) h1 i (x R.+ y)) x.contains_+ y.contains_+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)"]}
{"Context": ["y : E {\\this}", "h1 : x.contains = y.contains", "x : E {\\this}", "R : CRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {r a : R.E} -> (@) h1 i a -> (@) h1 i (r R.* a)) x.ideal-left y.ideal-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| ideal-left {r a : E {S}} (contains a) : contains (r * a)"]}
{"Context": ["l2 : Array (\\Sigma R.E M)", "l1 : Array (\\Sigma R.E M)", "r : l1 ~ l2", "R : AddMonoid", "M : \\Set", "l : Array (\\Sigma R.E M)"], "Expected type": "in~ {Array (\\Sigma R.E M)} {(~)} (l ++ l1) = in~ {Array (\\Sigma R.E M)} {(~)} (l ++ l2)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["l2 : Array (\\Sigma R.E M)", "M : \\Set", "R : AddMonoid", "l1 : Array (\\Sigma R.E M)", "l3 : Array (\\Sigma R.E M)"], "Expected type": "in~ {Array (\\Sigma R.E M)} {(~)} ((l1 ++ l2) ++ l3) = in~ {Array (\\Sigma R.E M)} {(~)} (l1 ++ l2 ++ l3)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["R : AddGroup", "l : Array (\\Sigma R.E M)", "l' : Array (\\Sigma R.E M)", "M : \\Set", "r : l ~ l'"], "Expected type": "in~ {Array (\\Sigma R.E M)} {(~)} (map {\\Sigma R.E M} {\\Sigma R.E M} (func {M} {R}) l) = in~ {Array (\\Sigma R.E M)} {(~)} (map {\\Sigma R.E M} {\\Sigma R.E M} (func {M} {R}) l')", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "\\func func \\hlevels  {M : \\Set} {R : AddGroup} (s : \\Sigma R.E M) : \\Sigma R.E M => (R.negative s.1, s.2)", "in~ A", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["M : \\Set", "R : AddGroup", "l : Array (\\Sigma R.E M)"], "Expected type": "in~ {Array (\\Sigma R.E M)} {(~)} (map {\\Sigma R.E M} {\\Sigma R.E M} (func {M} {R}) l ++ l) = in~ {Array (\\Sigma R.E M)} {(~)} nil", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func func \\hlevels  {M : \\Set} {R : AddGroup} (s : \\Sigma R.E M) : \\Sigma R.E M => (R.negative s.1, s.2)", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["R : Semiring", "l : Array (\\Sigma R.E M.E)", "M : Monoid"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)}\n  (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) ((R.ide, M.ide) :: nil) l) = in~ {Array (\\Sigma R.E M.E)} {(~)} l", "Expression": "monoidSet-ext ide-left-aux", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\lemma ide-left-aux \\hlevels  {M : Monoid} {R : Semiring} {l : Array (\\Sigma R.E M.E)} :\n  inMS~ {M.E} {R} (map {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R} (R.ide, M.ide)) l ++ nil) = inMS~ {M.E} {R} l ", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "| E : \\Set", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "| ide : E"]}
{"Context": ["R : Semiring", "l : Array (\\Sigma R.E M.E)", "M : Monoid"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)}\n  (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l ((R.ide, M.ide) :: nil)) = in~ {Array (\\Sigma R.E M.E)} {(~)} l", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set", "| ide : E"]}
{"Context": ["R : Semiring", "l2 : Array (\\Sigma R.E M.E)", "l1 : Array (\\Sigma R.E M.E)", "l3 : Array (\\Sigma R.E M.E)", "M : Monoid"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R})\n  (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l1 l2) l3) = in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l1\n  (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l2 l3))", "Expression": "~-pequiv (~-perm $ eperm-= $ pairs-assoc (\\lam {a} {b} {c} => ext (*-assoc {R}, *-assoc)))", "Premises": ["in~ A", "\\func eperm-= {A1 : \\Type} {l1 l' : Array A1} (_ : l1 = l') : EPerm {A1} l1 l' \n  | {A}, {l}, {l'}, idp => eperm-refl {A} {l}", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\func ~-pequiv {A : \\Type} {R : A -> A -> \\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)", "\\func pairs-assoc {A2 : \\Type} {f2 : A2 -> A2 -> A2} (_ : \\Pi {x y z : A2} -> f2 (f2 x y) z = f2 x (f2 y z)) {l5 l6 l7 : Array A2} :\n  pairs {A2} {A2} {A2} f2 (pairs {A2} {A2} {A2} f2 l5 l6) l7 = pairs {A2} {A2} {A2} f2 l5 (pairs {A2} {A2} {A2} f2 l6 l7) \n  | {A}, {f}, p, {nil}, {l2}, {l3} => idp {Array A} {pairs {A} {A} {A} f (pairs {A} {A} {A} f nil l2) l3}\n  | {A}, {f}, p, {:: {n} a l}, {l2}, {l3} =>\n  pairs_++-left {A} {A} {A} {f} {map {A} {A} (f a) l2} {pairs {A} {A} {A} f l l2} {l3} *> pmap2 {Array A} {Array A} {Array A} (++) {pairs {A} {A} {A} f (map {A} {A} (f a) l2) l3}\n    {map {A} {A} (f a) (pairs {A} {A} {A} f l2 l3)} (pairs_map-left {A} {f} p {a} {l2} {l3})\n    {pairs {A} {A} {A} f (pairs {A} {A} {A} f l l2) l3} {pairs {A} {A} {A} f l (pairs {A} {A} {A} f l2 l3)}\n    (pairs-assoc {A} {f} p {l} {l2} {l3})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "~-perm (EPerm {\\Sigma R.E M} l l')", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["l3 : Array (\\Sigma R.E M.E)", "R : Semiring", "l2 : Array (\\Sigma R.E M.E)", "M : Monoid", "l1 : Array (\\Sigma R.E M.E)"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) (l1 ++ l2) l3) = in~ {Array (\\Sigma R.E M.E)} {(~)}\n  (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l1 l3 ++ pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l2 l3)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["R : Semiring", "M : Monoid", "l : Array (\\Sigma R.E M.E)"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l nil) = in~ {Array (\\Sigma R.E M.E)} {(~)} nil", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["l2 : Array (\\Sigma R.E M.E)", "M : Monoid", "R : Semiring", "l : Array (\\Sigma R.E M.E)", "r : l1 ~ l2", "l1 : Array (\\Sigma R.E M.E)"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l l1) = in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l l2)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["R : Semiring", "l2 : Array (\\Sigma R.E M.E)", "r : l1 ~ l2", "M : Monoid", "l1 : Array (\\Sigma R.E M.E)", "l : Array (\\Sigma R.E M.E)"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l1 l) = in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l2 l)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["R : Semiring", "M : Monoid", "l : Array (\\Sigma R.E M.E)"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (map {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R} (R.ide, M.ide)) l ++ nil) = in~ {Array (\\Sigma R.E M.E)} {(~)} l", "Expression": "~-pequiv (~-perm $ eperm-= $ ++_nil *> exts (\\lam j => ext (ide-left {R}, ide-left)))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\func eperm-= {A1 : \\Type} {l1 l' : Array A1} (_ : l1 = l') : EPerm {A1} l1 l' \n  | {A}, {l}, {l'}, idp => eperm-refl {A} {l}", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func ~-pequiv {A : \\Type} {R : A -> A -> \\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "| ide-left {x : E} : ide * x = x", "\\func ++_nil {A2 : \\Type} {l1 : Array A2} : l1 ++ nil = l1 \n  | {A}, {nil} => idp {Array A} {nil ++ nil}\n  | {A}, {:: {n} a l} => pmap {Array A} {Array A} ((::) a) {l ++ nil} {l} (++_nil {A} {l})", "~-perm (EPerm {\\Sigma R.E M} l l')", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set", "| ide : E"]}
{"Context": ["l : Array (\\Sigma R.E M.E)", "M : CMonoid", "l' : Array (\\Sigma R.E M.E)", "R : CSemiring"], "Expected type": "in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l l') = in~ {Array (\\Sigma R.E M.E)} {(~)} (pairs {\\Sigma R.E M.E} {\\Sigma R.E M.E} {\\Sigma R.E M.E} (func {M} {R}) l' l)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func func \\hlevels  {M : Monoid} {R : Semiring} (s t : \\Sigma R.E M.E) : \\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)", "\\func pairs {A1 B1 C2 : \\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \n  | {A}, {B}, {C}, f, nil, l' => nil\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["R : Ring", "x : E {Dom {\\this}}", "y : E {Dom {\\this}}", "M : Monoid"], "Expected type": "inMS~ {M.E} {R} ((x R.+ y, M.ide) :: nil) = in~ {Array (\\Sigma R.E M.E)} {(~)} (((x, M.ide) :: nil) ++ (y, M.ide) :: nil)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "| \\infixl 6 + E E : E", "\\func inMS~ \\hlevels  {M : \\Set} {R : AddMonoid} (l : Array (\\Sigma R.E M)) : Quotient {Array (\\Sigma R.E M)} (~) \n  => in~ {Array (\\Sigma R.E M)} {(~)} l", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set", "| ide : E"]}
{"Context": ["M : \\Set", "f : M -> N", "r : l ~ l'", "g : AddMonoidHom", "N : \\Set", "l : Array (\\Sigma (E {g.Dom}) M)", "l' : Array (\\Sigma (E {g.Dom}) M)"], "Expected type": "inMS~ {N} {g.Cod}\n  (map {\\Sigma (E {g.Dom}) M} {\\Sigma (E {g.Cod}) N} (\\lam (s : \\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l) = inMS~ {N} {g.Cod}\n  (map {\\Sigma (E {g.Dom}) M} {\\Sigma (E {g.Cod}) N} (\\lam (s : \\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l')", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "| func (E {Dom}) : E {Cod}", "| Dom : BaseSet", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inMS~ \\hlevels  {M : \\Set} {R : AddMonoid} (l : Array (\\Sigma R.E M)) : Quotient {Array (\\Sigma R.E M)} (~) \n  => in~ {Array (\\Sigma R.E M)} {(~)} l", "| Cod : BaseSet", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set"]}
{"Context": ["x : E {\\this}", "l' : Array M.E", "this : KFinSet (\\Sigma (m : M.E) (msCoef ", "p : MonoidSet M.E R", "l : Array M.E", "R : AbMonoid", "Rd : DecSet R.E", "M : DecSet", "s : Index {M.E} x.1 l'"], "Expected type": "(l'.at s.1,\n  no-element {M.E} {\\lam (m : M.E) => msCoef {M} {R} p m = R.zro} (\\lam (m : M.E) => Rd.decideEq (msCoef {M} {R} p m) R.zro) {l} {s.1}) = x", "Expression": "ext s.2", "Premises": ["\\field decideEq (x y : E) : Dec (x = y)", "| E : \\Set", "\\func msCoef \\hlevels  {M : DecSet} {R : AbMonoid} (p : MonoidSet M.E R) (m : M.E) : R.E => monoidSet-coefs {M.E} {R} {(=) m} (M.decideEq m) p", "| zro : E", "\\lemma no-element {A : \\Type} {P : A -> \\Prop} (D : \\Pi (a : A) -> Dec (P a)) {l : Array A} {i : Fin (len {remove {A} {P} D l})}\n  (_ : P (at {remove {A} {P} D l} i)) : Empty ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["l' : Array M.E", "x : E {\\this}", "this : KFinSet (\\Sigma (m : M.E) (msCoef ", "p : MonoidSet M.E R", "l : Array M.E", "R : AbMonoid", "Rd : DecSet R.E", "M : DecSet", "s : Index {M.E} x.1 l'"], "Expected type": "TruncP (\\Sigma (x1 : Fin (finCard {\\this})) ((l'.at x1,\n  no-element {M.E} {\\lam (m : M.E) => msCoef {M} {R} p m = R.zro} (\\lam (m : M.E) => Rd.decideEq (msCoef {M} {R} p m) R.zro) {l} {x1}) = x))", "Expression": "inP (s.1, ext s.2)", "Premises": ["\\field decideEq (x y : E) : Dec (x = y)", "\\func msCoef \\hlevels  {M : DecSet} {R : AbMonoid} (p : MonoidSet M.E R) (m : M.E) : R.E => monoidSet-coefs {M.E} {R} {(=) m} (M.decideEq m) p", "\\lemma no-element {A : \\Type} {P : A -> \\Prop} (D : \\Pi (a : A) -> Dec (P a)) {l : Array A} {i : Fin (len {remove {A} {P} D l})}\n  (_ : P (at {remove {A} {P} D l} i)) : Empty ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "inP A", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| finCard : Nat", "| E : \\Set", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["R : CRing", "s1 : \\Sigma (q : Poly R) (f = q * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a))", "f : Poly R", "a : R.E", "s2 : \\Sigma (q : Poly R) (f = q * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a))"], "Expected type": "s1 = s2", "Expression": "ext (degree1PolyDivision-unique f a s1.2 s2.2)", "Premises": ["\\lemma degree1PolyDivision-unique \\hlevels  {R : CRing} (f : Poly R) (a : R.E) {q1 q2 : Poly R}\n  (_ : f = q1 * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a))\n  (_ : f = q2 * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a)) : q1 = q2 ", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["s1 : LDiv ", "f : Poly R", "a : R.E", "arg : s1.inv = s2.inv", "s2 : LDiv ", "R : CRing"], "Expected type": "Path (\\lam (i : I) => padd {R} ide (R.negative a) * arg @ i = f) s1.inv-right s2.inv-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| inv-right : val * inv = elem", "| \\infixl 7 * E E : E", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "padd (Poly R) R.E", "| ide : E"]}
{"Context": ["s1 : LDiv ", "f : Poly R", "a : R.E", "arg : s1.inv = s2.inv", "s2 : LDiv ", "R : CRing", "i : I"], "Expected type": "LDiv {PolyRing R} (padd {R} ide (R.negative a)) f (arg @ i) {\n  | inv-right => {?hidden}\n}", "Expression": "\\new LDiv {\n  | inv => arg @ i\n  | inv-right => prop-dpi (\\lam i => ext_coe) (inv-right {s1}) (inv-right {s2}) @ i\n}", "Premises": ["| inv-right : val * inv = elem", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "padd (Poly R) R.E", "| ide : E"]}
{"Context": ["R : Ring", "x : E", "f : LinearMap ", "U : LModule R", "l : Array U.E", "lg : IsGenerated {U} l"], "Expected type": "TruncP (\\Sigma (c : Array (Poly R) l.len)\n  (x = BigSum {polyModule {R} {U} f} (\\new Array U.E l.len (\\lam (i : Fin l.len) => c.at i *c l.at i))))", "Expression": "map {?} (\\lam s => (map (padd pzero) s.1,\n  s.2 *> pmap (BigSum {U}) (exts (\\lam j => inv $ pmap (\\lam _x => _x + _) (func-zro {f}) *> zro-left))))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| \\infixl 7 *c (E {R}) E : E", "| func (E {Dom}) : E {Cod}", "pzero", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 6 + E E : E", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| func-zro : func (zro {Dom}) = zro {Cod}", "| zro-left {x : E} : zro + x = x", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "| zro : E", "padd (Poly R) R.E", "\\func polyModule \\hlevels  {R1 : Ring} {U : LModule R1} (f : LinearMap {R1} U U) : LModule (PolyRing R1) U.E {\n  | zro => U.zro\n  | + => (U.+)\n  | negative => U.negative\n  | *c => \\lam (p : E {R {\\this}}) => poly_func {R1} {U} p f\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["R : Ring", "f : LinearMap ", "U : LModule R", "l : Array U.E", "lg : IsGenerated {U} l"], "Expected type": "TruncP (\\Sigma (l : Array E) (IsGenerated {polyModule {R} {U} f} l))", "Expression": "inP (l, \\lam x => map (lg x) (\\lam s => (map (padd pzero) s.1,\n  s.2 *> pmap (BigSum {U}) (exts (\\lam j => inv $ pmap (\\lam _x => _x + _) (func-zro {f}) *> zro-left)))))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| func (E {Dom}) : E {Cod}", "pzero", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type IsGenerated \\hlevels  {this : LModule} (l : Array E) : \\Prop \n  => \\Pi (x : E) -> TruncP (\\Sigma (c : Array (E {R}) l.len) (x = BigSum (\\new Array E l.len (\\lam (i : Fin l.len) => c.at i *c l.at i))))", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "| \\infixl 6 + E E : E", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| func-zro : func (zro {Dom}) = zro {Cod}", "| zro-left {x : E} : zro + x = x", "inP A", "| E : \\Set", "| zro : E", "padd (Poly R) R.E", "\\func polyModule \\hlevels  {R1 : Ring} {U : LModule R1} (f : LinearMap {R1} U U) : LModule (PolyRing R1) U.E {\n  | zro => U.zro\n  | + => (U.+)\n  | negative => U.negative\n  | *c => \\lam (p : E {R {\\this}}) => poly_func {R1} {U} p f\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["h1 : (\\lam (e : R.E) => in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (e, R.ide, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)} {\\Sigma (n : Nat) (pow {R} b n = R.ide)} contains_ide\n    (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)) => (n Nat.* p.1, transportInv\n      {R.E} (\\lam (x : R.E) => x = R.ide) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))) = (\\lam (e : R.E) => in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (e, R.ide, contains_ide))", "n : Nat", "b : R.E", "R : CRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.+ y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {pow-map {R} b n \u2218 locMap {R} {powers {R} (pow {R} b n)}}) (func-+ {locMap {R} {powers {R} b}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func pow-map \\hlevels  {R : CRing} (b : R.E) (n : Nat) : RingHom (LocRing {R} (powers {R} (pow {R} b n))) (LocRing {R} (powers {R} b)) {\n  | func => \\lam (p0 : E {Dom {\\this}}) => (\\case p0 \\with {\n    | in~ (x, y, c) => in~ {SType {R} (powers {R} b)}\n      {\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (x, y, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y)} {\\Sigma (n : Nat) (pow {R} b n = y)} c\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x : R.E) => x = y) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))\n    | ~-equiv x y r i =>\n    ~-pequiv {\\Sigma (_ y : R.E) (contains y)} {\\lam (x : \\Sigma (_ y : R.E) (TruncP (\\Sigma (n : Nat) (pow {R} b n = y))))\n      (y : \\Sigma (_ y : R.E) (TruncP (\\Sigma (n : Nat) (pow {R} b n = y)))) => x.1 R.* y.2 = y.1 R.* x.2}\n      {(x.1, x.2, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = x.2)} {\\Sigma (n : Nat) (pow {R} b n = x.2)} x.3\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = x.2)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x1 : R.E) => x1 = x.2) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))}\n      {(y.1, y.2, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y.2)} {\\Sigma (n : Nat) (pow {R} b n = y.2)} y.3\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y.2)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x : R.E) => x = y.2) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))}\n      r @ i\n  })\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : (\\lam (e : R.E) => in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (e, R.ide, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)} {\\Sigma (n : Nat) (pow {R} b n = R.ide)} contains_ide\n    (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)) => (n Nat.* p.1, transportInv\n      {R.E} (\\lam (x : R.E) => x = R.ide) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))) = (\\lam (e : R.E) => in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (e, R.ide, contains_ide))", "n : Nat", "b : R.E", "R : CRing"], "Expected type": "Path (\\lam (i : I) => (@) h1 i R.ide = ide) (func-ide {pow-map {R} b n \u2218 locMap {R} {powers {R} (pow {R} b n)}})\n  (func-ide {locMap {R} {powers {R} b}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func pow-map \\hlevels  {R : CRing} (b : R.E) (n : Nat) : RingHom (LocRing {R} (powers {R} (pow {R} b n))) (LocRing {R} (powers {R} b)) {\n  | func => \\lam (p0 : E {Dom {\\this}}) => (\\case p0 \\with {\n    | in~ (x, y, c) => in~ {SType {R} (powers {R} b)}\n      {\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (x, y, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y)} {\\Sigma (n : Nat) (pow {R} b n = y)} c\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x : R.E) => x = y) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))\n    | ~-equiv x y r i =>\n    ~-pequiv {\\Sigma (_ y : R.E) (contains y)} {\\lam (x : \\Sigma (_ y : R.E) (TruncP (\\Sigma (n : Nat) (pow {R} b n = y))))\n      (y : \\Sigma (_ y : R.E) (TruncP (\\Sigma (n : Nat) (pow {R} b n = y)))) => x.1 R.* y.2 = y.1 R.* x.2}\n      {(x.1, x.2, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = x.2)} {\\Sigma (n : Nat) (pow {R} b n = x.2)} x.3\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = x.2)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x1 : R.E) => x1 = x.2) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))}\n      {(y.1, y.2, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y.2)} {\\Sigma (n : Nat) (pow {R} b n = y.2)} y.3\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y.2)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x : R.E) => x = y.2) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))}\n      r @ i\n  })\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "| ide : E"]}
{"Context": ["h1 : (\\lam (e : R.E) => in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (e, R.ide, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)} {\\Sigma (n : Nat) (pow {R} b n = R.ide)} contains_ide\n    (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)) => (n Nat.* p.1, transportInv\n      {R.E} (\\lam (x : R.E) => x = R.ide) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))) = (\\lam (e : R.E) => in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (e, R.ide, contains_ide))", "n : Nat", "b : R.E", "R : CRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.* y) = (@) h1 i x * (@) h1 i y)\n  (func-* {pow-map {R} b n \u2218 locMap {R} {powers {R} (pow {R} b n)}}) (func-* {locMap {R} {powers {R} b}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 7 * E E : E", "\\func pow-map \\hlevels  {R : CRing} (b : R.E) (n : Nat) : RingHom (LocRing {R} (powers {R} (pow {R} b n))) (LocRing {R} (powers {R} b)) {\n  | func => \\lam (p0 : E {Dom {\\this}}) => (\\case p0 \\with {\n    | in~ (x, y, c) => in~ {SType {R} (powers {R} b)}\n      {\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (x, y, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y)} {\\Sigma (n : Nat) (pow {R} b n = y)} c\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x : R.E) => x = y) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))\n    | ~-equiv x y r i =>\n    ~-pequiv {\\Sigma (_ y : R.E) (contains y)} {\\lam (x : \\Sigma (_ y : R.E) (TruncP (\\Sigma (n : Nat) (pow {R} b n = y))))\n      (y : \\Sigma (_ y : R.E) (TruncP (\\Sigma (n : Nat) (pow {R} b n = y)))) => x.1 R.* y.2 = y.1 R.* x.2}\n      {(x.1, x.2, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = x.2)} {\\Sigma (n : Nat) (pow {R} b n = x.2)} x.3\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = x.2)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x1 : R.E) => x1 = x.2) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))}\n      {(y.1, y.2, map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y.2)} {\\Sigma (n : Nat) (pow {R} b n = y.2)} y.3\n        (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = y.2)) => (n Nat.* p.1, transportInv\n          {R.E} (\\lam (x : R.E) => x = y.2) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2)))}\n      r @ i\n  })\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["b : R.E", "a : R.E", "h1 : func {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}} = func {locMap {R} {powers {R} b}}", "a|b : LDiv ", "R : CRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.+ y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}}) (func-+ {locMap {R} {powers {R} b}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func div-map \\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)) {\n  | func => aux-func {R} {a} {b} a|b\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["b : R.E", "a : R.E", "h1 : func {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}} = func {locMap {R} {powers {R} b}}", "a|b : LDiv ", "R : CRing"], "Expected type": "Path (\\lam (i : I) => (@) h1 i R.ide = ide) (func-ide {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}})\n  (func-ide {locMap {R} {powers {R} b}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func div-map \\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)) {\n  | func => aux-func {R} {a} {b} a|b\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "| ide : E"]}
{"Context": ["b : R.E", "a : R.E", "h1 : func {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}} = func {locMap {R} {powers {R} b}}", "a|b : LDiv ", "R : CRing"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.* y) = (@) h1 i x * (@) h1 i y)\n  (func-* {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}}) (func-* {locMap {R} {powers {R} b}})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 7 * E E : E", "\\func div-map \\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)) {\n  | func => aux-func {R} {a} {b} a|b\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S : CRing", "h1 : (\\lam (e : R.E) => func {liftHom {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n  (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n    (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n      (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))}\n  (func {locMap {R} {powers {R} a}} e)) = func {locMap {S} {powers {S} (f.func a)} \u2218 f}", "R : CRing", "f : RingHom R S", "a : R.E"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.+ y) = (@) h1 i x + (@) h1 i y)\n  (func-+ {loc_change-of-base1 {R} {S} f {a} \u2218 locMap {R} {powers {R} a}})\n  (func-+ {locMap {S} {powers {S} (f.func a)} \u2218 f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func loc_change-of-base1 \\hlevels  {R S : CRing} (f : RingHom R S) {a : R.E} : RingHom (LocRing {R} (powers {R} a)) (LocRing {S} (powers {S} (f.func a))) {\n  | func => lift {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n    (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n      (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n        (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))\n} => liftHom {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n  (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n    (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n      (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S : CRing", "h1 : (\\lam (e : R.E) => func {liftHom {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n  (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n    (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n      (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))}\n  (func {locMap {R} {powers {R} a}} e)) = func {locMap {S} {powers {S} (f.func a)} \u2218 f}", "R : CRing", "f : RingHom R S", "a : R.E"], "Expected type": "Path (\\lam (i : I) => (@) h1 i R.ide = ide) (func-ide {loc_change-of-base1 {R} {S} f {a} \u2218 locMap {R} {powers {R} a}})\n  (func-ide {locMap {S} {powers {S} (f.func a)} \u2218 f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func loc_change-of-base1 \\hlevels  {R S : CRing} (f : RingHom R S) {a : R.E} : RingHom (LocRing {R} (powers {R} a)) (LocRing {S} (powers {S} (f.func a))) {\n  | func => lift {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n    (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n      (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n        (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))\n} => liftHom {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n  (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n    (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n      (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))", "| ide : E"]}
{"Context": ["S : CRing", "h1 : (\\lam (e : R.E) => func {liftHom {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n  (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n    (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n      (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))}\n  (func {locMap {R} {powers {R} a}} e)) = func {locMap {S} {powers {S} (f.func a)} \u2218 f}", "R : CRing", "f : RingHom R S", "a : R.E"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.* y) = (@) h1 i x * (@) h1 i y)\n  (func-* {loc_change-of-base1 {R} {S} f {a} \u2218 locMap {R} {powers {R} a}})\n  (func-* {locMap {S} {powers {S} (f.func a)} \u2218 f})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func locMap \\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\n  | func => \\lam (x : E {Dom {\\this}}) =>\n    in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func loc_change-of-base1 \\hlevels  {R S : CRing} (f : RingHom R S) {a : R.E} : RingHom (LocRing {R} (powers {R} a)) (LocRing {S} (powers {S} (f.func a))) {\n  | func => lift {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n    (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n      (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n        (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))\n} => liftHom {R} {powers {R} a} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f)\n  (powers-inv {R} {LocRing {S} (powers {S} (f.func a))} (locMap {S} {powers {S} (f.func a)} \u2218 f) {a}\n    (elem-inv {S} {powers {S} (f.func a)} (f.func a)\n      (inP {\\Sigma (n : Nat) (pow {S} (f.func a) n = f.func a)} (1, S.ide-left {f.func a}))))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p0 : inPS {J.E} (replicate {J.E} n j) = inPS {J.E} (replicate {J.E} m j) * in~ {Array J.E} {EPerm {J.E}} l", "l : Array J.E", "n : Nat", "j : J.E", "J : DecSet", "m : Nat"], "Expected type": "TruncP (EPerm {J.E} (replicate {J.E} n j) (replicate {J.E} m j ++ l))", "Expression": "unext p0", "Premises": ["\\lemma unext \\hlevels  {A : \\Set} {l l' : Array A} (_ : inPS~ {A} l = inPS~ {A} l') : TruncP (EPerm {A} l l') ", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "\\func replicate {A : \\Type} (n : Nat) (a : A) : Array A n (\\lam (_ : Fin n) => a) => \\new DArray", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["k : Fin (len {map {\\Sigma R.E (PermSet J.E)} {\\Sigma R.E (PermSet J.E)}\n  (func {PermSetMonoid J.E} {R} (R.ide, pow {PermSetMonoid J.E} (inPS {J.E} (j :: nil)) m)) l})", "n : Nat", "j : J.E", "J : DecSet", "m : Nat", "q : n < m", "l : Array (\\Sigma R.E E)"], "Expected type": "pow {PermSetMonoid J.E} (inPS {J.E} (j :: nil)) n = pow {PermSetMonoid J.E} (inPS {J.E} (j :: nil)) m * (l.at k).2 -> Empty", "Expression": "cases (l k).2 (\\case  \\with {\n  | in~ l => rewrite (permSet-pow, permSet-pow) (\\lam p0 => (\\case unext p0 \\with {\n    | inP e => linarith (EPerm_len e *> len_++)\n  }))\n})", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| M : Monoid", "\\type PermSet \\hlevels  (A : \\Set) : \\Set => Quotient {Array A} (EPerm {A})", "\\func inPS \\hlevels  {A : \\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l", "\\data Empty \\plevels  \\hlevels  ", "\\lemma len_++ {A : \\Type} {l l' : Array A} : len {l ++ l'} = l.len + l'.len ", "\\lemma unext \\hlevels  {A : \\Set} {l l' : Array A} (_ : inPS~ {A} l = inPS~ {A} l') : TruncP (EPerm {A} l l') ", "| \\infixl 7 * E E : E", "in~ A", "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : Array A1) : Array A1 \n  | {A}, nil, ys => ys\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys", "| len : Nat", "\\func \\infixl 6 + \\plevels  \\hlevels  (_ _ : Nat) : Nat \n  | x, 0 => x\n  | x, suc y => suc (x + y)", "\\lemma permSet-pow \\hlevels  {A : \\Set} {a : A} {n : Nat} : pow {PermSetMonoid A} (inPS {A} (a :: nil)) n = inPS {A} (replicate {A} n a) ", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)", "\\lemma EPerm_len {A : \\Type} {l l' : Array A} (_ : EPerm {A} l l') : l.len = l'.len ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a"]}
{"Context": ["J : \\Set", "l : Array (\\Sigma S.E (PermSet J))", "g : \\Pi (i : Fin l.len) -> \\Sigma (x : R.E) (f.func x = (l.at i).1)", "R : CRing", "S : CRing", "f : AddMonoidHom R S"], "Expected type": "TruncP (\\Sigma (x : MonoidSet (PermSet J) R) (mPoly-map {J} {R} {S} f x = in~ {Array (\\Sigma S.E (PermSet J))} {(~)} l))", "Expression": "inP (inMS (\\lam j => ((g j).1, (l j).2)), pmap inMS $ exts (\\lam j => ext ((g j).2, idp)))", "Premises": ["\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "in~ A", "\\func mPoly-map \\hlevels  {J : \\Set} {R S : CRing} (f : AddMonoidHom R S) (p : E) : E \n  => monoidSet-map {PermSet J} {PermSet J} (\\lam (x : PermSet J) => x) f p", "\\type PermSet \\hlevels  (A : \\Set) : \\Set => Quotient {Array A} (EPerm {A})", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "inP A", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set", "\\func inMS \\hlevels  {M : \\Set} {R : AddMonoid} (l : Array (\\Sigma R.E M)) : MonoidSet M R => in~ {Array (\\Sigma R.E M)} {(~)} l", "\\type MonoidSet \\hlevels  (M : \\Set) (R : AddMonoid) : \\Set => Quotient {Array (\\Sigma R.E M)} (~)", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["R : CRing", "n : Nat"], "Expected type": "in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)}\n  ((R.ide, in~ {Array (Fin (suc n))} {EPerm {Fin (suc n)}} (0 :: nil)) :: (R.zro, in~ {Array (Fin (suc n))} {EPerm {Fin (suc n)}} nil) :: nil) = in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (0 :: nil)) :: nil)", "Expression": "monoidSet-ext {?}", "Premises": ["\\lemma monoidSet-ext \\hlevels  {M : \\Set} {R : AddMonoid} {x y : Quotient {Array (\\Sigma R.E M)} (~)} (_ : x = y) : x = y ", "in~ A", "\\type PermSet \\hlevels  (A : \\Set) : \\Set => Quotient {Array A} (EPerm {A})", "\\func inPS \\hlevels  {A : \\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l", "\\data EPerm {A : \\Type} (_ _ : Array A) \\with\n  | {A}, nil, nil => eperm-nil\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "suc Nat", "\\data \\infix 5 ~ {M : \\Set} {R : AddMonoid} (_ _ : Array (\\Sigma R.E M)) \n  | ~-perm (EPerm {\\Sigma R.E M} l l')\n  | ~-sym (l' ~ l)\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\n  | ~-+ {l'' : Array (\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')", "| E : \\Set", "| zro : E", "| ide : E"]}
{"Context": ["R : Ring", "E : CRing", "f : RingHom R E", "a : E.E"], "Expected type": "TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = f.func (ide {R})))", "Expression": "polyImage-ext f a 1", "Premises": ["\\lemma polyImage-ext \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) (b : R.E) : contains (f.func b) ", "| Dom : BaseSet", "| E : \\Set", "\\func polyMapEvalRingHom \\hlevels  {R : Ring} {S : CRing} (f : RingHom R S) (a : S.E) : RingHom (PolyRing R) S {\n  | func => \\lam (x : E {Dom {\\this}}) => func {polyEvalRingHom {S} a} (func {polyMapRingHom f} x)\n} => polyEvalRingHom {S} a \u2218 polyMapRingHom f", "| func (E {Dom}) : E {Cod}", "| ide : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["a : E.E", "x : E {Dom {\\this}}", "f : RingHom R E", "R : Ring", "E : CRing"], "Expected type": "contains (f.func x)", "Expression": "polyImage-ext f a x", "Premises": ["\\lemma polyImage-ext \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) (b : R.E) : contains (f.func b) ", "| contains (E {S}) : \\Prop", "| func (E {Dom}) : E {Cod}", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)"]}
{"Context": ["R : CRing", "E : CRing", "gen : \\Sigma (l : Array E) (IsGenerated {homLModule f} l)", "f : RingHom R E", "s : \\Sigma (c : Array R.E (len {gen.1}))\n  (x.1 = BigSum {homLModule f} (\\new Array E.E (len {gen.1}) (\\lam (i : Fin (len {gen.1})) => c.at i *c at {gen.1} i)))", "x : E"], "Expected type": "x = BigSum {homLModule (corestrict {max {E1}} {R} f (\\lam (_ : R.E) => ()))}\n  (\\new Array (\\Sigma E.E (\\Sigma)) (len {gen.1}) (\\lam (i : Fin (len {gen.1})) => at {s.1} i *c (at {gen.1} i, ())))", "Expression": "ext (s.2 *> inv (sub-BigSum {max}))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| \\infixl 7 *c (E {R}) E : E", "\\func max \\hlevels  {R : Ring} : SubRing R (\\lam (_ : E {S}) => \\Sigma) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func corestrict \\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, p x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func homLModule \\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\n  | zro => zro {f.Cod}\n  | + => (+) {f.Cod}\n  | negative => negative {f.Cod}\n  | *c => \\lam (x : E {R {\\this}}) => (*) (f.func x)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) "]}
{"Context": ["R : CRing", "E : CRing", "gen : \\Sigma (l : Array E) (IsGenerated {homLModule f} l)", "f : RingHom R E", "x : E"], "Expected type": "TruncP (\\Sigma (c : Array R.E (len {gen.1})) (x = BigSum {homLModule (corestrict {max {E1}} {R} f (\\lam (_ : R.E) => ()))}\n  (\\new Array (\\Sigma E.E (\\Sigma)) (len {gen.1}) (\\lam (i : Fin (len {gen.1})) => c.at i *c (at {gen.1} i, ())))))", "Expression": "map {?} (\\lam s => (s.1, ext (s.2 *> inv (sub-BigSum {max}))))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| \\infixl 7 *c (E {R}) E : E", "\\func max \\hlevels  {R : Ring} : SubRing R (\\lam (_ : E {S}) => \\Sigma) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func corestrict \\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, p x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func homLModule \\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\n  | zro => zro {f.Cod}\n  | + => (+) {f.Cod}\n  | negative => negative {f.Cod}\n  | *c => \\lam (x : E {R {\\this}}) => (*) (f.func x)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["R : CRing", "E : CRing", "gen : \\Sigma (l : Array E) (IsGenerated {homLModule f} l)", "f : RingHom R E"], "Expected type": "TruncP (\\Sigma (l : Array E) (IsGenerated {homLModule (corestrict {max {E1}} {R} f (\\lam (_ : R.E) => ()))} l))", "Expression": "inP (map (\\lam p0 => (p0, ())) gen.1, \\lam x => map (gen.2 x.1) (\\lam s => (s.1, ext (s.2 *> inv (sub-BigSum {max})))))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func max \\hlevels  {R : Ring} : SubRing R (\\lam (_ : E {S}) => \\Sigma) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type IsGenerated \\hlevels  {this : LModule} (l : Array E) : \\Prop \n  => \\Pi (x : E) -> TruncP (\\Sigma (c : Array (E {R}) l.len) (x = BigSum (\\new Array E l.len (\\lam (i : Fin l.len) => c.at i *c l.at i))))", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func corestrict \\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, p x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "\\func homLModule \\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\n  | zro => zro {f.Cod}\n  | + => (+) {f.Cod}\n  | negative => negative {f.Cod}\n  | *c => \\lam (x : E {R {\\this}}) => (*) (f.func x)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["E : CRing", "f : RingHom R E", "a : E.E", "R : CRing"], "Expected type": "\\Pi (b : R.E) -> contains (f.func b)", "Expression": "polyImage-ext f a", "Premises": ["\\lemma polyImage-ext \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) (b : R.E) : contains (f.func b) ", "| contains (E {S}) : \\Prop", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)"]}
{"Context": ["f : RingHom R E", "q : E {Dom {polyMapEvalRingHom {R} {E1} f a}}", "qa=x : func {polyMapEvalRingHom {R} {E1} f a} q = x", "s : \\Sigma (p' : Poly R) (degree<= {R} p' t.1) (polyCoef {R} p' t.1 = R.ide) (polyEval {E1} (polyMap f p') x = E.zro)", "R : CRing", "a : E.E", "x : E {S}", "E : CRing"], "Expected type": "polyEval {cStruct {E1} (polyImage {R} {E1} f a)} (polyMap (polyImageHom {R} {E1} f a) s.1)\n  (x, inP {\\Sigma (x1 : Poly R) (func {polyMapEvalRingHom {R} {E1} f a} x1 = x)} (q, qa=x)) = zro", "Expression": "ext (inv (polyEval_polyMap {embed {polyImage f a}}) *> pmap (\\lam p0 => polyEval p0 x) (later $ polyMap-comp _ _) *> s.4)", "Premises": ["\\lemma polyEval_polyMap \\hlevels  {f : RingHom} {p : Poly f.Dom} {a : E {f.Dom}} :\n  polyEval {f.Cod} (polyMap f p) (f.func a) = f.func (polyEval {f.Dom} p a) ", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func polyEval \\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \n  | {R}, pzero, a => R.zro\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i", "| func (E {Dom}) : E {Cod}", "\\func embed \\hlevels  {this2 : SubRing} : RingHom IRing S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func cStruct \\hlevels  {R : CRing} (S1 : SubRing R) : CRing (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | zro => (zro {S.S}, contains_zro {\\new S1 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new S1 {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S.S} x.1, contains_negative {\\new S1 {}} {x.1} x.2)\n  | ide => (ide {S.S}, S.contains_ide)\n  | natCoef => natCoefImpl {ISemiring {S1}}\n} => \\new CRing {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | *-comm => {?hidden}\n}", "\\func polyMap \\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \n  | f, pzero => pzero {f.Cod}\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\n  | f, peq i => transportInv\n    {E {f.Cod}} (\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\n      f.func-zro (path (peq {f.Cod})) @ i", "\\lemma polyMap-comp \\hlevels  {A B C : AddPointed} (f : AddPointedHom A B) (g : AddPointedHom B C) {p : Poly A} :\n  polyMap g (polyMap f p) = polyMap (g \u2218 f) p ", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "\\func polyImageHom \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) : RingHom R (cStruct {E1} (polyImage {R} {E1} f a)) {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, polyImage-ext {R} {E1} f a x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "| E : \\Set", "\\func polyMapEvalRingHom \\hlevels  {R : Ring} {S : CRing} (f : RingHom R S) (a : S.E) : RingHom (PolyRing R) S {\n  | func => \\lam (x : E {Dom {\\this}}) => func {polyEvalRingHom {S} a} (func {polyMapRingHom f} x)\n} => polyEvalRingHom {S} a \u2218 polyMapRingHom f", "| zro : E", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)"]}
{"Context": ["t : \\Sigma (n : Nat) (degree<= {f.Dom} p n) (polyCoef {f.Dom} p n = ide {f.Dom})", "f : RingHom R E", "q : E {Dom {polyMapEvalRingHom {R} {E1} f a}}", "qa=x : func {polyMapEvalRingHom {R} {E1} f a} q = x", "pc : polyEval {f.Cod} (polyMap f p) a = zro {f.Cod}", "R : CRing", "x : E {S}", "a : E.E", "p : Poly f.Dom", "E : CRing"], "Expected type": "TruncP (\\Sigma (p : Poly R) (isMonic {R} p) (polyEval {cStruct {E1} (polyImage {R} {E1} f a)} (polyMap (polyImageHom {R} {E1} f a) p)\n  (x, inP {\\Sigma (x1 : Poly R) (func {polyMapEvalRingHom {R} {E1} f a} x1 = x)} (q, qa=x)) = zro))", "Expression": "map {?} (\\lam s => (s.1, inP (t.1, s.2, s.3),\n  ext $ inv (polyEval_polyMap {embed {polyImage f a}}) *> pmap (\\lam p0 => polyEval p0 x) (later $ polyMap-comp _ _) *> s.4))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\lemma polyMap-comp \\hlevels  {A B C : AddPointed} (f : AddPointedHom A B) (g : AddPointedHom B C) {p : Poly A} :\n  polyMap g (polyMap f p) = polyMap (g \u2218 f) p ", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "| E : \\Set", "| zro : E", "\\func polyMapEvalRingHom \\hlevels  {R : Ring} {S : CRing} (f : RingHom R S) (a : S.E) : RingHom (PolyRing R) S {\n  | func => \\lam (x : E {Dom {\\this}}) => func {polyEvalRingHom {S} a} (func {polyMapRingHom f} x)\n} => polyEvalRingHom {S} a \u2218 polyMapRingHom f", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\lemma polyEval_polyMap \\hlevels  {f : RingHom} {p : Poly f.Dom} {a : E {f.Dom}} :\n  polyEval {f.Cod} (polyMap f p) (f.func a) = f.func (polyEval {f.Dom} p a) ", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func polyEval \\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \n  | {R}, pzero, a => R.zro\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i", "\\func isMonic \\hlevels  {R : Ring} (p : Poly R) : \\Prop => TruncP (\\Sigma (n : Nat) (degree<= {R} p n) (polyCoef {R} p n = R.ide))", "| func (E {Dom}) : E {Cod}", "\\func embed \\hlevels  {this2 : SubRing} : RingHom IRing S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func polyMap \\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \n  | f, pzero => pzero {f.Cod}\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\n  | f, peq i => transportInv\n    {E {f.Cod}} (\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\n      f.func-zro (path (peq {f.Cod})) @ i", "\\func cStruct \\hlevels  {R : CRing} (S1 : SubRing R) : CRing (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | zro => (zro {S.S}, contains_zro {\\new S1 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new S1 {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S.S} x.1, contains_negative {\\new S1 {}} {x.1} x.2)\n  | ide => (ide {S.S}, S.contains_ide)\n  | natCoef => natCoefImpl {ISemiring {S1}}\n} => \\new CRing {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | *-comm => {?hidden}\n}", "\\func polyImageHom \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) : RingHom R (cStruct {E1} (polyImage {R} {E1} f a)) {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, polyImage-ext {R} {E1} f a x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)"]}
{"Context": ["E : CRing", "f : RingHom R E", "R : CRing", "t : \\Sigma (p : Poly R) (isMonic {R} p) (polyEval {E1} (polyMap f p) a.1 = E.zro)", "a : E {Cod {integralClosure-left {R} {E1} f}}"], "Expected type": "polyEval {IRing {integralClosure-subring {R} {E1} f}} (polyMap (integralClosure-left {R} {E1} f) t.1) a = zro", "Expression": "ext (inv (polyEval_polyMap {integralClosure-right f}) *> pmap (\\lam p0 => polyEval p0 _) (later $ polyMap-comp _ _) *> t.3)", "Premises": ["\\lemma polyEval_polyMap \\hlevels  {f : RingHom} {p : Poly f.Dom} {a : E {f.Dom}} :\n  polyEval {f.Cod} (polyMap f p) (f.func a) = f.func (polyEval {f.Dom} p a) ", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func polyEval \\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \n  | {R}, pzero, a => R.zro\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i", "\\func integralClosure-right \\hlevels  {R E1 : CRing} (f : RingHom R E1) : RingHom (IRing {integralClosure-subring {R} {E1} f}) S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => embed {integralClosure-subring {R} {E1} f}", "\\func integralClosure-left \\hlevels  {R E1 : CRing} (f : RingHom R E1) : RingHom R (IRing {integralClosure-subring {R} {E1} f}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, integral_image f x)\n} => corestrict {integralClosure-subring {R} {E1} f} {R} f (integral_image f)", "\\func integralClosure-subring \\hlevels  {R E1 : CRing} (f : RingHom R E1) : SubRing E1 (isIntegral f) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\func polyMap \\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \n  | f, pzero => pzero {f.Cod}\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\n  | f, peq i => transportInv\n    {E {f.Cod}} (\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\n      f.func-zro (path (peq {f.Cod})) @ i", "\\lemma polyMap-comp \\hlevels  {A B C : AddPointed} (f : AddPointedHom A B) (g : AddPointedHom B C) {p : Poly A} :\n  polyMap g (polyMap f p) = polyMap (g \u2218 f) p ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func IRing \\hlevels  {this : SubRing} : Ring (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this {}} {x.1} x.2)\n  | ide => (ide {S}, contains_ide)\n  | natCoef => natCoefImpl {ISemiring}\n} => \\new Ring {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n}", "| E : \\Set", "| zro : E"]}
{"Context": ["E : CRing", "R : CRing", "f : RingHom R E", "a : E {Cod {integralClosure-left {R} {E1} f}}"], "Expected type": "TruncP (\\Sigma (p : Poly R) (isMonic {R} p)\n  (polyEval {IRing {integralClosure-subring {R} {E1} f}} (polyMap (integralClosure-left {R} {E1} f) p) a = zro))", "Expression": "map {?} (\\lam t => (t.1, t.2,\n  ext $ inv (polyEval_polyMap {integralClosure-right f}) *> pmap (\\lam p0 => polyEval p0 _) (later $ polyMap-comp _ _) *> t.3))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\lemma polyEval_polyMap \\hlevels  {f : RingHom} {p : Poly f.Dom} {a : E {f.Dom}} :\n  polyEval {f.Cod} (polyMap f p) (f.func a) = f.func (polyEval {f.Dom} p a) ", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func polyEval \\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \n  | {R}, pzero, a => R.zro\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i", "\\func isMonic \\hlevels  {R : Ring} (p : Poly R) : \\Prop => TruncP (\\Sigma (n : Nat) (degree<= {R} p n) (polyCoef {R} p n = R.ide))", "\\func integralClosure-right \\hlevels  {R E1 : CRing} (f : RingHom R E1) : RingHom (IRing {integralClosure-subring {R} {E1} f}) S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => embed {integralClosure-subring {R} {E1} f}", "\\func integralClosure-left \\hlevels  {R E1 : CRing} (f : RingHom R E1) : RingHom R (IRing {integralClosure-subring {R} {E1} f}) {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, integral_image f x)\n} => corestrict {integralClosure-subring {R} {E1} f} {R} f (integral_image f)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func polyMap \\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \n  | f, pzero => pzero {f.Cod}\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\n  | f, peq i => transportInv\n    {E {f.Cod}} (\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\n      f.func-zro (path (peq {f.Cod})) @ i", "\\func integralClosure-subring \\hlevels  {R E1 : CRing} (f : RingHom R E1) : SubRing E1 (isIntegral f) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\lemma polyMap-comp \\hlevels  {A B C : AddPointed} (f : AddPointedHom A B) (g : AddPointedHom B C) {p : Poly A} :\n  polyMap g (polyMap f p) = polyMap (g \u2218 f) p ", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func IRing \\hlevels  {this : SubRing} : Ring (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this {}} {x.1} x.2)\n  | ide => (ide {S}, contains_ide)\n  | natCoef => natCoefImpl {ISemiring}\n} => \\new Ring {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n}", "| E : \\Set", "| zro : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["E : CRing", "R : CRing", "a : E.E", "e : polyEval {E1} (polyMap f p) a = E.zro", "c : contains q", "f : RingHom R E", "p : Poly R", "q : E {S}"], "Expected type": "func {polyImageHomPoly {R} {E1} f a} q = zro", "Expression": "ext (unfold (\\case closure1-lem.1 c \\with {\n  | inP (d, q=pd) => rewrite (q=pd, func-* {polyMapEvalRingHom f a}) equation\n}))", "Premises": ["\\lemma closure1-lem \\hlevels  {R : CRing} {a b : R.E} : contains b <-> TruncP (\\Sigma (c : R.E) (b = a R.* c)) ", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "| M : Monoid", "| zro : E", "\\func polyMapEvalRingHom \\hlevels  {R : Ring} {S : CRing} (f : RingHom R S) (a : S.E) : RingHom (PolyRing R) S {\n  | func => \\lam (x : E {Dom {\\this}}) => func {polyEvalRingHom {S} a} (func {polyMapRingHom f} x)\n} => polyEvalRingHom {S} a \u2218 polyMapRingHom f", "| \\infixl 7 * E E : E", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "| func (E {Dom}) : E {Cod}", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)", "\\func polyImageHomPoly \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) : RingHom (PolyRing R) (cStruct {E1} (polyImage {R} {E1} f a)) {\n  | func => \\lam (p : E {Dom {\\this}}) => (polyEval {E1} (polyMap f p) a, inP {\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}})\n    (func {polyMapEvalRingHom {R} {E1} f a} x = polyEval {E1} (polyMap f p) a)}\n    (p, idp {E.E} {func {polyMapEvalRingHom {R} {E1} f a} p}))\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func polyMap \\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \n  | f, pzero => pzero {f.Cod}\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\n  | f, peq i => transportInv\n    {E {f.Cod}} (\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\n      f.func-zro (path (peq {f.Cod})) @ i"]}
{"Context": ["R : CRing", "s : E", "p : I <= I * I", "I : Ideal R"], "Expected type": "TruncP (\\Sigma (l : Array (\\Sigma (x : R.E) (contains {I} x) (\\Sigma (x : R.E) (I.contains x))))\n  (s = BigSum {module {I}} (map {\\Sigma (x : R.E) (contains {I} x) (\\Sigma (x : R.E) (I.contains x))} {\\Sigma (x : R.E) (I.contains x)}\n    (\\lam (s : \\Sigma (x : R.E) (contains {I} x) (\\Sigma (x : R.E) (I.contains x))) => s.1 *c s.3) l)))", "Expression": "map {?} (\\lam t => (map (later (\\lam s => (s.1 * s.2.1, ideal-left s.2.3, (s.2.2, s.2.4)))) t.1,\n  ext $ t.2 *> pmap (BigSum {R}) (exts (\\lam j => inv *-assoc)) *> inv sub-BigSum))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func module \\hlevels  {this2 : Ideal} : LModule S (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this2 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this2 {}} {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this2 {}} {x.1} x.2)\n  | *c => \\lam (a : E {R {\\this}}) (s : E {\\this}) => (a * s.1, ideal-left {a} {s.1} s.2)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| contains (E {S}) : \\Prop", "| \\infixl 7 *c (E {R}) E : E", "| ideal-left {r a : E {S}} (contains a) : contains (r * a)", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| E : \\Set", "\\lemma sub-BigSum \\hlevels  {this : SubAddMonoid} {l : Array E} :\n  (BigSum {IAddMonoid} l).1 = BigSum {S} (map {\\Sigma (x : E {S}) (contains x)} {E {S}} (\\lam (p0 : \\Sigma (x : E {S}) (contains x)) => p0.1) l) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["this : AAlgebra R1 (\\Sigma R.E A.E) ", "R : CRing", "A : PseudoAlgebra R", "r : E {R {\\this}}", "a : E {\\this}", "b : E {\\this}"], "Expected type": "r *c (a * b) = r *c a * b", "Expression": "ext (inv *-assoc,\n  rewrite (*c-ldistr, *c-ldistr, *c-assoc, *c-comm-left) $ abGroup $ toZero {A} $ inv *c-assoc *> pmap (\\lam _x => _x *c _) *-comm *> *c-assoc)", "Premises": ["\\lemma toZero \\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b", "| \\infixl 7 * E E : E", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| \\infixl 7 *c (E {R}) E : E", "| *c-comm-left {r : E {R}} {a b : E} : r *c (a * b) = r *c a * b", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| *-comm {x y : E} : x * y = y * x", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}"]}
{"Context": ["A : PseudoAlgebra R", "R : CRing"], "Expected type": "AddGroupHom A (UnitAlgebra R A) {\n  | func => \\lam (x : E {Dom {\\this}}) => (R.zro, x)\n  | func-+ => {?hidden}\n}", "Expression": "\\new AddGroupHom {\n  | Dom => A\n  | Cod => UnitAlgebra R A\n  | func => \\lam x => (0, x)\n  | func-+ => ext (inv zro-left, idp)\n}", "Premises": ["| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| zro-left {x : E} : zro + x = x", "| Cod : BaseSet", "| E : \\Set", "| zro : E", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["n : Nat", "x : E {\\this}", "R : Ring"], "Expected type": "FinSum {R} {PairsFinSet n} (\\lam (s1 : E {PairsFinSet n}) => coef {R} R.ide s1.1 R.* x s1.2) = coef {R} R.ide 0 R.* x n", "Expression": "FinSum-unique {R} (later (0, n, idp))\n  (\\lam s s/=0 => pmap (\\lam _x => _x * _) (coef_/=0 (\\lam p => s/=0 $ ext (p, pmap (\\lam _x => _x + _) (inv p) *> s.3))) *> zro_*-left {R})", "Premises": ["\\lemma FinSum-unique {this : AbMonoid} {J : FinSet} {a : J.E -> E} (j : J.E) (_ : \\Pi (j' : J.E) -> j' /= j -> a j' = zro) :\n  FinSum {J} a = a j ", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\lemma coef_/=0 \\hlevels  {R : Ring} {a : R.E} {n : Nat} (_ : n /= 0) : coef {R} a n = R.zro ", "| zro_*-left {x : E} : zro * x = zro", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "\\func coef \\hlevels  {R1 : Ring} (_ : R.E) (_ : Nat) : R.E \n  | {R}, a, 0 => a\n  | {R}, a, suc n => R.zro", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1", "\\lemma PairsFinSet (n : Nat) : FinSet (\\Sigma (i j : Nat) (\\property (i + j = n))) {\n  | finCard => suc n\n} ", "| E : \\Set", "| zro : E", "| ide : E"]}
{"Context": ["R : Ring", "x : E {\\this}", "n : Nat"], "Expected type": "FinSum {R} {PairsFinSet n} (\\lam (s1 : E {PairsFinSet n}) => x s1.1 R.* coef {R} R.ide s1.2) = x n R.* coef {R} R.ide 0", "Expression": "FinSum-unique {R} (later (n, 0, idp))\n  (\\lam s s/=0 => pmap ((*) _) (coef_/=0 (\\lam p => s/=0 $ ext (pmap ((+) _) (inv p) *> s.3, p))) *> zro_*-right {R})", "Premises": ["\\lemma FinSum-unique {this : AbMonoid} {J : FinSet} {a : J.E -> E} (j : J.E) (_ : \\Pi (j' : J.E) -> j' /= j -> a j' = zro) :\n  FinSum {J} a = a j ", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\lemma coef_/=0 \\hlevels  {R : Ring} {a : R.E} {n : Nat} (_ : n /= 0) : coef {R} a n = R.zro ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "\\func coef \\hlevels  {R1 : Ring} (_ : R.E) (_ : Nat) : R.E \n  | {R}, a, 0 => a\n  | {R}, a, suc n => R.zro", "\\func \\infix 1 /= {A : \\Type} (a a' : A) : \\Prop => Not (a = a')", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1", "\\lemma PairsFinSet (n : Nat) : FinSet (\\Sigma (i j : Nat) (\\property (i + j = n))) {\n  | finCard => suc n\n} ", "| E : \\Set", "| zro : E", "| ide : E", "| zro_*-right {x : E} : x * zro = zro"]}
{"Context": ["s : A {\\this}", "n : Nat", "this : QEquiv "], "Expected type": "ret {\\this} (\n  \\let ((i, j, i+j=n), (k, m, k+m=i)) => s\n  \\in ((k, m + j,\n        inv {Nat} {s.2.1 + s.2.2 + s.1.2} {k + (m + j)} (+-assoc {s.2.1} {s.2.2} {s.1.2}) *> pmap {Nat} {Nat} (\\lam (_x : Nat) => _x + j) {k + m} {i} k+m=i *> i+j=n),\n        (m, j, idp {Nat} {m + j}))) = s", "Expression": "PairsFinSet-ext1 {?} idp idp idp", "Premises": ["| ret B : A", "| \\infixl 6 + E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "\\lemma PairsFinSet-ext1 {n : Nat} {x y : \\Sigma (s : E) E} (_ : x.1.1 = y.1.1) (_ : x.1.2 = y.1.2) (_ : x.2.1 = y.2.1) (_ : x.2.2 = y.2.2) : x = y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["s : B {\\this}", "n : Nat", "this : QEquiv "], "Expected type": "(\n  \\let ((i, j, i+j=n), (k, m, k+m=i)) => sec {\\this} s\n  \\in ((k, m + j, inv {Nat} {(sec {\\this} s).2.1 + (sec {\\this} s).2.2 + (sec {\\this} s).1.2} {k + (m + j)}\n        (+-assoc {(sec {\\this} s).2.1} {(sec {\\this} s).2.2} {(sec {\\this} s).1.2}) *> pmap {Nat} {Nat} (\\lam (_x : Nat) => _x + j) {k + m} {i} k+m=i *> i+j=n),\n        (m, j, idp {Nat} {m + j}))) = s", "Expression": "PairsFinSet-ext2 idp {?} idp idp", "Premises": ["\\lemma PairsFinSet-ext2 {n : Nat} {x y : \\Sigma (s : E) E} (_ : x.1.1 = y.1.1) (_ : x.1.2 = y.1.2) (_ : x.2.1 = y.2.1) (_ : x.2.2 = y.2.2) : x = y ", "| \\infixl 6 + E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "| sec B : A", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["n<=i : n <= i", "i+j=n+m : i + j = n + m", "m<=j : m <= j", "j : Nat", "n : Nat", "m : Nat", "i : Nat"], "Expected type": "(i, j, i+j=n+m) = (n, m, idp {Nat} {n + m})", "Expression": "ext (\n  \\have j=m => <=-antisymmetric (<=_cancel-left i $ =_<= i+j=n+m <=\u2218 <=_+ {NatSemiring} n<=i <=-refl) m<=j\n  \\in (cancel-right j $ i+j=n+m *> pmap ((+) n) (inv j=m), j=m))", "Premises": ["| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y", "| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "\\lemma =_<= \\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\lemma cancel-right \\plevels  \\hlevels  {n m : Nat} (k : Nat) (_ : n + k = m + k) : n = m ", "| <=-refl {x : E} : x <= x", "| \\infixl 6 + E E : E", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\lemma <=_cancel-left \\plevels  \\hlevels  (n : Nat) {m k : Nat} (_ : n + m <= n + k) : m <= k ", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "\\func \\infixl 6 + \\plevels  \\hlevels  (_ _ : Nat) : Nat \n  | x, 0 => x\n  | x, suc y => suc (x + y)"]}
{"Context": ["x : E {S}", "S : CRing", "f : RingHom R S", "y : E {S}", "R : CRing"], "Expected type": "func {R} {S1} {f}\n  (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} x + in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} y) = func {R} {S1} {f} (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} x) + func {R} {S1} {f} (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} y)", "Expression": "ext (rewrite (func-+ {f}) idp)", "Premises": ["| S : BaseSet", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "| contains (E {S}) : \\Prop", "in~ A", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| \\infixl 6 + E E : E", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : \\Set", "\\func func {R1 : CRing} {S3 : CRing} {f2 : RingHom R1 S3} (_ : E) : E \n  | {R}, {S1}, {f}, in~ a => (f.func a, inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func a)} (a, idp {S.E} {f.func a}))\n  | {R}, {S1}, {f}, ~-equiv x y r i => \n    \\have arg => inv {S.E} {f.func y} {f.func x} (transport {S.E} ((=) (f.func y)) {f.func x S.+ S.zro} {f.func x} (S.zro-right {f.func x})\n            (transport {S.E} (\\lam (x1 : S.E) => f.func y = f.func x S.+ x1) {S.negative (f.func y) S.+ f.func y} {S.zro}\n              (S.negative-left {f.func y}) (transport {S.E} ((=) (f.func y)) {f.func x S.+ S.negative (f.func y) S.+ f.func y}\n                {f.func x S.+ (S.negative (f.func y) S.+ f.func y)} (S.+-assoc {f.func x} {S.negative (f.func y)} {f.func y})\n                (transport {S.E} (\\lam (x1 : S.E) => x1 = f.func x - f.func y S.+ f.func y) {S.zro S.+ f.func y} {f.func y} (S.zro-left {f.func y})\n                  (pmap {S.E} {S.E} (\\lam (_x : S.E) => _x S.+ f.func y) {S.zro} {f.func x - f.func y}\n                    (transport {S.E} (\\lam (x1 : E {f.Cod}) => x1 = f.func x - f.func y) {f.func (x - y)} {S.zro} r (func-minus {f} {x} {y})))))))\n    \\in (arg @ i, prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {f.Dom}) (f.func x = arg @ i)))\n          (inP {\\Sigma (x1 : E {f.Dom}) (f.func x1 = f.func x)} (x, idp {S.E} {f.func x}))\n          (inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func y)} (y, idp {S.E} {f.func y})) @ i)"]}
{"Context": ["S : CRing", "x : E {S}", "f : RingHom R S", "y : E {S}", "R : CRing"], "Expected type": "func {R} {S1} {f}\n  (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} x * in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} y) = func {R} {S1} {f} (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} x) * func {R} {S1} {f} (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} y)", "Expression": "ext (rewrite (func-* {f}) idp)", "Premises": ["| \\infixl 7 * E E : E", "| S : BaseSet", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "| contains (E {S}) : \\Prop", "in~ A", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| E : \\Set", "\\func func {R1 : CRing} {S3 : CRing} {f2 : RingHom R1 S3} (_ : E) : E \n  | {R}, {S1}, {f}, in~ a => (f.func a, inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func a)} (a, idp {S.E} {f.func a}))\n  | {R}, {S1}, {f}, ~-equiv x y r i => \n    \\have arg => inv {S.E} {f.func y} {f.func x} (transport {S.E} ((=) (f.func y)) {f.func x S.+ S.zro} {f.func x} (S.zro-right {f.func x})\n            (transport {S.E} (\\lam (x1 : S.E) => f.func y = f.func x S.+ x1) {S.negative (f.func y) S.+ f.func y} {S.zro}\n              (S.negative-left {f.func y}) (transport {S.E} ((=) (f.func y)) {f.func x S.+ S.negative (f.func y) S.+ f.func y}\n                {f.func x S.+ (S.negative (f.func y) S.+ f.func y)} (S.+-assoc {f.func x} {S.negative (f.func y)} {f.func y})\n                (transport {S.E} (\\lam (x1 : S.E) => x1 = f.func x - f.func y S.+ f.func y) {S.zro S.+ f.func y} {f.func y} (S.zro-left {f.func y})\n                  (pmap {S.E} {S.E} (\\lam (_x : S.E) => _x S.+ f.func y) {S.zro} {f.func x - f.func y}\n                    (transport {S.E} (\\lam (x1 : E {f.Cod}) => x1 = f.func x - f.func y) {f.func (x - y)} {S.zro} r (func-minus {f} {x} {y})))))))\n    \\in (arg @ i, prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {f.Dom}) (f.func x = arg @ i)))\n          (inP {\\Sigma (x1 : E {f.Dom}) (f.func x1 = f.func x)} (x, idp {S.E} {f.func x}))\n          (inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func y)} (y, idp {S.E} {f.func y})) @ i)"]}
{"Context": ["S : CRing", "y : E {S}", "x : E {S}", "R : CRing", "r : contains (x - y)", "f : RingHom R S"], "Expected type": "(f.func x, inP {\\Sigma (x1 : E {f.Dom}) (f.func x1 = f.func x)} (x, idp {S.E} {f.func x})) = (f.func y, inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func y)} (y, idp {S.E} {f.func y}))", "Expression": "ext (inv $ rewrite (zro-left, +-assoc, negative-left, zro-right) in pmap (\\lam _x => _x + {S} f y) (rewrite r in func-minus {f} {x} {y}))", "Premises": ["\\lemma func-minus \\hlevels  {this : AddGroupHom} {x y : E {Dom}} : func (x - y) = func x - func y ", "| zro-right {x : E} : x + zro = x", "| negative E : E", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "| zro-left {x : E} : zro + x = x", "| E : \\Set", "| zro : E", "| S : BaseSet", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| negative-left {x : E} : negative x + x = zro", "| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "inP A"]}
{"Context": ["S : CRing", "x : S.E", "r : R.E", "f : RingHom R S", "A : f.func r = x", "R : CRing"], "Expected type": "TruncP (\\Sigma (x1 : Type (KernelC {R} {S} f))\n  (ringKerImageHom.func {R} {S} {f} x1 = (x, inP {\\Sigma (x1 : R.E) (f.func x1 = x)} (r, A))))", "Expression": "inP (in~ r, ext A)", "Premises": ["| S : BaseSet", "in~ A", "\\func KernelC \\hlevels  {R : CRing} {S1 : Ring} (f : RingHom R S1) : Ideal R (\\lam (x : E {S}) => f.func x = zro {f.Cod}) => \\new Ideal {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\type Type \\hlevels  (I : Ideal) : \\Set => Quotient {E {I.S}} (\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b))", "inP A", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I", "\\func func {R1 : CRing} {S3 : CRing} {f2 : RingHom R1 S3} (_ : E) : E \n  | {R}, {S1}, {f}, in~ a => (f.func a, inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func a)} (a, idp {S.E} {f.func a}))\n  | {R}, {S1}, {f}, ~-equiv x y r i => \n    \\have arg => inv {S.E} {f.func y} {f.func x} (transport {S.E} ((=) (f.func y)) {f.func x S.+ S.zro} {f.func x} (S.zro-right {f.func x})\n            (transport {S.E} (\\lam (x1 : S.E) => f.func y = f.func x S.+ x1) {S.negative (f.func y) S.+ f.func y} {S.zro}\n              (S.negative-left {f.func y}) (transport {S.E} ((=) (f.func y)) {f.func x S.+ S.negative (f.func y) S.+ f.func y}\n                {f.func x S.+ (S.negative (f.func y) S.+ f.func y)} (S.+-assoc {f.func x} {S.negative (f.func y)} {f.func y})\n                (transport {S.E} (\\lam (x1 : S.E) => x1 = f.func x - f.func y S.+ f.func y) {S.zro S.+ f.func y} {f.func y} (S.zro-left {f.func y})\n                  (pmap {S.E} {S.E} (\\lam (_x : S.E) => _x S.+ f.func y) {S.zro} {f.func x - f.func y}\n                    (transport {S.E} (\\lam (x1 : E {f.Cod}) => x1 = f.func x - f.func y) {f.func (x - y)} {S.zro} r (func-minus {f} {x} {y})))))))\n    \\in (arg @ i, prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {f.Dom}) (f.func x = arg @ i)))\n          (inP {\\Sigma (x1 : E {f.Dom}) (f.func x1 = f.func x)} (x, idp {S.E} {f.func x}))\n          (inP {\\Sigma (x : E {f.Dom}) (f.func x = f.func y)} (y, idp {S.E} {f.func y})) @ i)"]}
{"Context": ["I : HomogenIdeal", "x : E {I.S}", "Ix : I.contains x", "l_f_p : \\Sigma (l : Array (E {I.S})) (\\Pi (n : Fin l.len) -> isHomogen {I.S} (l.at n) n) (BigSum {I.S} l = x)", "U : E {I.S} -> \\Prop"], "Expected type": "TruncP (\\Sigma (l : Array (\\Sigma (E {I.S}) (\\Sigma (x : E {I.S}) (U x))))\n  (x = BigSum {I.S} (map {\\Sigma (E {I.S}) (\\Sigma (x : E {I.S}) (U x))} {E {I.S}}\n    (\\lam (p : \\Sigma (E {I.S}) (\\Sigma (x : E {I.S}) (U x))) => p.1 * p.2.1) l)))", "Expression": "map {?} (\\lam p0 => (\n  \\let (l, f, p) => p0\n  \\in (mkArray (\\lam j => later (1, (l j, inP (l, f, j, idp, rewrite p Ix)))),\n        inv p *> pmap BigSum (exts (\\lam j => inv ide-left)))))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func mkArray {A : \\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\new DArray", "| S : BaseSet", "| \\infixl 7 * E E : E", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func map {A B : \\Type} (f : A -> B) (as : Array A) : Array B as.len (\\lam (i : Fin as.len) => f (as.at i)) => \\new DArray", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| ide-left {x : E} : ide * x = x", "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)", "inP A", "| E : \\Set", "| ide : E", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["S : SubRing R", "this : Contr E (c.center, transportInv ", "c : Contr R.E", "x : A {\\this}"], "Expected type": "center {\\this} = x", "Expression": "ext (contraction {c} _)", "Premises": ["| center : A", "| contraction (a' : A) : center = a'", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : SubRing", "f : RingHom R S", "R : Ring", "p : \\Pi (x : R.E) -> contains (f.func x)"], "Expected type": "RingHom R IRing {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, p x)\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "Expression": "\\new RingHom {\n  | Dom => R\n  | Cod => IRing \n  | func => \\lam x => (f x, p x)\n  | func-+ => ext (func-+ {f})\n  | func-ide => ext (func-ide {f})\n  | func-* => ext (func-* {f})\n}", "Premises": ["| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "| \\infixl 7 * E E : E", "| func-ide : func (ide {Dom}) = ide {Cod}", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "| func (E {Dom}) : E {Cod}", "| Dom : BaseSet", "| \\infixl 6 + E E : E", "\\func IRing \\hlevels  {this : SubRing} : Ring (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this {}} {x.1} x.2)\n  | ide => (ide {S}, contains_ide)\n  | natCoef => natCoefImpl {ISemiring}\n} => \\new Ring {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n}", "| Cod : BaseSet", "| E : \\Set", "| ide : E"]}
{"Context": ["h2 : (R.+) = (S.+)", "S : Ring X", "R : Ring X", "X : \\Set", "h1 : R.zro = S.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i (h1 @ i) x = x) R.zro-left S.zro-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-left {x : E} : zro + x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (R.+) = (S.+)", "S : Ring X", "R : Ring X", "X : \\Set", "h1 : R.zro = S.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i x (h1 @ i) = x) R.zro-right S.zro-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| zro-right {x : E} : x + zro = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (R.+) = (S.+)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h2 i ((@) h2 i x y) z = (@) h2 i x ((@) h2 i y z)) R.+-assoc S.+-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (R.+) = (S.+)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : X} -> (@) h2 i x y = (@) h2 i y x) R.+-comm S.+-comm", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| +-comm {x y : E} : x + y = y + x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h3 : (R.*) = (S.*)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h3 i ((@) h3 i x y) z = (@) h3 i x ((@) h3 i y z)) R.*-assoc S.*-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| *-assoc {x y z : E} : x * y * z = x * (y * z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (R.+) = (S.+)", "h3 : (R.*) = (S.*)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h3 i x ((@) h2 i y z) = (@) h2 i ((@) h3 i x y) ((@) h3 i x z)) R.ldistr S.ldistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ldistr {x y z : E} : x * (y + z) = x * y + x * z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h2 : (R.+) = (S.+)", "h3 : (R.*) = (S.*)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : X} -> (@) h3 i ((@) h2 i x y) z = (@) h2 i ((@) h3 i x z) ((@) h3 i y z)) R.rdistr S.rdistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| rdistr {x y z : E} : (x + y) * z = x * z + y * z"]}
{"Context": ["h2 : (R.+) = (S.+)", "h4 : R.negative = S.negative", "S : Ring X", "R : Ring X", "X : \\Set", "h1 : R.zro = S.zro"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h2 i ((@) h4 i x) x = h1 @ i) R.negative-left S.negative-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| negative-left {x : E} : negative x + x = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h5 : R.ide = S.ide", "h3 : (R.*) = (S.*)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h3 i (h5 @ i) x = x) R.ide-left S.ide-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-left {x : E} : ide * x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h5 : R.ide = S.ide", "h3 : (R.*) = (S.*)", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : X} -> (@) h3 i x (h5 @ i) = x) R.ide-right S.ide-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| ide-right {x : E} : x * ide = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h6 : R.natCoef = S.natCoef", "S : Ring X", "R : Ring X", "X : \\Set", "h1 : R.zro = S.zro"], "Expected type": "Path (\\lam (i : I) => (@) h6 i 0 = h1 @ i) R.natCoefZero S.natCoefZero", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| natCoefZero : natCoef 0 = zro", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' "]}
{"Context": ["h6 : R.natCoef = S.natCoef", "h2 : (R.+) = (S.+)", "h5 : R.ide = S.ide", "S : Ring X", "R : Ring X", "X : \\Set"], "Expected type": "Path (\\lam (i : I) => \\Pi (n : Nat) -> (@) h6 i (suc n) = (@) h2 i ((@) h6 i n) (h5 @ i)) R.natCoefSuc S.natCoefSuc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "| natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["h1 : func {f_iso.hinv \u2218 f_iso.f} = func {id {f_iso.C} f_iso.dom}", "this : Iso "], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {dom {\\this}}) = ide {dom {\\this}}) (func-ide {hinv {\\this} \u2218 f {\\this}})\n  (func-ide {id {C {\\this}} (dom {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| dom : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod", "| ide : E"]}
{"Context": ["this : Iso ", "h1 : func {f_iso.f \u2218 f_iso.hinv} = func {id {f_iso.C} f_iso.cod}"], "Expected type": "Path (\\lam (i : I) => (@) h1 i (ide {cod {\\this}}) = ide {cod {\\this}}) (func-ide {f {\\this} \u2218 hinv {\\this}})\n  (func-ide {id {C {\\this}} (cod {\\this})})", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| cod : Ob {C}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| C : Precat", "| f : Hom {C} dom cod", "| ide : E"]}
{"Context": ["f : RingHom G H", "p : Iso ", "G : Ring", "H : Ring"], "Expected type": "Iso {GroupCat} {toGroup G} {toGroup H} (toGroupHom {G} {H} f1) {\n  | hinv => toGroupHom {H} {G} p.hinv\n  | hinv_f => {?hidden}\n  | f_hinv => {?hidden}\n}", "Expression": "\\new Iso {\n  | hinv => toGroupHom hinv\n  | hinv_f => exts (\\lam e i => hinv_f {p} i e)\n  | f_hinv => exts (\\lam e i => f_hinv {p} i e)\n}", "Premises": ["| Hom Ob Ob : \\Set", "| hinv_f : hinv \u2218 f = id {C} dom", "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func toGroup \\hlevels  (G : AddGroup) : Group G.E {\n  | ide => G.zro\n  | * => (G.+)\n  | inverse => G.negative\n} => \\new Group {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse-left => {?hidden}\n  | inverse-right => {?hidden}\n}", "\\func toGroupHom \\hlevels  {G H : AddGroup} (f : AddGroupHom G H) : GroupHom (toGroup G) (toGroup H) {\n  | func => f.func\n} => \\new GroupHom {\n  | func-* => {?hidden}\n}", "| hinv : Hom {C} cod dom", "| id (X : Ob) : Hom X X", "| C : Precat", "| f : Hom {C} dom cod", "| f_hinv : f \u2218 hinv = id {C} cod"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {Image=Cod {R} {S} f p @ i}} -> zro {Image=Cod {R} {S} f p @ i} + x = x) zro-left S.zro-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 6 + E E : E", "| zro-left {x : E} : zro + x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {Image=Cod {R} {S} f p @ i}} -> x + zro {Image=Cod {R} {S} f p @ i} = x) zro-right\n  S.zro-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 6 + E E : E", "| zro-right {x : E} : x + zro = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : E {Image=Cod {R} {S} f p @ i}} -> x + y + z = x + (y + z)) +-assoc S.+-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 6 + E E : E", "| +-assoc {x y z : E} : x + y + z = x + (y + z)", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {Image=Cod {R} {S} f p @ i}} -> x + y = y + x) +-comm S.+-comm", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| +-comm {x y : E} : x + y = y + x", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : E {Image=Cod {R} {S} f p @ i}} -> x * y * z = x * (y * z)) *-assoc S.*-assoc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| *-assoc {x y z : E} : x * y * z = x * (y * z)", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : E {Image=Cod {R} {S} f p @ i}} -> x * (y + z) = x * y + x * z) ldistr S.ldistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 7 * E E : E", "| \\infixl 6 + E E : E", "| ldistr {x y z : E} : x * (y + z) = x * y + x * z", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y z : E {Image=Cod {R} {S} f p @ i}} -> (x + y) * z = x * z + y * z) rdistr S.rdistr", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 7 * E E : E", "| \\infixl 6 + E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| rdistr {x y z : E} : (x + y) * z = x * z + y * z"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {Image=Cod {R} {S} f p @ i}} -> negative {Image=Cod {R} {S} f p @ i} x + x = zro {Image=Cod {R} {S} f p @ i})\n  negative-left S.negative-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| negative-left {x : E} : negative x + x = zro", "| \\infixl 6 + E E : E", "| negative E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| zro : E", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {Image=Cod {R} {S} f p @ i}} -> ide {Image=Cod {R} {S} f p @ i} * x = x) ide-left S.ide-left", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 7 * E E : E", "| ide-left {x : E} : ide * x = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x : E {Image=Cod {R} {S} f p @ i}} -> x * ide {Image=Cod {R} {S} f p @ i} = x) ide-right\n  S.ide-right", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 7 * E E : E", "| ide-right {x : E} : x * ide = x", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => natCoef {Image=Cod {R} {S} f p @ i} 0 = zro {Image=Cod {R} {S} f p @ i}) natCoefZero S.natCoefZero", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| natCoefZero : natCoef 0 = zro", "| natCoef Nat : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| zro : E"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi (n : Nat) ->\n  natCoef {Image=Cod {R} {S} f p @ i} (suc n) = natCoef {Image=Cod {R} {S} f p @ i} n + ide {Image=Cod {R} {S} f p @ i})\n  natCoefSuc S.natCoefSuc", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| \\infixl 6 + E E : E", "\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat", "| natCoef Nat : E", "| natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide", "suc Nat", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| ide : E"]}
{"Context": ["p : IsSurj {R.E} {S.E} f.func", "S : CRing", "R : Ring", "f : RingHom R S"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : E {Image=Cod {R} {S} f p @ i}} -> x * y = y * x) *-comm S.*-comm", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["\\func Image=Cod {R S : Ring} (f : RingHom R S) (p : IsSurj {R.E} {S.E} f.func) : IRing {ringHomImage f} = S \n  => isotoid {RingCat} {IRing {Image {f}}} {S} (image-iso {f} p)", "| *-comm {x y : E} : x * y = y * x", "| \\infixl 7 * E E : E", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S : Ring", "h1 : f.func = g.func", "f : RingHom R S", "g : RingHom R S", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.+ y) = (@) h1 i x S.+ (@) h1 i y) f.func-+ g.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["S : Ring", "h1 : f.func = g.func", "f : RingHom R S", "g : RingHom R S", "R : Ring"], "Expected type": "Path (\\lam (i : I) => (@) h1 i R.ide = S.ide) f.func-ide g.func-ide", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E"]}
{"Context": ["S : Ring", "h1 : f.func = g.func", "f : RingHom R S", "g : RingHom R S", "R : Ring"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.* y) = (@) h1 i x S.* (@) h1 i y) f.func-* g.func-*", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : Ring", "this : Contr (RingHom R S) (\\new RingHom R S ", "f : A {\\this}", "S : Ring", "h1 : (\\lam (_ : R.E) => c.center) = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.+ y) = (@) h1 i x S.+ (@) h1 i y) (func-+ {center {\\this}}) f.func-+", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| center : A", "| \\infixl 6 + E E : E", "| func-+ {x y : E {Dom}} : func (x + y) = func x + func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["R : Ring", "this : Contr (RingHom R S) (\\new RingHom R S ", "f : A {\\this}", "S : Ring", "h1 : (\\lam (_ : R.E) => c.center) = f.func"], "Expected type": "Path (\\lam (i : I) => (@) h1 i R.ide = S.ide) (func-ide {center {\\this}}) f.func-ide", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| center : A", "| func-ide : func (ide {Dom}) = ide {Cod}", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| ide : E"]}
{"Context": ["R : Ring", "this : Contr (RingHom R S) (\\new RingHom R S ", "f : A {\\this}", "S : Ring", "h1 : (\\lam (_ : R.E) => c.center) = f.func"], "Expected type": "Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.* y) = (@) h1 i x S.* (@) h1 i y) (func-* {center {\\this}}) f.func-*", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| center : A", "| \\infixl 7 * E E : E", "| func-* {x y : E {Dom}} : func (x * y) = func x * func y", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["E : CRing", "R : CRing", "f : RingHom R E", "s : \\Sigma (x : E.E) (TruncP (\\Sigma (x1 : Poly R) (func {polyMapEvalRingHom {R} {E1} f a} x1 = x)))", "t : \\Sigma (x : Poly R) (func {polyMapEvalRingHom {R} {E1} f a} x = s.1)", "a : E.E", "pm : isMinPoly f a p", "p : Poly R"], "Expected type": "func {integral_factor {R} {E1} f a p pm.1} (in~ {E {S}} {\\lam (a : E {S}) (b : E {S}) => contains (a - b)} t.1) = s", "Expression": "ext t.2", "Premises": ["| S : BaseSet", "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y", "in~ A", "| contains (E {S}) : \\Prop", "\\func integral_factor \\hlevels  {R E1 : CRing} (f : RingHom R E1) (a : E.E) (p : Poly R) (e : polyEval {E1} (polyMap f p) a = E.zro) :\nRingHom (FactorRing (closure1 {PolyAlgebra R} p)) (cStruct {E1} (polyImage {R} {E1} f a)) {\n  | func => factor-lift.func {closure1 {PolyAlgebra R} p} {cStruct {E1} (polyImage {R} {E1} f a)} {polyImageHomPoly {R} {E1} f a}\n    {\\lam {q : E {S}} (c : contains q) => path (\\lam (i : I) => (\n      \\have arg => \\case (closure1-lem {PolyAlgebra R} {p} {q}).1 c \\with {\n              | inP (d, q=pd) => transportInv {Poly R} (\\lam (x : E) => polyEval {E1} (polyMap f x) a = zro {S}) {q} {p * d} q=pd\n                (transportInv {E.E} (\\lam (x : E {Cod {polyMapEvalRingHom {R} {E1} f a}}) => x = zro {S})\n                  {SetHom.func {polyMapEvalRingHom {R} {E1} f a} (p * d)}\n                  {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d}\n                  (func-* {polyMapEvalRingHom {R} {E1} f a} {p} {d}) (\n                    \\let d1 => \\new CRingData {E1} (polyEval {E1} (polyMap f p) a :: polyEval {E1} (polyMap f d) a :: nil) {\n                           | interpretNF_negate => {?hidden}\n                         }\n                    \\in fromZero {E1} {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d} {zro {S}}\n                          (terms-equality {d1}\n                            (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2}))\n                            (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 1 :* (var {E {d.C}} {Fin (len {d.vars})} 0 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2})) :+ :zro {Int} {Fin 2})\n                            (idp {E.E} {interpretRingNF\n                              {d1} (normalize {d1} (var {Int} {Fin 2} 0 :* var {Int} {Fin 2} 1 :+ :negative {Int} {Fin 2} (:zro {Int} {Fin 2})))}) *> gensZeroToIdealZero {E1}\n                            ((interpret {d1} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1),\n                              polyEval {E1} (polyMap f p) a E.+ E.negative E.zro, toZero {E1} {polyEval {E1} (polyMap f p) a} {E.zro} e) :: nil {\\Sigma E.E (gen : E.E) (gen = E.zro)}))))\n            }\n    \\in (arg @ i,\n          prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (SetHom.func {polyMapEvalRingHom {R} {E1} f a} x = arg @ i)))\n            (SetHom.func {polyImageHomPoly {R} {E1} f a} q).2 zro.2 @ i)))}\n} => factor-lift {closure1 {PolyAlgebra R} p} {cStruct {E1} (polyImage {R} {E1} f a)} (polyImageHomPoly {R} {E1} f a)\n  (\\lam {q : E {S}} (c : contains q) => path (\\lam (i : I) => (\n    \\have arg => \\case (closure1-lem {PolyAlgebra R} {p} {q}).1 c \\with {\n            | inP (d, q=pd) => transportInv {Poly R} (\\lam (x : E) => polyEval {E1} (polyMap f x) a = zro {S}) {q} {p * d} q=pd\n              (transportInv {E.E} (\\lam (x : E {Cod {polyMapEvalRingHom {R} {E1} f a}}) => x = zro {S})\n                {SetHom.func {polyMapEvalRingHom {R} {E1} f a} (p * d)}\n                {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d}\n                (func-* {polyMapEvalRingHom {R} {E1} f a} {p} {d}) (\n                  \\let d1 => \\new CRingData {E1} (polyEval {E1} (polyMap f p) a :: polyEval {E1} (polyMap f d) a :: nil) {\n                         | interpretNF_negate => {?hidden}\n                       }\n                  \\in fromZero {E1} {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d} {zro {S}}\n                        (terms-equality {d1}\n                          (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2}))\n                          (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 1 :* (var {E {d.C}} {Fin (len {d.vars})} 0 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2})) :+ :zro {Int} {Fin 2})\n                          (idp {E.E} {interpretRingNF\n                            {d1} (normalize {d1} (var {Int} {Fin 2} 0 :* var {Int} {Fin 2} 1 :+ :negative {Int} {Fin 2} (:zro {Int} {Fin 2})))}) *> gensZeroToIdealZero {E1}\n                          ((interpret {d1} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1),\n                            polyEval {E1} (polyMap f p) a E.+ E.negative E.zro, toZero {E1} {polyEval {E1} (polyMap f p) a} {E.zro} e) :: nil {\\Sigma E.E (gen : E.E) (gen = E.zro)}))))\n          }\n  \\in (arg @ i,\n        prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (SetHom.func {polyMapEvalRingHom {R} {E1} f a} x = arg @ i)))\n          (SetHom.func {polyImageHomPoly {R} {E1} f a} q).2 zro.2 @ i))))", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| E : \\Set"]}
{"Context": ["R : CRing", "E : CRing", "f : RingHom R E", "s : \\Sigma (x : E.E) (TruncP (\\Sigma (x1 : Poly R) (func {polyMapEvalRingHom {R} {E1} f a} x1 = x)))", "a : E.E", "pm : isMinPoly f a p", "p : Poly R"], "Expected type": "TruncP (\\Sigma (x : Type (closure1 {PolyAlgebra R} p)) (func {integral_factor {R} {E1} f a p pm.1} x = s))", "Expression": "map {?} (\\lam t => (in~ t.1, ext t.2))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "| S : BaseSet", "in~ A", "\\func integral_factor \\hlevels  {R E1 : CRing} (f : RingHom R E1) (a : E.E) (p : Poly R) (e : polyEval {E1} (polyMap f p) a = E.zro) :\nRingHom (FactorRing (closure1 {PolyAlgebra R} p)) (cStruct {E1} (polyImage {R} {E1} f a)) {\n  | func => factor-lift.func {closure1 {PolyAlgebra R} p} {cStruct {E1} (polyImage {R} {E1} f a)} {polyImageHomPoly {R} {E1} f a}\n    {\\lam {q : E {S}} (c : contains q) => path (\\lam (i : I) => (\n      \\have arg => \\case (closure1-lem {PolyAlgebra R} {p} {q}).1 c \\with {\n              | inP (d, q=pd) => transportInv {Poly R} (\\lam (x : E) => polyEval {E1} (polyMap f x) a = zro {S}) {q} {p * d} q=pd\n                (transportInv {E.E} (\\lam (x : E {Cod {polyMapEvalRingHom {R} {E1} f a}}) => x = zro {S})\n                  {SetHom.func {polyMapEvalRingHom {R} {E1} f a} (p * d)}\n                  {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d}\n                  (func-* {polyMapEvalRingHom {R} {E1} f a} {p} {d}) (\n                    \\let d1 => \\new CRingData {E1} (polyEval {E1} (polyMap f p) a :: polyEval {E1} (polyMap f d) a :: nil) {\n                           | interpretNF_negate => {?hidden}\n                         }\n                    \\in fromZero {E1} {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d} {zro {S}}\n                          (terms-equality {d1}\n                            (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2}))\n                            (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 1 :* (var {E {d.C}} {Fin (len {d.vars})} 0 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2})) :+ :zro {Int} {Fin 2})\n                            (idp {E.E} {interpretRingNF\n                              {d1} (normalize {d1} (var {Int} {Fin 2} 0 :* var {Int} {Fin 2} 1 :+ :negative {Int} {Fin 2} (:zro {Int} {Fin 2})))}) *> gensZeroToIdealZero {E1}\n                            ((interpret {d1} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1),\n                              polyEval {E1} (polyMap f p) a E.+ E.negative E.zro, toZero {E1} {polyEval {E1} (polyMap f p) a} {E.zro} e) :: nil {\\Sigma E.E (gen : E.E) (gen = E.zro)}))))\n            }\n    \\in (arg @ i,\n          prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (SetHom.func {polyMapEvalRingHom {R} {E1} f a} x = arg @ i)))\n            (SetHom.func {polyImageHomPoly {R} {E1} f a} q).2 zro.2 @ i)))}\n} => factor-lift {closure1 {PolyAlgebra R} p} {cStruct {E1} (polyImage {R} {E1} f a)} (polyImageHomPoly {R} {E1} f a)\n  (\\lam {q : E {S}} (c : contains q) => path (\\lam (i : I) => (\n    \\have arg => \\case (closure1-lem {PolyAlgebra R} {p} {q}).1 c \\with {\n            | inP (d, q=pd) => transportInv {Poly R} (\\lam (x : E) => polyEval {E1} (polyMap f x) a = zro {S}) {q} {p * d} q=pd\n              (transportInv {E.E} (\\lam (x : E {Cod {polyMapEvalRingHom {R} {E1} f a}}) => x = zro {S})\n                {SetHom.func {polyMapEvalRingHom {R} {E1} f a} (p * d)}\n                {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d}\n                (func-* {polyMapEvalRingHom {R} {E1} f a} {p} {d}) (\n                  \\let d1 => \\new CRingData {E1} (polyEval {E1} (polyMap f p) a :: polyEval {E1} (polyMap f d) a :: nil) {\n                         | interpretNF_negate => {?hidden}\n                       }\n                  \\in fromZero {E1} {SetHom.func {polyMapEvalRingHom {R} {E1} f a} p E.* SetHom.func {polyMapEvalRingHom {R} {E1} f a} d} {zro {S}}\n                        (terms-equality {d1}\n                          (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2}))\n                          (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 1 :* (var {E {d.C}} {Fin (len {d.vars})} 0 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 2})) :+ :zro {Int} {Fin 2})\n                          (idp {E.E} {interpretRingNF\n                            {d1} (normalize {d1} (var {Int} {Fin 2} 0 :* var {Int} {Fin 2} 1 :+ :negative {Int} {Fin 2} (:zro {Int} {Fin 2})))}) *> gensZeroToIdealZero {E1}\n                          ((interpret {d1} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1),\n                            polyEval {E1} (polyMap f p) a E.+ E.negative E.zro, toZero {E1} {polyEval {E1} (polyMap f p) a} {E.zro} e) :: nil {\\Sigma E.E (gen : E.E) (gen = E.zro)}))))\n          }\n  \\in (arg @ i,\n        prop-dpi (\\lam (i : I) => TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (SetHom.func {polyMapEvalRingHom {R} {E1} f a} x = arg @ i)))\n          (SetHom.func {polyImageHomPoly {R} {E1} f a} q).2 zro.2 @ i))))", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "\\func closure1 \\hlevels  {R : CRing} (a : R.E) : Ideal R (\\lam (e : E {S {\\this}}) => TruncP (\\Sigma (l : Array (\\Sigma R.E (\\Sigma)))\n  (e = BigSum {R} (map {\\Sigma R.E (\\Sigma)} {R.E} (\\lam (p : \\Sigma R.E (\\Sigma)) => p.1 R.* a) l)))) \n  => closure {R} {\\Sigma} (\\lam (_ : \\Sigma) => a)", "\\type Type \\hlevels  (I : Ideal) : \\Set => Quotient {E {I.S}} (\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b))", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "| E : \\Set", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["x : E", "s : \\Sigma (c : Array K.E l.len) (x.1 = BigSum {homLModule f} (\\new Array E.E l.len (\\lam (i : Fin l.len) => c.at i *c l.at i)))", "E : CRing", "K : DiscreteField", "f : RingHom K E", "l : Array E.E"], "Expected type": "x = BigSum {homLModule (corestrict {max {E1}} {K} f (\\lam (_ : K.E) => ()))}\n  (\\new Array (\\Sigma E.E (\\Sigma)) l.len (\\lam (i : Fin l.len) => at {s.1} i *c (l.at i, ())))", "Expression": "ext (s.2 *> inv (func-BigSum {embed}))", "Premises": ["\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| \\infixl 7 *c (E {R}) E : E", "\\func max \\hlevels  {R : Ring} : SubRing R (\\lam (_ : E {S}) => \\Sigma) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\func embed \\hlevels  {this2 : SubRing} : RingHom IRing S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func corestrict \\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, p x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\func homLModule \\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\n  | zro => zro {f.Cod}\n  | + => (+) {f.Cod}\n  | negative => negative {f.Cod}\n  | *c => \\lam (x : E {R {\\this}}) => (*) (f.func x)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "| E : \\Set", "\\lemma func-BigSum \\hlevels  {this : AddMonoidHom} {l : Array (E {Dom})} :\n  func (BigSum {Dom} l) = BigSum {Cod} (\\new Array (E {Cod}) l.len (\\lam (j : Fin l.len) => func (l.at j))) "]}
{"Context": ["x : E", "E : CRing", "K : DiscreteField", "lb : IsBasis {homLModule f} l", "f : RingHom K E", "l : Array E.E"], "Expected type": "TruncP (\\Sigma (c : Array K.E l.len) (x = BigSum {homLModule (corestrict {max {E1}} {K} f (\\lam (_ : K.E) => ()))}\n  (\\new Array (\\Sigma E.E (\\Sigma)) l.len (\\lam (i : Fin l.len) => c.at i *c (l.at i, ())))))", "Expression": "map {?} (\\lam s => (s.1, ext $ s.2 *> inv (func-BigSum {embed})))", "Premises": ["\\func map {A B1 : \\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \n  | {A}, {B}, inP a, f => inP {B} (f a)", "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p", "| \\infixl 7 *c (E {R}) E : E", "\\func max \\hlevels  {R : Ring} : SubRing R (\\lam (_ : E {S}) => \\Sigma) => \\new SubRing {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | contains_* => {?hidden}\n  | contains_negative => {?hidden}\n  | contains_ide => {?hidden}\n}", "\\func embed \\hlevels  {this2 : SubRing} : RingHom IRing S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'", "| len : Nat", "\\func BigSum \\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l", "\\func corestrict \\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\n  | func => \\lam (x : E {Dom {\\this}}) => (f.func x, p x)\n} => \\new RingHom {\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)", "\\func homLModule \\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\n  | zro => zro {f.Cod}\n  | + => (+) {f.Cod}\n  | negative => negative {f.Cod}\n  | *c => \\lam (x : E {R {\\this}}) => (*) (f.func x)\n} => \\new LModule {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n}", "| E : \\Set", "\\lemma func-BigSum \\hlevels  {this : AddMonoidHom} {l : Array (E {Dom})} :\n  func (BigSum {Dom} l) = BigSum {Cod} (\\new Array (E {Cod}) l.len (\\lam (j : Fin l.len) => func (l.at j))) ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["a : E.E", "K : DiscreteField", "E : CRing", "f : RingHom K E"], "Expected type": "\\Pi (b : K.E) -> contains (f.func b)", "Expression": "polyImage-ext f a", "Premises": ["\\lemma polyImage-ext \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) (b : R.E) : contains (f.func b) ", "| contains (E {S}) : \\Prop", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)"]}
{"Context": ["a : E.E", "lb : IsBasis {homLModule (polyImageHom {K} {E} f a)} l", "K : DiscreteField", "f : RingHom K E", "E : CRing", "l : Array E"], "Expected type": "TruncP (\\Sigma (p : Poly K) (isMonicMinPoly f a p))", "Expression": "inP (finDim_minPoly f (polyImage f a) (polyImage-ext f a) lb polyImage-element)", "Premises": ["\\lemma polyImage-ext \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) (b : R.E) : contains (f.func b) ", "\\func isMonicMinPoly \\hlevels  (f : RingHom) (a : E {f.Cod}) (p : Poly f.Dom) : \\Prop => \\Sigma (isMonic {f.Dom} p) (isMinPoly f a p)", "\\lemma finDim_minPoly {K : DiscreteField} {E1 : CRing} (f : RingHom K E1) (S : SubRing E1) (SR : \\Pi (x : K.E) -> S.contains (f.func x))\n  {l : Array E} (_ : IsBasis {homLModule (corestrict {S} {K} f SR)} l) {a : E.E} (_ : S.contains a) :\n  \\level (\\Sigma (p : Poly K) (isMonicMinPoly f a p)) (\\lam (s : \\Sigma (p : Poly K) (isMonicMinPoly f a p)) (t : \\Sigma (p : Poly K) (isMonicMinPoly f a p)) =>\n  path (\\lam (i : I) => (\n    \\have arg => unique {K} {f} {a} {s.1} {t.1} s.2 t.2\n    \\in (arg @ i, prop-dpi (\\lam (i : I) => \\Sigma (isMonic {f.Dom} (arg @ i)) (isMinPoly f a (arg @ i))) s.2 t.2 @ i)))) ", "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I", "inP A", "\\func polyImage \\hlevels  {R : Ring} {E1 : CRing} (f : RingHom R E1) (a : E.E) :\nSubRing (Cod {polyMapEvalRingHom {R} {E1} f a}) (\\lam (y : E {S {\\this}}) =>\n  TruncP (\\Sigma (x : E {Dom {polyMapEvalRingHom {R} {E1} f a}}) (func {polyMapEvalRingHom {R} {E1} f a} x = y))) \n  => ringHomImage (polyMapEvalRingHom {R} {E1} f a)", "\\lemma polyImage-element \\hlevels  {R : Ring} {E1 : CRing} {f : RingHom R E1} {a : E.E} : contains a ", "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"]}
{"Context": ["l1 : Localization R S", "R : CRing", "S : SubSet R", "h1 : l1.R' = l2.R'", "l2 : Localization R S", "h2 : Path (\\lam (i : I) => RingHom R (h1 @ i)) l1.inL l2.inL"], "Expected type": "Path (\\lam (i : I) => \\Pi (x : R.E) -> S.contains x -> Inv {h1 @ i} (func {h2 @ i} x)) l1.local l2.local", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| local (x : E {R}) (contains {S} x) : Inv {R'} (func {inL} x)", "| contains (E {S}) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}"]}
{"Context": ["l1 : Localization R S", "R : CRing", "S : SubSet R", "h1 : l1.R' = l2.R'", "l2 : Localization R S", "h2 : Path (\\lam (i : I) => RingHom R (h1 @ i)) l1.inL l2.inL"], "Expected type": "Path (\\lam (i : I) => \\Pi {R'' : CRing} -> \\Pi (f : RingHom R R'') -> (\\Pi (x : R.E) -> S.contains x -> Inv {R''} (f.func x)) ->\n  Contr (\\Sigma (g : RingHom (h1 @ i) R'') (\\Pi (x : R.E) -> g.func (func {h2 @ i} x) = f.func x))) l1.local-univ\n  l2.local-univ", "Expression": "prop-dpi (\\lam i => ext_coe) {?} {?}", "Premises": ["| local-univ {R'' : CRing} (f : RingHom R R'') (\\Pi (x : E {R}) -> contains {S} x -> Inv {R''} (f.func x)) : Contr (\\Sigma (g : RingHom R' R'') (\\Pi (x : E {R}) -> g.func (func {inL} x) = f.func x))", "| contains (E {S}) : \\Prop", "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ", "| E : \\Set", "| func (E {Dom}) : E {Cod}", "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'"]}
{"Context": ["this : Dec", "c : \\Sigma (a b : E) (b#0 : #0 b) (GCD {\\new this {}} a b ide) (x = inl~ {\\new this {}} {subMonoid} (a, b, b#0))", "e : \\Sigma (n : Nat) (LDiv c.2 (pow c.1 n))", "c1#0 : #0 c.1"], "Expected type": "LDiv {nonZeroGCDMonoid} (c.2, c.3) (c.1, c1#0)", "Expression": "gcd_pow_div {{?}} {(c.2, c.3)} {(c.1, c1#0)} {e.1}\n  (transport (LDiv _) (ext $ inv (func-pow {embedMonoid {subMonoid }})) $ ldiv_nonZero {_} {_} {(_, pow_#0  c1#0)} e.2)\n  {?}", "Premises": ["\\lemma ldiv_nonZero \\hlevels  {this : Domain} {a b : E} (_ : LDiv a.1 b.1) : LDiv {nonZeroMonoid} a b ", "\\lemma gcd_pow_div \\hlevels  {this : CancelGCDMonoid} {a b : E} {n : Nat} (_ : LDiv a (pow b n)) (_ : IsCoprime a b) : LDiv a b ", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "\\lemma pow_#0 \\hlevels  {this : Domain} {a : E} {n : Nat} (_ : #0 a) : #0 (pow a n) ", "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a", "| \\infix 8 #0 E : \\Prop", "\\func embedMonoid \\hlevels  {this2 : SubMonoid} : MonoidHom IMonoid S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n} => \\new MonoidHom {\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "\\lemma func-pow \\hlevels  {this : MonoidHom} {x : E {Dom}} {n : Nat} : func (pow {Dom} x n) = pow {Cod} (func x) n ", "\\func subMonoid \\hlevels  {this1 : Domain} : SubMonoid this1 #0 => \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}", "| M : CMonoid", "\\func nonZeroGCDMonoid \\hlevels  {this5 : GCDDomain} : CancelGCDMonoid (\\Sigma (x : E) (#0 x)) {\n  | ide => (ide, zro#ide)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\n} => \\new CancelGCDMonoid {\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | *-comm => {?hidden}\n  | isGCD => {?hidden}\n  | cancel_*-left => {?hidden}\n}"]}
{"Context": ["this : GCDDomain", "g*x#0 : #0 (g.res * inv {g.res|val1})", "g : GCD x.1 y.1", "this : GCD x y (g.res, g#0) (\\new LDiv "], "Expected type": "LDiv {GCD.M {\\this}} (res {\\this}) (val1 {\\this}) (inv {g.res|val1}, #0-*-right {g.res} {inv {g.res|val1}} g*x#0) {\n  | inv-right => {?hidden}\n}", "Expression": "\\new LDiv {\n  | inv => (inv {res|val1 {g}}, #0-*-right  g*x#0)\n  | inv-right => ext (inv-right {res|val1 {g}})\n}", "Premises": ["| \\infixl 7 * E E : E", "| #0-*-right {x y : E} (#0 (x * y)) : #0 y", "| val1 : E {M}", "| inv : E {M}", "| inv-right : val * inv = elem", "| res|val1 : LDiv {M} res val1", "| M : Monoid", "| val : E {M}", "| res : E {M}", "| \\infix 8 #0 E : \\Prop", "| M : CMonoid"]}
{"Context": ["this : GCDDomain", "g : GCD x.1 y.1", "y : E {\\this}", "this : GCD x y (g.res, g#0) (\\new LDiv "], "Expected type": "LDiv {GCD.M {\\this}} (res {\\this}) (val2 {\\this}) (Monoid.DivBase.inv {g.res|val2},\n  #0-*-right {g.res} {Monoid.DivBase.inv {g.res|val2}} (transport {E} #0 {y.1} {g.res * Monoid.DivBase.inv {g.res|val2}}\n    (Paths.inv {E} {g.res * Monoid.DivBase.inv {g.res|val2}} {y.1} (inv-right {g.res|val2})) y.2)) {\n  | inv-right => {?hidden}\n}", "Expression": "\\new LDiv {\n  | inv => (inv {res|val2 {g}}, #0-*-right  (transport (#0 ) (inv (inv-right {res|val2 {g}})) y.2))\n  | inv-right => ext (inv-right {res|val2 {g}})\n}", "Premises": ["| \\infixl 7 * E E : E", "| #0-*-right {x y : E} (#0 (x * y)) : #0 y", "| res|val2 : LDiv {M} res val2", "| inv : E {M}", "| inv-right : val * inv = elem", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "| val2 : E {M}", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| M : Monoid", "| val : E {M}", "| res : E {M}", "| \\infix 8 #0 E : \\Prop", "| E : \\Set", "| M : CMonoid"]}
{"Context": ["this : GCDDomain", "g#0 : #0 g.res", "g : GCD x.1 y.1", "h : E {M {\\this}}", "this : GCD x y (g.res, g#0) (\\new LDiv ", "h|g : LDiv "], "Expected type": "LDiv {GCD.M {\\this}} h (res {\\this}) (h|g.inv,\n  #0-*-right {h.1} {h|g.inv} (transport {E} #0 {g.res} {h.1 * h|g.inv} (Paths.inv {E} {h.1 * h|g.inv} {g.res} h|g.inv-right) g#0)) {\n  | inv-right => {?hidden}\n}", "Expression": "\\new LDiv {\n  | inv => (inv {h|g}, #0-*-right  (transport (#0 ) (inv (inv-right {h|g})) g#0))\n  | inv-right => ext (inv-right {h|g})\n}", "Premises": ["| \\infixl 7 * E E : E", "| #0-*-right {x y : E} (#0 (x * y)) : #0 y", "| inv : E {M}", "| inv-right : val * inv = elem", "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right", "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}", "| M : Monoid", "| res : E {M}", "| \\infix 8 #0 E : \\Prop", "| E : \\Set", "| M : CMonoid"]}
